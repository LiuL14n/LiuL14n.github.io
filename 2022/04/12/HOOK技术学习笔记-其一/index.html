<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/xintiao_32.png?v=7.1.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/xintiao_16.png?v=7.1.0"><link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222"><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.1.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="article"><meta property="og:title" content="HOOK技术学习笔记-其一"><meta property="og:url" content="http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/index.html"><meta property="og:site_name" content="LiuLian"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://liul14nimg.oss-cn-qingdao.aliyuncs.com/liul14nimg/97547828_p0.jpg"><meta property="og:updated_time" content="2022-07-15T03:57:31.350Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HOOK技术学习笔记-其一"><meta name="twitter:image" content="https://liul14nimg.oss-cn-qingdao.aliyuncs.com/liul14nimg/97547828_p0.jpg"><link rel="canonical" href="http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>HOOK技术学习笔记-其一 | LiuLian</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">LiuLian</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类<span class="badge">8</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档<span class="badge">60</span></a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="LiuLian"><meta itemprop="description" content="Salute The Time"><meta itemprop="image" content="/images/touxiang.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LiuLian"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">HOOK技术学习笔记-其一</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-04-12 00:52:14" itemprop="dateCreated datePublished" datetime="2022-04-12T00:52:14+08:00">2022-04-12</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-07-15 11:57:31" itemprop="dateModified" datetime="2022-07-15T11:57:31+08:00">2022-07-15</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/随手小记/" itemprop="url" rel="index"><span itemprop="name">随手小记</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">53k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">44 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://liul14nimg.oss-cn-qingdao.aliyuncs.com/liul14nimg/97547828_p0.jpg" alt></p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>再来系统学习一下之前学的不扎实的HOOK技术:cry:</p><p>HOOK技术，用好了能有很奇妙的效果哟~</p><p>可以对程序的执行流进行监控、拦截。举个例子：键盘钩子，可以监控用户通过键盘输入了什么:happy:</p><p>本文重点去讨论<code>HOOK过程的原子性</code></p><h1 id="0x01-HOOK的几种分类"><a href="#0x01-HOOK的几种分类" class="headerlink" title="0x01 HOOK的几种分类"></a>0x01 HOOK的几种分类</h1><p>HOOK技术可以分为<code>Inline Hook</code>、<code>Address Hook</code>、<code>基于异常处理的Hook</code>、<code>不是HOOK的HOOK</code>等</p><h2 id="1-Inline-Hook"><a href="#1-Inline-Hook" class="headerlink" title="1. Inline Hook"></a>1. Inline Hook</h2><p>Inline Hook是指直接修改指令的Hook，其关键是转移程序的执行流程，一般用jmp、call、retn等转移指令</p><h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><ol><li>jmp xxxxxxxx(5字节)</li><li>push xxxxxxxx / retn(6字节)</li><li>mov eax,xxxxxxxx / jmp eax(7字节)</li><li>call Hook</li><li>HotPatch Hook</li></ol><h2 id="2-Address-Hook"><a href="#2-Address-Hook" class="headerlink" title="2. Address Hook"></a>2. Address Hook</h2><p>Address Hook是指通过修改数据来进行Hook，这些数据往往是一些函数的地址或者偏移量，它们通常存放在某类数据结构中或是指定位置处，也可能是存在于寄存器中。它们有一个共同点，就是会在某时刻成为执行过程中的eip，因此将这数据替换成我们想要的函数地址就实现了Hook</p><h3 id="几种常见形式-1"><a href="#几种常见形式-1" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><ol><li>IAT(Import Address Table,输入表)</li><li>EAT(Export Address Table,输出表)</li><li>user32.dll的回调函数表</li><li>IDT(Interrupt Descriptor Table,系统的中断描述符表)</li><li>SSDT和Shadow SSDT</li><li>C++类的虚函数表</li><li>COM接口的功能函数表</li><li>特殊寄存器中的地址</li><li>特定的函数指针</li></ol><h2 id="3-基于异常处理的Hook"><a href="#3-基于异常处理的Hook" class="headerlink" title="3. 基于异常处理的Hook"></a>3. 基于异常处理的Hook</h2><p>在程序中自行安装SEH，向被HOOK的位置写入一条会引发异常的指令，只要程序执行到这里就会触发异常，从而跳转到事先安装的异常处理程序处。</p><h2 id="4-不是HOOK的HOOK"><a href="#4-不是HOOK的HOOK" class="headerlink" title="4. 不是HOOK的HOOK"></a>4. 不是HOOK的HOOK</h2><p>回顾病毒和操作系统的一些行为，都是在某些时候取得程序的控制权，并进行适当的处理。</p><h3 id="几种常见的形式"><a href="#几种常见的形式" class="headerlink" title="几种常见的形式"></a>几种常见的形式</h3><ol><li><p>PE被感染，修改EnterPoint</p><p>会在执行完病毒代码后跳回正常的程序入口，使其不易被察觉。</p></li><li><p>系统回调机制</p></li><li><p>分层服务和过滤驱动模型</p></li></ol><h1 id="0x02-几个细节"><a href="#0x02-几个细节" class="headerlink" title="0x02 几个细节"></a>0x02 几个细节</h1><h2 id="1-裸函数-naked"><a href="#1-裸函数-naked" class="headerlink" title="1. 裸函数 naked"></a>1. 裸函数 naked</h2><p>__declspec(naked) 告诉编译器，以下的汇编不需要编译器再优化什么指令。</p><h2 id="2-系统位数引起的细节问题"><a href="#2-系统位数引起的细节问题" class="headerlink" title="2. 系统位数引起的细节问题"></a>2. 系统位数引起的细节问题</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针在x86上4字节，在x64上8字节。</p><p>可以使用<code>ULONG_PTR</code>来自适应于编译器，类似的还有<code>SIZE_T</code></p><h3 id="内存地址对齐"><a href="#内存地址对齐" class="headerlink" title="内存地址对齐"></a>内存地址对齐</h3><p>x64最好按照16字节来对齐，尽管x64对应8字节</p><h3 id="PE格式"><a href="#PE格式" class="headerlink" title="PE格式"></a>PE格式</h3><p>影响依照PE结构的HOOK</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>x64仅有<code>__fastcall</code>调用方式</p><p>用寄存器来传参</p><p>第1~4个整型参数依次按照<code>RCX、RDX、R8、R9</code>来传参</p><p>第1~4个浮点参数依次按照<code>XMM0、XMM1、XMM2、XMM3</code>来传参</p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>对于直接跳转指令<code>E9</code>，跳转范围以当前位置为界，前后各2GB，在X86平台完全够用，但是在X64平台就不够了。</p><p>所以在64位的情况下，jmp必须直接包含目标地址</p><p>可以用</p><p><code>mov rax,addr / jmp rax</code></p><p><code>push ret</code></p><p><code>jmp [addr]</code>其中此jmp为<code>FF25</code>且<code>Address = eip + 偏移量 + 6(指令长度)</code></p><h3 id="PatchGuard"><a href="#PatchGuard" class="headerlink" title="PatchGuard"></a>PatchGuard</h3><h2 id="3-一个经典的问题"><a href="#3-一个经典的问题" class="headerlink" title="3. 一个经典的问题"></a>3. 一个经典的问题</h2><p>我们该如何保证HOOK的原子性？</p><p>即，我们如何保证负责HOOK的线程在进行HOOK的时候，其他线程不会访问被HOOK但还没完成HOOK的代码段？</p><p>这里提出几种解决方案，这几种解决方案均是受启发于《Windows核心编程》这本经典著作。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>我们可以在执行HOOK的时候，挂起(Suspend)其他一切无关的线程，在HOOK完毕后再恢复(Resume)其他线程。</p><p>不过，这个方案相比方案二，<strong>耗时会较多一些</strong>。</p><p>相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Solution1</span><span class="params">(BOOL isSuspend)</span> </span>&#123;</span><br><span class="line">	HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwPid = GetCurrentProcessId();</span><br><span class="line">	DWORD dwTid = GetCurrentThreadId();</span><br><span class="line">	THREADENTRY32 stThreadEntry32;</span><br><span class="line">	stThreadEntry32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line">	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL anymore = Thread32First(hSnapshot, &amp;stThreadEntry32);</span><br><span class="line">	<span class="keyword">while</span> (anymore) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stThreadEntry32.th32OwnerProcessID == dwPid &amp;&amp; stThreadEntry32.th32ThreadID != dwTid) &#123;</span><br><span class="line">			hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, stThreadEntry32.th32ThreadID);</span><br><span class="line">			<span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isSuspend) &#123;</span><br><span class="line">				SuspendThread(hThread);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ResumeThread(hThread);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseHandle(hThread);</span><br><span class="line">		&#125;</span><br><span class="line">		anymore = Thread32Next(hSnapshot, &amp;stThreadEntry32);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hSnapshot);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>我们可以借助Windows提供的具有原子性的API，例如</p><p><code>InterlockedExchange</code>系列与<code>InterlockedCompareExchange</code>系列</p><p>但是值得注意的是，这两个系列均仅支持修改1/2/4/8字节，并不支持修改其他字节，是的，我并没有找到直接修改HOOK所需的5或者7字节的API，但是这并不妨碍我们进行修改，例如我们的Inline Hook往往是需要修改5或者7字节，这都小于8字节，因此我们可以调用<code>InterlockedExchange64</code>来直接修改8字节！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Install</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (originalCodeAddr == <span class="number">0</span> || originalSize &lt; <span class="number">5</span> || originalSize &gt; <span class="number">8</span> || newCodeAddr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置内存写权限</span></span><br><span class="line">	DWORD dwOldProtectFlag;</span><br><span class="line">	BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算E9 JMP后面的4字节 = 要跳转的地址 - CALL的下一条指令的地址</span></span><br><span class="line">	DWORD dwJmpCode = newCodeAddr - (originalCodeAddr + <span class="number">5</span>);</span><br><span class="line">	<span class="comment">// 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节</span></span><br><span class="line">	BYTE bReplace[<span class="number">8</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;<span class="comment">//全部用NOP替换</span></span><br><span class="line">	bReplace[<span class="number">0</span>] = <span class="number">0xE9</span>; <span class="comment">// JMP</span></span><br><span class="line"></span><br><span class="line">	*(PDWORD)(&amp;(bReplace[<span class="number">1</span>])) = dwJmpCode;<span class="comment">//☆体会这种语句的好处</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓</span></span><br><span class="line">	<span class="built_in">memcpy</span>( (BYTE*)(bReplace + originalSize),</span><br><span class="line">		(LPVOID)(originalCodeAddr + originalSize), <span class="number">8</span> - originalSize);<span class="comment">//把后面字节copy过来</span></span><br><span class="line"></span><br><span class="line">	LONG64 llReplace;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;llReplace, bReplace, <span class="number">8</span>);<span class="comment">//全都copy给一个64位的变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原子操作hook</span></span><br><span class="line">	InterlockedExchange64((LONG64 <span class="keyword">volatile</span>*)originalCodeAddr, llReplace);</span><br><span class="line">	<span class="comment">// 恢复内存属性</span></span><br><span class="line">	VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, dwOldProtectFlag, &amp;dwOldProtectFlag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Uninstall</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, BYTE * oldCodeAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (originalCodeAddr == <span class="number">0</span> || originalSize &lt; <span class="number">5</span> || originalSize &gt; <span class="number">8</span> || oldCodeAddr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置内存写权限</span></span><br><span class="line">	DWORD dwOldProtectFlag;</span><br><span class="line">	BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节</span></span><br><span class="line">	BYTE bReplace[<span class="number">8</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;<span class="comment">//全部用NOP替换</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓</span></span><br><span class="line">	<span class="built_in">memcpy</span>((BYTE*)bReplace, (LPVOID)(oldCodeAddr), originalSize);<span class="comment">//还原原始的</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>((BYTE*)(bReplace + originalSize),</span><br><span class="line">		(LPVOID)(originalCodeAddr + originalSize), <span class="number">8</span> - originalSize);<span class="comment">//把后面字节copy过来</span></span><br><span class="line"></span><br><span class="line">	LONG64 llReplace;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;llReplace, bReplace, <span class="number">8</span>);<span class="comment">//全都copy给一个64位的变量</span></span><br><span class="line">	<span class="comment">// 原子操作hook</span></span><br><span class="line">	InterlockedExchange64((LONG64 <span class="keyword">volatile</span>*)originalCodeAddr, llReplace);</span><br><span class="line">	<span class="comment">// 恢复内存属性</span></span><br><span class="line">	VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, dwOldProtectFlag, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>借助信号量机制。</p><p>首先，我们进行修改内存的时候极有可能使用<code>memcpy</code>这个函数，而这个函数并不是线程安全函数，引用自StackOverflow</p><blockquote><p>memcpy is typically coded for raw speed. It will not be thread safe. If you require this, you need to perform the memcpy call inside of a critical section or use some other semaphor mechanism.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; take_mutex(&amp;mutex);</span><br><span class="line">&gt; <span class="built_in">memcpy</span>(dst, src, count);</span><br><span class="line">&gt; yield_mutex(&amp;mutex);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="0x03-HOOK实例"><a href="#0x03-HOOK实例" class="headerlink" title="0x03 HOOK实例"></a>0x03 HOOK实例</h1><p>来写一个DLL来稍微练习一下HOOK</p><p>同时为了应用上述提到的实现原子性的方案，给出多种代码作为参考。</p><h2 id="各方案共同的代码"><a href="#各方案共同的代码" class="headerlink" title="各方案共同的代码"></a>各方案共同的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InlineHook.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">HookMessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">	UINT		   uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案一,依据BOOL型参数来决定是挂起还是恢复</span></span><br><span class="line"><span class="function">BOOL <span class="title">Solution1</span><span class="params">(BOOL isSuspend)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Install</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Uninstall</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, BYTE* oldCodeAddr)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InlineHook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		InitHook();</span><br><span class="line">		InstallHook();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		UnInstallHook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InlineHook.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InlineHook.h"</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_unHook = <span class="literal">NULL</span>;<span class="comment">//保存函数地址</span></span><br><span class="line">BYTE g_oldCode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//原始的5个字节</span></span><br><span class="line">BYTE g_newCode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;<span class="comment">//改变后的5个字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">HookMessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">	UINT		   uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">	UnInstallHook();<span class="comment">//先卸载钩子，防止死循环</span></span><br><span class="line">	<span class="keyword">int</span> result = MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"HOOK Success"</span>), TEXT(<span class="string">"test4fun"</span>), MB_OK);</span><br><span class="line">	InstallHook();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HMODULE hMoudle = LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hMoudle) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	g_unHook = (DWORD)GetProcAddress(hMoudle, <span class="string">"MessageBoxA"</span>);</span><br><span class="line">	memcpy_s(g_oldCode, <span class="number">5</span>, (BYTE*)g_unHook, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	DWORD offset = (DWORD)HookMessageBox - g_unHook - <span class="number">5</span>;</span><br><span class="line">	memcpy_s(g_newCode + <span class="number">1</span>, <span class="number">4</span>, &amp;offset, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!g_unHook) &#123;<span class="comment">//初始化未成功</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Solution1(TRUE);<span class="comment">//挂起全部其他线程</span></span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;<span class="comment">//原来的内存属性</span></span><br><span class="line">	VirtualProtect((DWORD*)g_unHook, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtect);<span class="comment">//修改内存地址可读可写可执行</span></span><br><span class="line">	memcpy_s((DWORD*)g_unHook, <span class="number">5</span>, g_newCode, <span class="number">5</span>);<span class="comment">//把要改变的5个字节写到函数地址里</span></span><br><span class="line">	VirtualProtect((DWORD*)g_unHook, <span class="number">5</span>, OldProtect, &amp;OldProtect);<span class="comment">//再将内存属性改回去</span></span><br><span class="line">	Solution1(FALSE);<span class="comment">//恢复全部其他线程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!g_unHook) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Solution1(TRUE);<span class="comment">//挂起其他全部线程</span></span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;<span class="comment">//原来的内存属性</span></span><br><span class="line">	VirtualProtect((DWORD*)g_unHook, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtect);<span class="comment">//修改内存地址可读可写可执行</span></span><br><span class="line">	memcpy_s((DWORD*)g_unHook, <span class="number">5</span>, g_oldCode, <span class="number">5</span>);<span class="comment">//把原来的5个字节写到函数地址里</span></span><br><span class="line">	VirtualProtect((DWORD*)g_unHook, <span class="number">5</span>, OldProtect, &amp;OldProtect);<span class="comment">//再将内存属性改回去</span></span><br><span class="line">	Solution1(FALSE);<span class="comment">//恢复其他全部线程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution1</span><span class="params">(BOOL isSuspend)</span> </span>&#123;</span><br><span class="line">	HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwPid = GetCurrentProcessId();</span><br><span class="line">	DWORD dwTid = GetCurrentThreadId();</span><br><span class="line">	THREADENTRY32 stThreadEntry32;</span><br><span class="line">	stThreadEntry32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line">	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwPid);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	BOOL anymore = Thread32First(hSnapshot, &amp;stThreadEntry32);</span><br><span class="line">	<span class="keyword">while</span> (anymore) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stThreadEntry32.th32OwnerProcessID == dwPid &amp;&amp; stThreadEntry32.th32ThreadID != dwTid) &#123;</span><br><span class="line">			hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, stThreadEntry32.th32ThreadID);</span><br><span class="line">			<span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isSuspend) &#123;</span><br><span class="line">				SuspendThread(hThread);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ResumeThread(hThread);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseHandle(hThread);</span><br><span class="line">		&#125;</span><br><span class="line">		anymore = Thread32Next(hSnapshot, &amp;stThreadEntry32);</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hSnapshot);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InlineHook.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"InlineHook.h"</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_unHook = <span class="literal">NULL</span>;<span class="comment">//保存函数地址</span></span><br><span class="line">BYTE g_oldCode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//原始的5个字节</span></span><br><span class="line">BYTE g_newCode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;<span class="comment">//改变后的5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">HookMessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HWND    hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">	UINT		   uType</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">	UnInstallHook();<span class="comment">//先卸载钩子，防止死循环</span></span><br><span class="line">	<span class="keyword">int</span> result = MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"HOOK Success!"</span>), TEXT(<span class="string">"Test4fun"</span>), MB_OK);</span><br><span class="line">	InstallHook();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HMODULE hMoudle = LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!hMoudle) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	g_unHook = (DWORD)GetProcAddress(hMoudle, <span class="string">"MessageBoxA"</span>);</span><br><span class="line">	memcpy_s(g_oldCode, <span class="number">5</span>, (BYTE*)g_unHook, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!g_unHook) &#123;<span class="comment">//初始化未成功</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Solution2_Install(g_unHook, <span class="number">5</span>, (DWORD)HookMessageBox);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!g_unHook) &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Solution2_Uninstall(g_unHook, <span class="number">5</span>, g_oldCode);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Install</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originalCodeAddr == <span class="number">0</span> || originalSize &lt; <span class="number">5</span> || originalSize &gt; <span class="number">8</span> || newCodeAddr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置内存写权限</span></span><br><span class="line">	DWORD dwOldProtectFlag;</span><br><span class="line">	BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算E9 JMP后面的4字节 = 要跳转的地址 - CALL的下一条指令的地址</span></span><br><span class="line">	DWORD dwJmpCode = newCodeAddr - (originalCodeAddr + <span class="number">5</span>);</span><br><span class="line">	<span class="comment">// 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节</span></span><br><span class="line">	BYTE bReplace[<span class="number">8</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;<span class="comment">//全部用NOP替换</span></span><br><span class="line">	bReplace[<span class="number">0</span>] = <span class="number">0xE9</span>; <span class="comment">// JMP</span></span><br><span class="line"></span><br><span class="line">	*(PDWORD)(&amp;(bReplace[<span class="number">1</span>])) = dwJmpCode;<span class="comment">//☆体会这种语句的好处</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓</span></span><br><span class="line">	<span class="built_in">memcpy</span>( (BYTE*)(bReplace + originalSize),</span><br><span class="line">		(LPVOID)(originalCodeAddr + originalSize), <span class="number">8</span> - originalSize);<span class="comment">//把后面字节copy过来</span></span><br><span class="line"></span><br><span class="line">	LONG64 llReplace;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;llReplace, bReplace, <span class="number">8</span>);<span class="comment">//全都copy给一个64位的变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原子操作hook</span></span><br><span class="line">	InterlockedExchange64((LONG64 <span class="keyword">volatile</span>*)originalCodeAddr, llReplace);</span><br><span class="line">	<span class="comment">// 恢复内存属性</span></span><br><span class="line">	VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, dwOldProtectFlag, &amp;dwOldProtectFlag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Solution2_Uninstall</span><span class="params">(DWORD originalCodeAddr, DWORD originalSize, BYTE * oldCodeAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (originalCodeAddr == <span class="number">0</span> || originalSize &lt; <span class="number">5</span> || originalSize &gt; <span class="number">8</span> || oldCodeAddr == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置内存写权限</span></span><br><span class="line">	DWORD dwOldProtectFlag;</span><br><span class="line">	BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">if</span> (!bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节</span></span><br><span class="line">	BYTE bReplace[<span class="number">8</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;<span class="comment">//全部用NOP替换</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓</span></span><br><span class="line">	<span class="built_in">memcpy</span>((BYTE*)bReplace, (LPVOID)(oldCodeAddr), originalSize);<span class="comment">//还原原始的</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>((BYTE*)(bReplace + originalSize),</span><br><span class="line">		(LPVOID)(originalCodeAddr + originalSize), <span class="number">8</span> - originalSize);<span class="comment">//把后面字节copy过来</span></span><br><span class="line"></span><br><span class="line">	LONG64 llReplace;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;llReplace, bReplace, <span class="number">8</span>);<span class="comment">//全都copy给一个64位的变量</span></span><br><span class="line">	<span class="comment">// 原子操作hook</span></span><br><span class="line">	InterlockedExchange64((LONG64 <span class="keyword">volatile</span>*)originalCodeAddr, llReplace);</span><br><span class="line">	<span class="comment">// 恢复内存属性</span></span><br><span class="line">	VirtualProtect((LPVOID)originalCodeAddr, <span class="number">8</span>, dwOldProtectFlag, &amp;dwOldProtectFlag);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个用于测试的demo"><a href="#一个用于测试的demo" class="headerlink" title="一个用于测试的demo"></a>一个用于测试的demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMoudle = LoadLibrary(<span class="string">"InlineHookTest.dll"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hMoudle)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"HOOK Failed"</span>), TEXT(<span class="string">"test4fun"</span>), MB_OK);<span class="comment">//调用MessageBox来检测</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果HOOK成功以后，弹出的MessageBox应该是HOOK Success</span></span><br><span class="line">    <span class="comment">//否则就会是这个HOOK Failed</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p>《加密与解密》第四版</p><p>《逆向工程核心原理》</p><p><a href="https://blog.csdn.net/qq_31507523/article/details/92800468?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-92800468-blog-7269486.pc_relevant_antiscanv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-92800468-blog-7269486.pc_relevant_antiscanv3&utm_relevant_index=2" target="_blank" rel="noopener">多线程inline hook</a></p><p><a href="https://blog.csdn.net/Kwansy/article/details/108549163?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-108549163-blog-7269486.pc_relevant_antiscanv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-108549163-blog-7269486.pc_relevant_antiscanv3&utm_relevant_index=5" target="_blank" rel="noopener">多线程inline hook</a></p><p><a href="https://blog.51cto.com/u_15127640/4356145?b=totalstatistic" target="_blank" rel="noopener">inline hook需要注意的问题</a></p><p><code>inline hook需要注意的问题</code>这一篇里面关于挂起线程和恢复线程的代码是存在问题的，它挂起的是所有进程的线程而非目标进程的线程，<strong>本文已经对其代码进行了修改完善</strong>，不过仍要感谢文章作者提供的思路！</p><p><a href="https://stackoverflow.com/questions/15145152/is-memcpy-process-safe" target="_blank" rel="noopener">memcpy是否线程安全</a></p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------至此本文结束<i class="fa fa-tree"></i>感谢您的阅读-------------</div></div></div><div><div id="reward-container"><div>如果觉得这篇文章对您有用，请随意打赏。 (๑•⌄•๑) 您的支持将鼓励我继续创作！</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/Wechat_SKM.png" alt="LiuLian 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/ZFB_SKM.png" alt="LiuLian 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>LiuLian</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/" title="HOOK技术学习笔记-其一">http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2022/03/18/CRC-Check-Bypass/" rel="next" title="CRC Check Bypass"><i class="fa fa-chevron-left"></i> CRC Check Bypass</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2022/05/23/DLL输出调试信息的几种方式/" rel="prev" title="DLL输出调试信息的几种方式">DLL输出调试信息的几种方式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang.jpeg" alt="LiuLian"><p class="site-author-name" itemprop="name">LiuLian</p><div class="site-description motion-element" itemprop="description">Salute The Time</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">60</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/LiuL14n" title="GitHub &rarr; https://github.com/LiuL14n" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=aFlZWl1aWVxcWVEoGRlGCwcF" title="E-Mail &rarr; http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=aFlZWl1aWVxcWVEoGRlGCwcF" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=1125214419&site=qq&menu=yes" title="QQ &rarr; http://wpa.qq.com/msgrd?v=3&uin=1125214419&site=qq&menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> From 大佬 import&nbsp; <i class="fa fa-fw fa-link"></i></div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://suxinghe39.github.io/" title="SuXingHe" target="_blank">SuXingHe</a></li><li class="links-of-blogroll-item"><a href="https://hal900000.github.io" title="Hal90000" target="_blank">Hal90000</a></li><li class="links-of-blogroll-item"><a href="http://n4tsu.top/" title="Natsu" target="_blank">Natsu</a></li><li class="links-of-blogroll-item"><a href="https://dililidala.github.io" title="Ohrxw" target="_blank">Ohrxw</a></li><li class="links-of-blogroll-item"><a href="http://www.wendev.site" title="JiangWen" target="_blank">JiangWen</a></li><li class="links-of-blogroll-item"><a href="https://l0ne1y.xyz/" title="L0ne1y" target="_blank">L0ne1y</a></li></ul><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("04/25/2019 21:13:14"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-前言"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-HOOK的几种分类"><span class="nav-number">2.</span> <span class="nav-text">0x01 HOOK的几种分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Inline-Hook"><span class="nav-number">2.1.</span> <span class="nav-text">1. Inline Hook</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几种常见形式"><span class="nav-number">2.1.1.</span> <span class="nav-text">几种常见形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Address-Hook"><span class="nav-number">2.2.</span> <span class="nav-text">2. Address Hook</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几种常见形式-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">几种常见形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基于异常处理的Hook"><span class="nav-number">2.3.</span> <span class="nav-text">3. 基于异常处理的Hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-不是HOOK的HOOK"><span class="nav-number">2.4.</span> <span class="nav-text">4. 不是HOOK的HOOK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几种常见的形式"><span class="nav-number">2.4.1.</span> <span class="nav-text">几种常见的形式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-几个细节"><span class="nav-number">3.</span> <span class="nav-text">0x02 几个细节</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-裸函数-naked"><span class="nav-number">3.1.</span> <span class="nav-text">1. 裸函数 naked</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-系统位数引起的细节问题"><span class="nav-number">3.2.</span> <span class="nav-text">2. 系统位数引起的细节问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">3.2.1.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存地址对齐"><span class="nav-number">3.2.2.</span> <span class="nav-text">内存地址对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PE格式"><span class="nav-number">3.2.3.</span> <span class="nav-text">PE格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用约定"><span class="nav-number">3.2.4.</span> <span class="nav-text">调用约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳转指令"><span class="nav-number">3.2.5.</span> <span class="nav-text">跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PatchGuard"><span class="nav-number">3.2.6.</span> <span class="nav-text">PatchGuard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-一个经典的问题"><span class="nav-number">3.3.</span> <span class="nav-text">3. 一个经典的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方案一"><span class="nav-number">3.3.1.</span> <span class="nav-text">方案一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案二"><span class="nav-number">3.3.2.</span> <span class="nav-text">方案二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案三"><span class="nav-number">3.3.3.</span> <span class="nav-text">方案三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-HOOK实例"><span class="nav-number">4.</span> <span class="nav-text">0x03 HOOK实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#各方案共同的代码"><span class="nav-number">4.1.</span> <span class="nav-text">各方案共同的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案一-1"><span class="nav-number">4.2.</span> <span class="nav-text">方案一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案二-1"><span class="nav-number">4.3.</span> <span class="nav-text">方案二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个用于测试的demo"><span class="nav-number">4.4.</span> <span class="nav-text">一个用于测试的demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-参考"><span class="nav-number">5.</span> <span class="nav-text">0x04 参考</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love" id="animate"><i class="fa fa-star"></i> </span><span class="author" itemprop="copyrightHolder">LiuLian</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数:<span id="busuanzi_value_site_pv"></span></span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-s"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="255,105,180" opacity="0.6" zindex="-1" count="77" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.0"></script><script src="/js/motion.js?v=7.1.0"></script><script src="/js/affix.js?v=7.1.0"></script><script src="/js/schemes/pisces.js?v=7.1.0"></script><script src="/js/scrollspy.js?v=7.1.0"></script><script src="/js/post-details.js?v=7.1.0"></script><script src="/js/next-boot.js?v=7.1.0"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=t,document.body.appendChild(n),n.select(),n.setSelectionRange(0,t.length),n.readOnly=!1;document.execCommand("copy");n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script><script type="text/javascript" color="0,191,255" opacity="1" zindex="-2" count="60" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/clicklove.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:210,height:420},mobile:{show:!0},log:!1})</script></body></html>